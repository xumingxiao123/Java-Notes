[TOC]

# 规划（一个月内）

#### 1. 看什么？

* 《第一行代码》

* github上的开源项目（**5个**）

#### 2. 做什么？

* 自己做两个项目并上架谷歌商城
  * 类似于githu提交记录去制作一个手机使用时间的说明，分为轻度，中度，重度

#### 3. 其他？

* 阅读java全部源码（领悟设计模式，代码规范，实现思想）
* 玩转字节码和虚拟机
* 深入操作系统层面
* 编程：每天2题及以上
* 专业课不能忘！

| 日期 | 书籍                   | 看项目      | 做项目 | Java | 编程       |
| ---- | ---------------------- | ----------- | ------ | ---- | ---------- |
| 8.16 | 《第一行代码》p0-82    |             |        |      |            |
| 8.17 | 《第一行代码》p82-111  |             |        |      |            |
| 8.18 | 《第一行代码》p111-243 |             |        |      | 二叉搜索树 |
| 8.19 | 《第一行代码》p243-400 |             |        |      |            |
| 8.20 | 《第一行代码》p400-600 |             |        |      |            |
| 8.21 |                        | 天气预报App |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |

# 总结（10大问题）

# 安卓开发之路第一天（8.16）

### 事件1：阅读《第一行代码》P1-82

#### 第一章：第一行代码

##### 1.  安卓的发展

##### 2. 搭建开发环境

模拟器选择：**pixel**

##### 3. 创建第一个安卓开发环境

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817092618656.png" alt="image-20200817092618656" style="zoom:50%;" />

##### 4.详解安卓开发目录结构

* **grable是什么？**

Gradle 是一个基于 [Apache Ant](https://www.oschina.net/p/apache+ant) 和 [Apache Maven](https://www.oschina.net/p/maven) 概念的项目自动化构建工具，支持依赖管理和多项目，类似 [Maven](https://www.oschina.net/p/maven)，但比之简单轻便。它使用一种基于 [Groovy](https://www.oschina.net/p/groovy) 的特定领域语言来声明项目设置，而不是传统的 XML。

当前其支持的语言限于 Java、Groovy 和 Scala，计划未来将支持更多的语言。

1. **project目录**

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817100902922.png" alt="image-20200817100902922" style="zoom:80%;" />

2. **app目录**



<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817101447841.png" alt="image-20200817101447841" style="zoom:80%;" />

3. **AndroidManifest**

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myfistapp">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

4. **Manifest**

```java
package com.example.myfistapp;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
//AppCompatActivity向下兼容的Activity
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //视图和逻辑分离，所以没有helloword
        super.onCreate(savedInstanceState);
        //引入了一个ContentView布局
        setContentView(R.layout.activity_main);
    }
}
```

5. **R.layout.activity_main**

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />


</androidx.constraintlayout.widget.ConstraintLayout>
~~~

6. **如何引用？**

代码中：R.layout.activity_main

XML中：android:icon="@mipmap/ic_launcher"

7.  外层grable

```java
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    //代码仓库
    repositories {
        google()
        jcenter()
    }
    //
    dependencies {
        classpath "com.android.tools.build:gradle:4.0.1"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories 
        //两个插件
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁.

8. 内层grable

~~~java
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.example.myfistapp"
        minSdkVersion 15
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'

}
~~~

##### 5. 掌握日志工具的使用

专业的！

* 日志开关可控制
* 可添加日志标签
* 日志级别可以区分

#### 第二章：快速入门Kotlin

##### 1.  语言简洁

##### 2  变量

自动转型：

val：对应final变量

var：对应final常量

##### 3.  函数

fun，单行代码可不加{}

##### 4.  逻辑控制语句（if  when for）

if：有返回值，每个条件中最后一行代码的返回值

when：有返回值，可以用->，**判断对象相等可以直接用==，判断引用相等===**

while和for：for-in,并且可以用until跳出区间

##### 5.  类

**类**：class

**方法**：fun

##### 6.  继承与构造函数

**继承**：默认不可被继承，加上open才可以

**构造函数：**这里比较复杂

##### 7.  接口

继承： **：**

实现： **，**

访问修饰符：Kotiln默认是public，另外还有internal关键字

##### 8. 数据类与单例类

class->object

##### 9. Lambda编程

**集合创建（更简洁）和遍历（for-in）！**

**集合的函数式API**：求一个集合里面的最大值，直接list.maxBy

**java函数API**

##### 10. 空指针检查

空指针异常解决：编译时期会直接报错

**？.**  可为空

**？：** 类似于java中的？：

##### 11.小魔术

**字符串内嵌表达式** 

**给参数的默认值**

# 安卓开发之路第二天（8.17）

#### 事件1： 复习+连接到手机

https://www.cnblogs.com/oreox/p/10662066.html

#### 事件2： 学习activty

##### 1. 编写按钮

~~~java
    <Button
        android:id="@+id/button" //定义一个唯一id
        android:layout_width="match_parent" //定义宽度，匹配父元素
        android:layout_height="wrap_content" //定义高度，刚好包含里面的内容wrap_content
        android:text="Button" /> //显示内容
~~~

##### 2. activity调用

~~~java
package com.example.mysecendacticity;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class FristActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //调用父类默认实现
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
    }
}
~~~

##### 3. andoridMainActivity

~~~java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.mysecendacticity">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".FristActivity"
            android:label="This is FristActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            </activity>
    </application>

</manifest>
~~~

##### 4. **toast**

```java
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
        Button button1=(Button) findViewById(R.id.button1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); }
        });
    }
}
```

##### 5.**菜单**

~~~java
    @Override
    //菜单可见
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
    @Override
    //菜单响应时间
    public boolean onOptionsItemSelected(MenuItem item) {
        //使用item.getItemId()判断使用哪个菜单项
        switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
            default:
        }
        return true;
    }
}
~~~

##### 6.**intent**

~~~java
//显示       
button1.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        //第一个参数Context 要求提供一个启动活动的上下文， 第二个参数Class 则是指定想要启动的目标活动
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                        startActivity(intent);
                    }
        });

    }
~~~

~~~xml
//隐式  

<activity android:name=".SecondActivity">
            <intent-filter> 
                <action android:name="com.example.activitytest.ACTION_START" /> 
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity
~~~

在<action> 标签中我们指明了当前活动可以响应 **com.example.activitytest.ACTION_START** 这个action ，而<category> 标签则包含 了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的**category** 。只 有<action> 和<category> 中的内容同时能够匹配上Intent中指定的**action** 和**category** 

时，这个活动才能响应该**Intent**。 

##### 7.[Intent的常用属性action和category](https://www.cnblogs.com/z-cg/p/12356168.html)

**设置隐式跳转时**，首先在我们按钮监听器中添加

```java
Intent i=new Intent();
//参数为字符串，可以添加包名.活动名
i.setAction("com.example.aaaaa.testliandong.MainActivity");
startActivity(i);
```

只是这样还不够，必须得在AndroidMainfest.xml文件中添加如下代码

```xml
 <activity android:name=".NewActivity">
             <intent-filter>
                 <action android:name="com.example.aaaaa.testliandong.MainActivity"/>
                 <category android:name="android.intent.category.DEFAULT"/>
             </intent-filter>
        </activity>
```

其中第一行和活动的声明一样，intent-filter标签中的action中name的值为和之前在Java中setAction的参数一样，category中的name值为android.intent.category.DEFAULT，DEFAULT则表示跳转为隐式跳转

可以看到，我们使用了Intent的另一个构造函数，直接将action 的字符串传了进去，表明我们 

想要启动能够响应com.example.activitytest.ACTION_START 这个action 的活动。那 前面不是说要<action> 和<category> 同时匹配上才能响应的吗？**怎么没看到哪里有指定 category 呢？**这是因为android.intent.category.DEFAULT 是一种默认的category ，在调用startActivity() 方法的时候会自动将这个category 添加到Intent中。 

##### 8.**Activity的Action(单个)和category（多个）属性**

https://blog.csdn.net/itszt888/article/details/76074243

介绍Action和Category的关系 
举一个例子,一个女孩子找男朋友,她有一些要求：男性、高、富、帅。 
男性相当于`Action`,`Action`这能有一个 
高富帅相当于`Category`,`Category`可以有很多 
而一个男性有很多特点,满足了很多女孩系择偶的标准,用如下图表示

![这里写图片描述](https://img-blog.csdn.net/20170725152114852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRzenQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

~~~java
//今天看了Activity，来跟大家分享一下它的Action属性和category属性
//下面页面为第一个页面，页面只有一个跳转按钮，此处不再给出页面布局
package a.a;

import android.app.Activity;
import android.os.Bundle;
import android.widget.*;
import android.view.*;
import android.view.View.OnClickListener;
import android.content.*;
public class Er extends Activity 
{
   private Button jump;
   private static final String MY_ACTION = "ery.src.a.a.MY_ACTION";
   private static final String MY_CATEGORY = "ery.src.a.a.MY_CATEGORY";
   public void onCreate(Bundle savedInstanceState) 
  {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.main);
       jump = (Button)findViewById(R.id.jump);
       jump.setOnClickListener(new OnClickListener()
       {
           public void onClick(View v)
           {
               //此处为intent添加了一个自定义action和一个自定义category属性，因此配置被启                        //动Activity在注册表androidmanifest.xml文件中要包括这样的两行配置:
               //<action android:name="ery.src.a.a.MY_ACTION" />和
               //<category android:name="ery.src.a.a.MY_CATEGORY" />，然而每一个Intent还                          //有一个默认的category，所以这个默认的也得注册，为:
               //<category android:name="android.intent.category.DEFAULT" />
               //总之归结起来，注册表中的Activity要想启动，必须包含对应Intent的Action属性
               //和Intent的所有category属性。(附：一个Intent只能有一个acton，但可以添加多                        //个category)
               Intent  intent = new Intent();
               intent.setAction(MY_ACTION);
               intent.addCategory(MY_CATEGORY);
                Er.this.startActivity(intent);
            }
        });
   }
}
//第二个页面，只有一个TextView，在此不再给出布局文件
package a.a;
import android.app.*;
import android.os.Bundle;
public class Second extends Activity
{
    protected void onCreate(Bundle savedInstanceState) 
    {
       super.onCreate(savedInstanceState);
       super.setContentView(R.layout.second);
    }
}
~~~

~~~xml

//AnaroidManifest.xml文件
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="a.a"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="15" />

    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <activity
            android:label="@string/app_name"
            android:name=".Er" >
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".Second"
            android:theme="@android:style/Theme.Dialog" 
            >
            <intent-filter>
                <action android:name="ery.src.a.a.MY_ACTION" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="ery.src.a.a.MY_CATEGORY" />
                <category android:name="saer"/>
            </intent-filter>
        </activity>
    </application>

</manifest>

~~~

##### 9. 更多隐式**Intent**的用法 

使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得 Android多个应用程序之间的功能共享成为了可能。比如说你的应用程序中需要展示一个网页， 这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器 来打开这个网页就行了。

~~~xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <action android:name="com.example.activitytest.ACTION_START" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="com.example.activitytest.MY_CATEGORY" />
            </intent-filter>
        </activity>
        <activity
~~~



我们在ThirdActivity的<intent-filter> 中配置了当前活动能够响应的action 

是Intent.ACTION_VIEW 的常量值，而category 则毫无疑问指定了默认的category 值， 

另外在<data> 标签中我们通过android:scheme 指定了数据的协议必须是http协议，这样 

ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。



~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                //常量值
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~



 我们还可以在<intent-filter> 标签中再配置一个<data> 标签，用于**更精确地** 

**指定当前活动能够响应什么类型的数据**。<data> 标签中主要可以配置以下内容。 

android:scheme 。用于指定数据的协议部分，如上例中的http部分。 

android:host 。用于指定数据的主机名部分，如上例中的www.baidu.com部分。 

android:port 。用于指定数据的端口部分，一般紧随在主机名之后。 

android:path 。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内 

容。

android:mimeType 。用于指定可以处理的数据类型，允许使用通配符的方式进行指 

定。 

只有<data> 标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该 

Intent。不过一般在<data> 标签中都不会指定过多的内容，如上面浏览器示例中，其实**只需要** 

**指定android:scheme 为http，就可以响应所有的http协议的Intent了。** 

为了让你能够更加直观地理解，我们来自己建立一个活动，让它也能响应打开网页的Intent。

~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~

##### 10.  向下一个activity传输数据

~~~java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            //Intent中提供了一系列putExtra() 方法的重载，可以把 我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出 就可以了
            public void onClick(View v) {
                String data = "Hello SecondActivity";
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                intent.putExtra("extra_data", data);
                startActivity(intent);
            }
        });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.second_layout);
            Intent intent = getIntent();
            String data = ((Intent) intent).getStringExtra("extra_data");
            Log.d("SecondActivity", data); }
~~~

##### 11. 返回数据给上一个活动 

既然可以传递数据给下一个活动，那么能不能够返回数据给上一个活动呢？答案是肯定的。不 过不同的是，返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动的Intent 来传递数据。通过查阅文档你会发现，Activity中还有一个**startActivityForResult() 方 法**也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 毫无疑问，这就是我们所需要的。 

startActivityForResult() 方法接收两个参数，第一个参数还是Intent，第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改FirstActivity中按钮的 点击事件，代码如下所示： 

~~~java
        button1.setOnClickListener(
                new View.OnClickListener() { 
                    @Override 
                    public void onClick(View v) { 
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class); 
                        startActivityForResult(intent, 1); } 
                });
~~~

# 安卓开发之路第三天（8.18）

# 安卓开发之路第四天（8.19）

# 安卓开发之路第五天（8.20）

# 安卓开发之路第六天（8.21）

### 天气预报App

#### 1. 需求分析

**酷欧天气中至少应该具备以下功能：**

1. 可以罗列出全国所有的省、市、县； 

2. 可以查看全国任意城市的天气信息； 

3. 可以自由地切换城市，去查看其他城市的天气； 

4. 提供手动更新以及后台自动更新天气的功能。

#### 2. 技术可行性分析（彩云天气）

我们 如何才能得到全国省市县的数据信息，以及如何才能获取到每个城市的天气信息。比较遗憾的 是，现在网上免费的天气预报接口已经越来越少，很多之前可以使用的接口都慢慢关闭掉了， 包括本书第1版中使用的中国天气网的接口。因此，这次我也是特意用心去找了一些更加稳定的 天气预报服务，比如彩云天气以及和风天气都非常不错。这两个天气预报服务虽说都是收费 的，但它们每天都提供了一定次数的免费天气预报请求。其中彩云天气的数据更加实时和专 业，可以将天气预报精确到分钟级，每天提供1000次免费请求；和风天气的数据相对简单一 些，比较适合新手学习，每天提供3000次免费请求。那么简单起见，这里我们就使用和风天气 来作为天气预报的数据来源，每天3000次的免费请求对于学习而言已经是相当充足了。

>https://id.heweather.com/#/login?redirect=https%3A%2F%2Fconsole.heweather.com%2F%23%2Fconsole

#### 3.  Gitee托管

https://gitee.com/xumingxiao/Sunny-Weather

#### 4.  搭建MVVM项目架构

#### 5 创建数据库和表

~~~java
dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
    //添加依赖项,使用LitePal对数据库进行操作
    implementation 'org.litepal.android:java:3.0.0'
}
~~~

~~~java
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'androidx.appcompat:appcompat:1.3.0-alpha01'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.3.0-rc03'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0-alpha4'
    //
    implementation 'org.litepal.android:java:3.0.0'
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
    implementation 'com.squareup.retrofit2:converter-scalars:2.5.0'
    implementation 'com.github.bumptech.glide:glide:3.7.0'
    def lifecycle_version = "2.0.0"
    // ViewModel and LiveData
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
}
~~~

#### 6 LitePal

https://www.jianshu.com/p/9d0d00b69fe8

https://www.jianshu.com/p/6d3a0f87d637

**学习文档：**

https://github.com/guolindev/LitePal

#### 7 为什么需要实体类

最近因为学习三层架构中的实体类，引发不少问题，下面具体说下三层中的实体类，即数据库表的映射

**为何使用实体类？**

数据库中，DatsSet 不具备OO的优点， 实现数据检索繁琐，易出错， 使数据结构暴露在业务逻辑层和表现层

> “OO，它是英文词组Object Oriented的缩写，它的意思是面向对象

为了消除以上局限我们使用实体类:

![img](https:////upload-images.jianshu.io/upload_images/6923303-2ec385d83393a914.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)



**举例说明**

用实体类之后，代码时变得简介，面向对象**封装**思想，最重要的是，**如果将来有所改动，只需要改动实体类， 方法间调用接口，完全不需要变动，大大减少了程序修改量，迎合了面向对象中接口不变的思想。**

甚至在程序设计时，就把将来可能需要的属性预先放在实体类中，这样以后变动时，连实体类都不用变动了

实体类在三层结构中的主要作用是什么？

Using 语句的主要作用是什么？

**为什么需要实体类？**

 从OOP细想考虑

 它是完全受控制的对象

 它具有面向对象的基本特征

 可以自定义行为

消除了关系数据和对象之间的差异

**为我们在关系数据库和对象之间架起了一座桥梁**

**什么是实体类？**

 **简单的说就是描述一个业务实体的类， 例如： 管理员的信息**

![img](https:////upload-images.jianshu.io/upload_images/6923303-e26ae89a463c6480.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)



**下面几个问题是值得思考的**

**表示层如何使用实体类？**

**业务逻辑层如何使用实体类？**



![img](https:////upload-images.jianshu.io/upload_images/6923303-6a1d13147862af10.png?imageMogr2/auto-orient/strip|imageView2/2/w/667/format/webp)



**数据访问层如何使用实体类？**

他们之间的业务实体的依赖图为

![img](https:////upload-images.jianshu.io/upload_images/6923303-85645b9c7cfc862e.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



 其中Using 语句，用于定义一个范围，在此范围末尾将释放对象



![img](https:////upload-images.jianshu.io/upload_images/6923303-a4c0b2b7ba9ef313.png?imageMogr2/auto-orient/strip|imageView2/2/w/571/format/webp)

https://blog.csdn.net/qq_41386332/article/details/99701010

#### 8 OkHttp用法

https://www.jianshu.com/p/f5320b1e0287

https://github.com/square/okhttp

原理：https://www.jianshu.com/p/7b29b89cd7b5

#### 9. throw new RuntimeException("Stub!")

https://blog.csdn.net/anhenzhufeng/article/details/75268195

这样定义的方法，表示在程序执行的时候，实际由android rom里面相同的类来执行。

**为什么会出现这样的定义？**我猜想可能是，这个类实际只在rom里面提供，而我们有时候要用到这个类的一些方法，那么就以这种方式来提供，因为在编译期间，我们的程序要使用这个类，那必然要提供这个类的定义，不然就引用不了。

就比如在看滴滴的插件化开源软件[VirtualAPK](https://github.com/didi/VirtualAPK) 的时候，在hack AMS服务的时候，需要用到ActivityManagerNative这个类，而这个类我们知道在api里面没有提供，是在framework里面提供的。那么要想引入这个类，要么就是编译一个framework.jar包，工程引用这个jar包，但是这样有个问题，我们的应用要安装在各种版本的系统里面，每个版本的framework都是有差异的，兼容性就低了。所以这里使用了另外一种方法，在我们的工程中声明一个和framework一模一样的类，在运行的时候就能自动运行rom里面的类了。

# 安卓开发之路第六天（8.22）

#### 1 编写ChooseAreaFragment类

**ChooseAreaFragment**用于展示查询界面和实现基本查询功能，继承于**Fragment**

1. 重写**onCreateView**，获取到了一些控件的实例，然后去初始化了ArrayAdapter，并将它设置为ListView的适 配器。
2. **onActivityCreated()**，接着在onActivityCreated() 方法中给**ListView和Button**设置了点击事件，到这里我 们的初始化工作就算是完成了。在onActivityCreated() 方法的最后，调用了queryProvinces() 方法，也就是从这里开 始加载省级数据的。
   * **queryProvinces() 方法**中首先会将头布局的标题设置成中国，将返回 按钮隐藏起来，因为省级列表已经不能再返回了。然后调用LitePal的查询接口来从数据库中读 取省级数据，如果读取到了就直接将数据显示到界面上，如果没有读取到就按照14.1节讲述的接 口组装出一个请求地址，然后调用queryFromServer() 方法来从服务器上查询数据。
     * **queryFromServer() 方法**中会调用HttpUtil的sendOkHttpRequest() 方法来向服务器发送 请求，响应的数据会回调到onResponse() 方法中，然后我们在这里去调用Utility的 handleProvincesResponse() 方法来解析和处理服务器返回的数据，并存储到数据库中。 接下来的一步很关键，在解析和处理完数据之后，我们再次调用了queryProvinces() 方法 来重新加载省级数据，由于queryProvinces() 方法牵扯到了UI操作，因此必须要在主线程 中调用，这里借助了runOnUiThread() 方法来实现从子线程切换到主线程。现在数据库中已 经存在了数据，因此调用queryProvinces() 就会直接将数据显示到界面上了。
3. 当你点击了某个省的时候会进入到ListView的**onItemClick()** 方法中，这个时候会根据当前的 级别来判断是去**调用queryCities()** 方法还是queryCounties() 方法，queryCities() 方法是去查询市级数据，而**queryCounties() 方法**是去查询县级数据，这两个方法内部的流 程和queryProvinces() 方法基本相同，这里就不重复讲解了。 另外还有一点需要注意，在返回按钮的点击事件里，会对当前ListView的列表级别进行判断。如 果当前是县级列表，那么就返回到市级列表，如果当前是市级列表，那么就返回到省级表列表。当返回到省级列表时，返回按钮会自动隐藏，从而也就不需要再做进一步的处理了。 

~~~java
package com.example.sunnywheather.activity;

import android.app.ProgressDialog;
import android.os.Bundle;
import android.telecom.Call;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

import com.example.sunnywheather.R;
import com.example.sunnywheather.db.City;
import com.example.sunnywheather.db.County;
import com.example.sunnywheather.db.Province;
import com.example.sunnywheather.util.HttpUtil;
import com.example.sunnywheather.util.Utility;

import org.litepal.LitePal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.security.auth.callback.Callback;

import okhttp3.Response;
// 新建一个ChooseAreaFragment用于展示查询界面和实现基本查询功能
public class ChooseAreaFragment extends Fragment {
    public static final int LEVEL_PROVINCE = 0;
    public static final int LEVEL_CITY = 1;
    public static final int LEVEL_COUNTY = 2;
    private ProgressDialog progressDialog;
    private TextView titleText;
    private Button backButton;
    private ListView listView;
    private ArrayAdapter<String> adapter;
    private List<String> dataList = new ArrayList<>();
    /*** 省列表 */
    private List<Province> provinceList;
    /*** 市列表 */
    private List<City> cityList;
    /*** 县列表 */
    private List<County> countyList;
    /*** 选中的省份 */
    private Province selectedProvince;
    /*** 选中的城市 */
    private City selectedCity;
    /*** 当前选中的级别*/
    private int currentLevel;

    /**
     * 在onCreateView()方法中先是获取到了一些控件的实例，
     * 然后去初始化了ArrayAdapter，并将它设置为ListView的适配器。
     * 接着在onActivityCreated() 方法中给ListView和Button设置了点击事件，
     * 到这里我们的初始化工作就算是完成了
     * @param inflater
     * @param container
     * @param savedInstanceState
     * @return
     */
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

        View view = inflater.inflate(R.layout.choose_area, container, false);
        titleText = (TextView) view.findViewById(R.id.title_text);
        backButton = (Button) view.findViewById(R.id.back_button);
        listView = (ListView) view.findViewById(R.id.list_view);
        adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_list_item_1, dataList);
        listView.setAdapter(adapter);
        return view;
    }

    /**
     * 在onActivityCreated()方法中设置ListView和Button的点击事件，
     * 在这里完成了基本的初始化操作，调用queryProvinces()方法，加载省级数据
     * @param savedInstanceState
     */
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        //对列表设置监听事件
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if(currentLevel == LEVEL_PROVINCE){
                    //记住选中的省份
                    selectedProvince = provinceList.get(position);
                    //显示出省份对应下city的界面
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //记住选中的City
                    selectedCity = cityList.get(position);
                    //切换到相应的county界面
                    queryCounties();
                }
            }
        });
        //为返回按钮注册监听事件
        backButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View v){
                //若在county切换到City
                if(currentLevel == LEVEL_COUNTY){
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //若在City切换到province
                    queryProvinces();
                }
            }
        });
        //初始状态下显示province
        queryProvinces();
    }

    /*** 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryProvinces() {
        //首先将头布局的标题设为中国
        titleText.setText("中国");
        //隐藏返回按键
        backButton.setVisibility(View.GONE);
        //调用LitePal接口读取省级数据
        provinceList = LitePal.findAll(Province.class);
        //如果读取到了就直接将数据显示在桌面上
        if (provinceList.size() > 0) {
            dataList.clear();
            //遍历链表
            for (Province province : provinceList) {
                dataList.add(province.getProvinceName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_PROVINCE;
        } else {
            //否则向服务器上查询
            String address = "http://guolin.tech/api/china";
            //传入一个地址和回调函数
            queryFromServer(address, "province");
        }
    }

    /*** 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCities() {
        titleText.setText(selectedProvince.getProvinceName());
        backButton.setVisibility(View.VISIBLE);
        cityList = LitePal.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class);
        if (cityList.size() > 0) {
            dataList.clear();
            for (City city : cityList) {
                dataList.add(city.getCityName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_CITY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            String address = "http://guolin.tech/api/china/" + provinceCode;
            queryFromServer(address, "city");
        }
    }

    /*** 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCounties() {
        titleText.setText(selectedCity.getCityName());
        backButton.setVisibility(View.VISIBLE);
        countyList = LitePal.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class);
        if (countyList.size() > 0) {
            dataList.clear();
            for (County county : countyList) {
                dataList.add(county.getCountyName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_COUNTY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            int cityCode = selectedCity.getCityCode();
            String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode;
            queryFromServer(address, "county");
        }
    }

    /*** 根据传入的地址和类型从服务器上查询省市县数据 */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    private void queryFromServer(String address,final String type){
        //未查出之前显示出进度条框
        showProgressDialog();
        //Log.d(TAG,"发送之前");
        HttpUtil.sendOkHttpRequest(address, new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, IOException e) {
                //通过runOnUiThread回到主线程处理逻辑
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        closeProgressDialog();
                        Toast.makeText(getContext(),"加载失败",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            @Override
            public void onResponse(okhttp3.Call call, Response response) throws IOException {
                String responseText = response.body().string();
                boolean result = false;
                if(type.equals("province")){
                    result = Utility.handleProvinceResponse(responseText);
                }else if(type.equals("city")){
                    result = Utility.handleCityResponse(responseText,selectedProvince.getId());
                }else if(type.equals("county")){
                    result = Utility.handleCountyResponse(responseText,selectedCity.getId());
                }
                if(result){
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            closeProgressDialog();
                            if(type.equals("province")){
                                queryProvinces();
                            }else if(type.equals("city")){
                                queryCities();
                            }else if(type.equals("county")){
                                queryCounties();
                            }
                        }
                    });
                }
            }
        });
    }
    /*** 显示进度对话框 */
    private void showProgressDialog() {
        if (progressDialog == null) {
            progressDialog = new ProgressDialog(getActivity());
            progressDialog.setMessage("正在加载...");
            progressDialog.setCanceledOnTouchOutside(false);
        }
        progressDialog.show();
    }

    /*** 关闭进度对话框 */
    private void closeProgressDialog() {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }
}
~~~

# 安卓开发之路第七天（8.23）

# 安卓开发之路第八天（8.24）

# 安卓开发之路第九天（8.25）

# 安卓开发之路第十天（8.26）

# 安卓开发之路第十一天（8.27）

