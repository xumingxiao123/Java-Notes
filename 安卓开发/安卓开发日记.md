[TOC]

# 规划（一个月内）

#### 1. 看什么？

* 《第一行代码》

* github上的开源项目（**5个**）

#### 2. 做什么？

* 自己做两个项目并上架谷歌商城
  * 类似于githu提交记录去制作一个手机使用时间的说明，分为轻度，中度，重度

#### 3. 其他？

* 阅读java全部源码（领悟设计模式，代码规范，实现思想）
* 玩转字节码和虚拟机
* 深入操作系统层面
* 编程：每天2题及以上
* 专业课不能忘！

| 日期 | 书籍                   | 看项目      | 做项目 | Java | 编程       |
| ---- | ---------------------- | ----------- | ------ | ---- | ---------- |
| 8.16 | 《第一行代码》p0-82    |             |        |      |            |
| 8.17 | 《第一行代码》p82-111  |             |        |      |            |
| 8.18 | 《第一行代码》p111-243 |             |        |      | 二叉搜索树 |
| 8.19 | 《第一行代码》p243-400 |             |        |      |            |
| 8.20 | 《第一行代码》p400-600 |             |        |      |            |
| 8.21 |                        | 天气预报App |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |

# 问题总结（10大问题）

## 【Activity专题】

##### [1] Activity是什么？

我们都知道android中有四大组件（Activity 活动，Service 服务，Content Provider 内容提供者，BroadcastReceiver 广播接收器），Activity是我们用的最多也是最基本的组件，因为应用的所有操作都与用户相关，Activity 提供窗口来和用户进行交互。

官方文档这么说： 　　

> An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).
>
> 大概的意思：

> activity是独立平等的，用来处理用户操作。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，开发者可以通过setContentView(View)的接口把UI放到给窗口上。

　　Android中的activity全都归属于task管理 。task 是多个 activity 的集合，这些 activity 按照启动顺序排队存入一个栈（即“back stack”）。android默认会为每个App维持一个task来存放该app的所有activity，task的默认name为该app的packagename。

　　当然我们也可以在AndroidMainfest.xml中申明activity的taskAffinity属性来自定义task，但不建议使用，如果其他app也申明相同的task，它就有可能启动到你的activity，带来各种安全问题（比如拿到你的Intent）。

##### [2] Activity的生命周期

　　上面已经说了，系统通过堆栈来管理activity，当一个新的activity开始时，它被放置在堆栈的顶部和成为运行活动，以前的activity始终保持低于它在堆栈，而不会再次到达前台，直到新的活动退出。

还是上这张官网的activity_lifecycle图： 　　[![这里写图片描述](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)　

1. 首先打开一个新的activity实例的时候，系统会依次调用

> onCreate（）  -> onStart() -> onResume() 然后开始running

2. running的时候被覆盖了（从它打开了新的activity或是被锁屏，但是它**依然在前台**运行， lost focus but is still visible），系统调用onPause();

> 　该方法执行activity暂停，通常用于提交未保存的更改到持久化数据，停止动画和其他的东西。但这个activity还是完全活着（它保持所有的状态和成员信息，并保持连接到**窗口管理器**）

3. 接下来它有三条出路：

 ①用户返回到该activity就调用onResume()方法重新running

 ②用户回到桌面或是打开其他activity，就会调用onStop()进入停止状态（保留所有的状态和成员信息，**对用户不可见**）

 ③系统内存不足，拥有更高限权的应用需要内存，那么该activity的进程就可能会被系统回收。（回收onRause()和onStop()状态的activity进程）要想重新打开就必须重新创建一遍。

4. 如果用户返回到onStop()状态的activity（又显示在前台了），系统会调用

> onRestart() ->  onStart() -> onResume() 然后重新running

5. 在activity结束（调用finish ()）或是被系统杀死之前会调用onDestroy()方法释放所有占用的资源。

> activity生命周期中三个嵌套的循环

- activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。　
- activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。　
- activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。 因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，**这两个方法中的代码应该相当地轻量化**。

##### [3] activity被回收的状态和信息保存和恢复过程

```java
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
   @Override
protected void onSaveInstanceState(Bundle outState) {
	// TODO Auto-generated method stub
	 //可能被回收内存前保存状态和信息，
	   Bundle data = new Bundle(); 
	   data.putString("key", "last words before be kill");
	   outState.putAll(data);
	super.onSaveInstanceState(outState);
}
   @Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
	// TODO Auto-generated method stub
	   if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
	super.onRestoreInstanceState(savedInstanceState);
}
}
```

**onSaveInstanceState方法**

　　在activity　可能被回收之前　调用,用来保存自己的状态和信息，以便回收后重建时恢复数据（在onCreate()或onRestoreInstanceState()中恢复）。旋转屏幕重建activity会调用该方法，但其他情况在onRause()和onStop()状态的activity不一定会调用 ，下面是该方法的文档说明。

> One example of when onPause and onStop is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause is called and not onSaveInstanceState is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact.

也就是说，系统灵活的来决定调不调用该方法，**但是如果要调用就一定发生在onStop方法之前，但并不保证发生在onPause的前面还是后面。**

**onRestoreInstanceState方法**

　　这个方法在onStart 和 onPostCreate之间调用，在onCreate中也可以状态恢复，但有时候需要所有布局初始化完成后再恢复状态。

　　onPostCreate：一般不实现这个方法，当程序的代码开始运行时，它调用系统做最后的初始化工作。

##### [4] activity启动模式

**启动模式什么？**简单的说就是定义activity 实例与task 的关联方式。 　　

**为什么要定义启动模式？**

　　 为了实现一些默认启动（standard）模式之外的需求： 　　

- 让某个 activity 启动一个新的 task （而不是被放入当前 task ）
- 让 activity 启动时只是调出已有的某个实例（而不是在 back stack 顶创建一个新的实例）　
- 或者，你想在用户离开 task 时只保留根 activity，而 back stack 中的其它 activity 都要清空

**怎样定义启动模式？**

　　定义启动模式的方法有两种：

**使用 manifest 文件**

　　在 manifest 文件中activity声明时，利用 activity 元素的 launchMode 属性来设定 activity 与 task 的关系。

```
 <activity
            ．．．．．．
            android:launchMode="standard"
             >
           ．．．．．．．
        </activity>
```

> 注意： 你用 launchMode 属性为 activity 设置的模式可以被启动 activity 的 intent 标志所覆盖。

**有哪些启动模式？**

- **"standard"** （默认模式）　

　　当通过这种模式来启动Activity时,　Android总会为目标 Activity创建一个新的实例,并将该Activity添加到当前Task栈中。这种方式不会启动新的Task,只是将新的 Activity添加到原有的Task中。　 　　

- **"singleTop"**　

　　该模式和standard模式基本一致,但有一点不同: 当将要被启动的Activity已经位于Task栈顶时,系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- **"singleTask"**

　　Activity在同一个Task内只有一个实例。如果将要启动的Activity不存在,那么系统将会创建该实例,并将其加入Task栈顶；　

　　如果将要启动的Activity已存在,且存在栈顶,直接复用Task栈顶的Activity。　

　　如果Activity存在但是没有位于栈顶,那么此时系统会把位于该Activity上面的所有其他Activity全部移出Task,从而使得该目标Activity位于栈顶。

- **"singleInstance"**　

　　无论从哪个Task中启动目标Activity,只会创建一个目标Activity实例且会用一个全新的Task栈来装载该Activity实例（全局单例）.

　　如果将要启动的Activity不存在,那么系统将会先创建一个全新的Task,再创建目标Activity实例并将该Activity实例放入此全新的Task中。

　　如果将要启动的Activity已存在,那么无论它位于哪个应用程序,哪个Task中;系统都会把该Activity所在的Task转到前台,从而使该Activity显示出来。

**使用 Intent 标志**

　　在要启动 activity 时，你可以在传给 startActivity() 的 **intent** 中包含相应标志，以修改 **activity 与 task** 的默认关系。

```java
　　　　　Intent i = new Intent(this,ＮewActivity.class);
		i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		startActivity(i);
```

**可以通过标志修改的默认模式有哪些？**

- FLAG_ACTIVITY_NEW_TASK

　　与"singleTask"模式相同，在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台。

- FLAG_ACTIVITY_SINGLE_TOP

　　与 "singleTop"模式相同，如果要启动的 activity位于back stack 顶，系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- FLAG_ACTIVITY_CLEAR_TOP

　　**此种模式在launchMode中没有对应的属性值。**如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁。

**关于启动模式的一些建议**

　　 一般不要改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持谨慎，并确保 activity 在启动和从其它 activity 返回时的可用性，多做测试和安全方面的工作。

##### [5] Intent Filter

　　android的3个核心组件——Activity、services、广播接收器——是通过intent传递消息的。intent消息用于在运行时绑定不同的组件。在 Android 的 AndroidManifest.xml 配置文件中可以通过 intent-filter 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。

**intent-filter 的三大属性**

**Action**

　　一个 Intent Filter 可以包含多个 Action，Action 列表用于标示 Activity 所能接受的“动作”，它是一个用户自定义的字符串。

```
<intent-filter > 
 <action android:name="android.intent.action.MAIN" /> 
 <action android:name="com.scu.amazing7Action" /> 
……
 </intent-filter>
```

在代码中使用以下语句便可以启动该Intent 对象：

```
Intent i=new Intent(); 
i.setAction("com.scu.amazing7Action");
```

Action 列表中包含了“com.scu.amazing7Action”的 Activity 都将会匹配成功

**URL**

　　在 intent-filter 节点中，通过 data节点匹配外部数据，也就是通过 URI 携带外部数据给目标组件。

```
<data android:mimeType="mimeType" 
	android:scheme="scheme" 
	 android:host="host"
	 android:port="port" 
	 android:path="path"/>
```

注意：只有data的所有的属性都匹配成功时 URI 数据匹配才会成功

**Category**

　　为组件定义一个 类别列表，当 Intent 中包含这个类别列表的所有项目时才会匹配成功。

```
<intent-filter . . . >
   <action android:name="code android.intent.action.MAIN" />
   <category android:name="code　android.intent.category.LAUNCHER" />
</intent-filter>
```

**Activity 中 Intent Filter 的匹配过程**

① 加载所有的Intent Filter列表 　　

② 去掉action匹配失败的Intent Filter 　　

③ 去掉url匹配失败的Intent Filter 　

④ 去掉Category匹配失败的Intent Filter 　

⑤ 判断剩下的Intent Filter数目是否为0。如果为0查找失败返回异常；如果大于0，就按优先级排序，返回最高优先级的Intent Filter

##### [6] 开发中Activity的一些问题

一般设置Activity为非公开的

```java
<activity  
．．．．．． 
android:exported="false" /> 
```

注意：非公开的Activity不能设置intent-filter，以免被其他activity唤醒（如果拥有相同的intent-filter）。

- 不要指定activity的taskAffinity属性
- 不要设置activity的LaunchMode（保持默认）

　　注意Activity的intent最好也不要设定为FLAG_ACTIVITY_NEW_TASK

- 在匿名内部类中使用this时加上activity类名（类名.this,不一定是当前activity）
- 设置activity全屏

　　在其 onCreate()方法中加入：

```java
// 设置全屏模式
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 
 // 去除标题栏
 requestWindowFeature(Window.FEATURE_NO_TITLE);
```

## 【Service详细解析】

##### [1] 什么是服务？　　

　　Service是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与content provider进行交互，所有这些都是后台进行的。

##### [2] Service 与Thread的区别

　　服务仅仅是一个组件，即使用户不再与你的应用程序发生交互，它仍然能在后台运行。因此，应该只在需要时才创建一个服务。

　　如果你需要在主线程之外执行一些工作，但仅当用户与你的应用程序交互时才会用到，那你应该创建一个新的线程而不是创建服务。 比如，如果你需要播放一些音乐，但只是当你的activity在运行时才需要播放，你可以在onCreate()中创建一个线程，在onStart()中开始运行，然后在onStop()中终止运行。还可以考虑使用AsyncTask或HandlerThread来取代传统的Thread类。

　　**由于无法在不同的 Activity 中对同一 Thread 进行控制**，这个时候就要考虑用服务实现。如果你使用了服务，它默认就运行于应用程序的主线程中。因此，如果服务执行密集计算或者阻塞操作，你仍然应该在服务中创建一个新的线程来完成（避免ANR）。

##### [3] 服务的分类

**1. 按运行分类**

- 前台服务

　　前台服务是指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，并会置于“正在进行的”（“Ongoing”）组之下。这意味着只有在服务被终止或从前台移除之后，此通知才能被解除。例如，用服务来播放音乐的播放器就应该运行在前台，因为用户会清楚地知晓它的运行情况。 状态栏通知可能会标明当前播放的歌曲，并允许用户启动一个activity来与播放器进行交互。

　　要把你的服务请求为前台运行，可以调用**startForeground()**方法。此方法有两个参数：唯一标识通知的整数值、状态栏通知Notification对象。例如：

```java
Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());
Intent notificationIntent = new Intent(this,ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
notification.setLatestEventInfo(this, getText(R.string.notification_title),
        getText(R.string.notification_message), pendingIntent);  
startForeground(ONGOING_NOTIFICATION, notification);
```

　　要从前台移除服务，请调用**stopForeground()**方法，这个方法接受个布尔参数，表示是否同时移除状态栏通知。此方法不会终止服务。不过，如果服务在前台运行时被你终止了，那么通知也会同时被移除。

- 后台服务

**2. 按使用分类**　　

- **本地服务**：用于应用程序内部，实现一些耗时任务，并不占用应用程序比如Activity所属线程，而是单开线程后台执行。调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。

- **远程服务**：用于Android系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用 Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。

##### [4] Service生命周期

　                                   ![img](https://upload-images.jianshu.io/upload_images/4625401-84380bfeb9c4b0ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



【链接：https://www.jianshu.com/p/cc25fbb5c0b3】

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200901224652977.png" alt="image-20200901224652977" style="zoom:80%;" />



**Service生命周期方法：**

```java
public class ExampleService extends Service {
    int mStartMode;       // 标识服务被杀死后的处理方式
    IBinder mBinder;      // 用于客户端绑定的接口
    boolean mAllowRebind; // 标识是否使用onRebind

    @Override
    public void onCreate() {
        // 服务正被创建
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // 服务正在启动，由startService()调用引发
        return mStartMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // 客户端用bindService()绑定服务
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        // 所有的客户端都用unbindService()解除了绑定
        return mAllowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        // 某客户端正用bindService()绑定到服务,
        // 而onUnbind()已经被调用过了
    }
    @Override
    public void onDestroy() {
        // 服务用不上了，将被销毁
    }
}
```

> 请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行。onStartCommand()的返回值必须是以下常量之一：

> START_NOT_STICKY 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。START_STICKY 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。　

> START_REDELIVER_INTENT 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。

　　服务的生命周期与activity的非常类似。不过，更重要的是你需密切关注服务的创建和销毁环节，因为后台运行的服务是不会引起用户注意的。

　　服务的生命周期——从创建到销毁——可以有两种路径：

- **一个started服务**

　　这类服务由其它组件调用startService()来创建。然后保持运行，且**必须通过调用stopSelf()自行终止**。其它组件也可通过调用stopService() 终止这类服务。服务终止后，系统会把它销毁。

　　如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且**系统只会创建Service的一个实例**（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。

- **一个bound服务**

　　服务由其它组件（客户端）调用bindService()来创建。然后客户端通过一个**IBinder接口与服务进行通信**。客户端可以通过调用unbindService()来关闭联接。多个客户端可以绑定到同一个服务上，当所有的客户端都解除绑定后，系统会销毁服务。（服务不需要自行终止。）

　　如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。

![img](https://upload-images.jianshu.io/upload_images/4625401-756d89b600d55081.png?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

　　这两条路径并不是完全隔离的。也就是说，你可以绑定到一个已经用startService()启动的服务上。例如，一个后台音乐服务可以通过调用startService()来启动，传入一个指明所需播放音乐的 Intent。 之后，用户也许需要用播放器进行一些控制，或者需要查看当前歌曲的信息，这时一个activity可以通过调用bindService()与此服务绑定。在类似这种情况下，stopService()或stopSelf()不会真的终止服务，除非所有的客户端都解除了绑定。

> 　　当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。

**在manifest中声明服务**

　　无论是什么类型的服务都必须在manifest中申明，格式如下：

```
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```

Service 元素的属性有：

> android:name　　-------------　　服务类名

> android:label　　--------------　　服务的名字，如果此项不设置，那么默认显示的服务名则为类名

> android:icon　　--------------　　服务的图标

> android:permission　　-------　　申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务

> android:process　　----------　　表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字

> android:enabled　　----------　　如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false

> android:exported　　---------　　表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false　

　　android:name是唯一必需的属性——它定义了服务的类名。与activity一样，服务可以定义intent过滤器，使得其它组件能用隐式intent来调用服务。如果你想让服务只能内部使用（其它应用程序无法调用），那么就不必（也不应该）提供任何intent过滤器。 　　此外，如果包含了android:exported属性并且设置为"false"， 就可以确保该服务是你应用程序的私有服务。即使服务提供了intent过滤器，本属性依然生效。　

**startService 启动服务**

　　从activity或其它应用程序组件中可以启动一个服务，调用startService()并传入一个Intent（指定所需启动的服务）即可。

```java
	Intent intent = new Intent(this, MyService.class);
	startService(intent);
```

服务类：

```java
public class MyService extends Service {

	  /**
     * onBind 是 Service 的虚方法，因此我们不得不实现它。
     * 返回 null，表示客服端不能建立到此服务的连接。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return null;
	}
    
	@Override
    public void onCreate() {
        super.onCreate();
    }
     
    @Override
 public int onStartCommand(Intent intent, int flags, int startId)  　　 {  	
    //接受传递过来的intent的数据 
     return START_STICKY; 
    };
     
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
	
}
```

　　一个started服务必须自行管理生命周期。也就是说，系统不会终止或销毁这类服务，除非必须恢复系统内存并且服务返回后一直维持运行。 因此，服务必须通过调用stopSelf()自行终止，或者其它组件可通过调用stopService()来终止它。

**bindService 启动服务**　　

　　当应用程序中的activity或其它组件需要与服务进行交互，或者应用程序的某些功能需要暴露给其它应用程序时，你应该创建一个bound服务，并通过进程间通信（IPC）来完成。

方法如下：

```
 Intent intent=new Intent(this,BindService.class); 
 bindService(intent, ServiceConnection conn, int flags)  
```

> 注意bindService是Context中的方法，当没有Context时传入即可。

在进行服务绑定的时，其flags有：

- Context.BIND_AUTO_CREATE

　　表示收到绑定请求的时候，如果服务尚未创建，则即刻创建，在系统内存不足需要先摧毁优先级组件来释放内存，且只有驻留该服务的进程成为被摧毁对象时，服务才被摧毁　

- Context.BIND_DEBUG_UNBIND    　

　　通常用于调试场景中判断绑定的服务是否正确，但容易引起内存泄漏，因此非调试目的的时候不建议使用

- Context.BIND_NOT_FOREGROUND    　

　　表示系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行。

服务类：

```
public class BindService extends Service {

	 // 实例化MyBinder得到mybinder对象；
	private final MyBinder binder = new MyBinder();
	
	  /**
     * 返回Binder对象。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return binder;
	}
    
     /**
      * 新建内部类MyBinder，继承自Binder(Binder实现IBinder接口),
      * MyBinder提供方法返回BindService实例。
      */
　　public class MyBinder extends Binder{
        
        public BindService getService(){
            return BindService.this;
        }
    }
     

	@Override
	public boolean onUnbind(Intent intent) {
		// TODO Auto-generated method stub
		return super.onUnbind(intent);
	}
}
```

启动服务的activity代码：

```
public class MainActivity extends Activity {

	/** 是否绑定 */  
	boolean mIsBound = false; 
	BindService mBoundService;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		doBindService();
	}
	/**
	 * 实例化ServiceConnection接口的实现类,用于监听服务的状态
	 */
	private ServiceConnection conn = new ServiceConnection() {  
		  
	    @Override  
	    public void onServiceConnected(ComponentName name, IBinder service) {  
	        BindService mBoundService = ((BindService.MyBinder) service).getService();  
	        
	    }  
	  
	    @Override  
	    public void onServiceDisconnected(ComponentName name) {  
	        mBoundService = null;  
	     
	    }  
	}; 
	
	/** 绑定服务 */  
	public void doBindService() {  
	    bindService(new Intent(MainActivity.this, BindService.class), conn,Context.BIND_AUTO_CREATE);  
	    mIsBound = true;  
	}  
	
	/** 解除绑定服务 */  
	public void doUnbindService() {  
	    if (mIsBound) {  
	        // Detach our existing connection.  
	        unbindService(conn);  
	        mIsBound = false;  
	    }  
	} 
	
	@Override
	protected void onDestroy() {
		// TODO Auto-generated method stub
		super.onDestroy();
		
		doUnbindService();
	}
}
```

> 注意在AndroidMainfest.xml中对Service进行显式声明

判断Service是否正在运行：

```
private boolean isServiceRunning() {
    ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    
 　{
        if ("com.example.demo.BindService".equals(service.service.getClassName())) 　　{
            return true;
        }
    }
    return false;
}
```

##### [5] [bindService与startService区别](https://www.cnblogs.com/yesphet/p/4766786.html)

1. Started Service中使用startService（）方法来进行方法的调用，调用者和服务之间没有联系，即使调用者退出了，服务依然在进行 【onCreate()-  >onStartCommand()->startService()->onDestroy()】，注意其中没有 onStart()，主要是被onStartCommand()方法给取代了，onStart方法不推荐使用了。
2. BindService中使用bindService()方法来绑定服务，调用者和绑定者绑在一起，调用者一旦退出服务也就终止了【onCreate()->onBind()->onUnbind()->onDestroy()】。

##### [6] IntentService详细解析

1. **IntentService定义**

　　IntentService继承于Service，用来处理异步请求。客户端可以通过startService(Intent)方法传递请求给IntentService。IntentService在onCreate()函数中通过HandlerThread单独开启一个线程来依次处理所有Intent请求对象所对应的任务。这样以免事务处理阻塞主线程（ＡＮＲ）。执行完所一个Intent请求对象所对应的工作之后，如果没有新的Intent请求达到，则**自动停止**Service；否则执行下一个Intent请求所对应的任务。　 　　    IntentService在处理事务时，还是采用的Handler方式，创建一个名叫ServiceHandler的内部Handler，并把它直接绑定到HandlerThread所对应的子线程。 ServiceHandler把处理一个intent所对应的事务都封装到叫做**onHandleIntent**的虚函数；因此我们直接实现虚函数onHandleIntent，再在里面根据Intent的不同进行不同的事务处理就可以了。 另外，IntentService默认实现了Onbind（）方法，返回值为null。

使用IntentService需要实现的两个方法： 　　

- **构造函数**　

　　IntentService的构造函数一定是**参数为空**的构造函数，然后再在其中调用super("name")这种形式的构造函数。因为Service的实例化是系统来完成的，而且系统是用参数为空的构造函数来实例化Service的

- **实现虚函数onHandleIntent**

　　在里面根据Intent的不同进行不同的事务处理。好处：处理异步请求的时候可以减少写代码的工作量，比较轻松地实现项目的需求。

2. **IntentService与Service的区别**

　　Service不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的，不建议在Service中编写耗时的逻辑和操作，否则会引起ANR。

　　IntentService 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents（把intent插入到工作队列中）。通过工作队列把intent逐个发送给onHandleIntent()。不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。

　　 默认实现的onBind()返回null。

3. **IntentService实例介绍**

　　首先是myIntentService.java

```java
public class myIntentService extends IntentService {

	//------------------必须实现-----------------------------
	
	public myIntentService() {
		super("myIntentService");
		// 注意构造函数参数为空，这个字符串就是worker thread的名字
	}

	@Override
	protected void onHandleIntent(Intent intent) {
		//根据Intent的不同进行不同的事务处理 
        String taskName = intent.getExtras().getString("taskName");  
        switch (taskName) {
		case "task1":
			Log.i("myIntentService", "do task1");
			break;
		case "task2":
			Log.i("myIntentService", "do task2");
			break;
		default:
			break;
		}		
	}
  //--------------------用于打印生命周期--------------------	
   @Override
  public void onCreate() {
		Log.i("myIntentService", "onCreate");
	super.onCreate();
}
	
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		Log.i("myIntentService", "onStartCommand");
		return super.onStartCommand(intent, flags, startId);
	}
	
	@Override
	public void onDestroy() {
		Log.i("myIntentService", "onDestroy");
		super.onDestroy();
	}
}
```

然后记得在Manifest.xml中注册服务

```java
 <service android:name=".myIntentService">
            <intent-filter >  
                <action android:name="cn.scu.finch"/>  
            </intent-filter>     
        </service>
```

最后在Activity中开启服务

```java
public class MainActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		
		//同一服务只会开启一个worker thread，在onHandleIntent函数里依次处理intent请求。
		
        Intent i = new Intent("cn.scu.finch");  
        Bundle bundle = new Bundle();  
        bundle.putString("taskName", "task1");  
        i.putExtras(bundle);  
        startService(i);  
           
        Intent i2 = new Intent("cn.scu.finch");  
        Bundle bundle2 = new Bundle();  
        bundle2.putString("taskName", "task2");  
        i2.putExtras(bundle2);  
        startService(i2); 
        
        startService(i);  //多次启动
	}
}
```

运行结果：

[![这里写图片描述](https://camo.githubusercontent.com/fb6bf8fc2ff7c1713ef558183b6ab0f47cb846e3/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353133313335343131303337)](https://camo.githubusercontent.com/fb6bf8fc2ff7c1713ef558183b6ab0f47cb846e3/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353133313335343131303337)　

　　IntentService在onCreate()函数中通过HandlerThread单独开启一个线程来依次处理所有Intent请求对象所对应的任务。通过onStartCommand()传递给服务intent被**依次**插入到工作队列中。工作队列又把intent逐个发送给onHandleIntent()。

> 注意： 它只有一个工作线程，名字就是构造函数的那个字符串，也就是“myIntentService”，我们知道多次开启service，只会调用一次onCreate方法（创建一个工作线程），多次onStartCommand方法（用于传入intent通过工作队列再发给onHandleIntent函数做处理）。

##### [7] IntentService——Handler与Service的结合 

**综述**

　　我们都知道Service是作为后台服务运行再程序中的。但是Service他依然是运行在主线程中的，所以我们依然不能在Service中进行耗时的操作。所以当我们在Service处理时，我们需要在Service中开启一个子线程，并且在子线程中运行。当然为了简化我们的操作，在Android中为我们提供了IntentService来进行这一处理，下面我们就来看一下这个IntentService用法以及它的工作原理。

**用法简介**

　　IntentService它继承自Service，一来说我们开启一个Service可以通过startService和bindService两个方式进行开启一个服务，但是对于IntentService我们采用startService方法进行开启服务，对于为什么要这么做，在后面会进行分析讲解。下面我们来看一下如何使用这个IntentService的。

**效果演示**

　　在这里我们做一个倒计时的程序，以毫秒为单位。这里先看一下效果演示。 

​                                                ![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTpy8CspBHm5RjmJsZbU6YsKibeaWobtRBCg7ahv5g76bqR8TosABUmDA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

**代码分析**

　　在这里我们使用到了开源框架EventBus，对于EventBus的使用可以参考 EventBus3.0使用详解这篇文章。由于我们用到这EventBus,首先我们创建一个实体类，在EventBus中进行发送，接收处理。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTkzbscibibDjE0rNJxRhpCgmk7xcZrkkWl3tlu1UWsmibfX3nJ93FlAVCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面我们看一下IntentService中的代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTO8QD9S1YNfsbpseDhazeHJLplSvQv4xiaS6PjRne1AmC2rT5lkFhmCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSThDRPckUxibsNm9yicNEL07HEMW8NFic1dP3ehWYMt2S5VjPFCWejrK4Yg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
    在上面的handleActionFoo方法中进行我们的耗时任务。然后我们在看一下Activity中的代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTwRIh3HDECYkicHnkUIB8SjanSUW59HrKBaNNbc6djlYUHu0pJDPupkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTTTiaDiacJZZmJTCbmBKRuHItpUV1pbrictSPx0oAiaEsia9sH22CdWLSb4Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　最后是布局代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTXoG5nZJrnP1Exh0KUFjriaVqEInkokB2ZdvLqTdYgz74yRl3mZSSmqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　对于上面代码实现起来都是非常的简单，在这里就不在进行详细介绍。

**IntentService工作原理分析**

　　其实对于IntentService的工作原理也不复杂，既然在IntentService中能够进行耗时操作，也就是说在这个IntentService中必然也创建了一个子线程，在Android中我们称为工作者线程。然后在这个工作者线程中进行我们的任务。在分析IntentService之前，我们先看一下HandlerThread。

**HandlerThread**

　　其实HandlerThread就是一个工作者线程，在这里看一下HandlerThread的源码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTepsCEdZwVLB1fibYxF4RKttibspqmCrg2AcrsyiaibXibSUkn92aWOf86yA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)　　![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTKkbVSAAU3nkPr7Uybk9pBznvdejYPMZ6uwLAyNJ006t6EMXY6ib8ViaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​    看过上篇文章 Android的消息机制——Handler的工作过程就很容易理解这个HandlerThread了。还记的我们在上篇文章的最后，新建了一个包含Looper的子线程。而这个HandlerThread也就是一个包含Looper的子线程。所以当我们需要创建一个包含Looper的线程时直接使用HandlerThread即可。对于HandlerThread有以下几点需要说明一下。 

　　1. 在构造方法中设置线程优先级的时候，使用的Process是android.os包中的而不是java.lang包内的。 
　　2. 如果在Looper开启消息循环之前我们进行一些设置，我们可以继承HandlerThread并且重写onLooperPrepared方法。 
　　3. 通过getLooper方法我们获取HandlerThread的Looper对象时，有可能Looper还未创建完成。所以在getLooper中未创建Looper是进行了线程等待操作，在创建完Looper以后在返回Looper对象。

**IntentService**

　　下面我们再看一下IntentService。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTKvgBvpPOQ2jF5pxJO2cQ0bJnm55xSO7K4EW6m62Zavjadb2hB2JNzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTxhw7cqTxFtMs3Y6QvTmRUAjHpDZQFzfVHqEVqowTS0g1RBP1WkxzXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　我们看一下这个IntentService的构造是不是很简单。在这里主要看一下onCreate和onStart方法即可。在onCreate中，我们开启了一个HandlerThread线程，之后获取HandlerThread线程中的Looper，并通过这个Looper创建了一个Handler。然后在onStart方法中通过这个Handler将intent与startId作为Message的参数进行发送到消息队列中，然后交由Handler中的handleMessage中进行处理。由于在onStart方法是在主线程内运行的，而Handler是通过工作者线程HandlerThread中的Looper创建的。所以也就是在主线程中发送消息，在工作者接收到消息后便可以进行一些耗时的操作。 
　　我们在看一下handleMessage中的操作，在handleMessage中调用onHandleIntent方法，他是一个抽象方法，所以在我们的Service中复写onHandleIntent方法并且将耗时的操作写在onHandleIntent方法内即可。当执行完onHandleIntent后通过stopSelf来停止服务，这样就不用我们手动停止服务了。所以也就回答了我们上面那个为什么要使用startService而不用onBind来开启一个IntentService。

**总结**

　　从我们的示例和源码分析中可以看出来。对于通过IntentService来执行任务，他是串行的。也就是说只有在上一个任务执行完以后才会执行下一个任务。因为Handler中将消息插入消息队列，而队列又是先进先出的数据结构。所以只有在上个任务执行完成以后才能够获取到下一个任务进行操作。在这里也就说明了对于高并发的任务同过IntentService是不合适.

## 【ContentProvider详解】

##### [1] ContentProvider是什么？

　　**ContentProvider（内容提供者）是Android的四大组件之一**，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。Android的数据存储方式总共有五种，分别是：**Shared Preferences、网络存储、文件存储、外储存储、SQLite**。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候**我们需要操作其他应用程序的一些数据，就会用到ContentProvider**。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。

　　但注意**ContentProvider它也只是一个中间人**，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。

##### [2] URL

　　URL（统一资源标识符）代表要操作的数据，可以用来标识每个ContentProvider，这样你就可以通过指定的URI找到想要的ContentProvider, 从中获取或修改数据。在Android中URI的格式如下图所示：

[![这里写图片描述](https://camo.githubusercontent.com/1e138aeb9ce10fa4b788b18659fae3d8d29da73a/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313534333232303435)](https://camo.githubusercontent.com/1e138aeb9ce10fa4b788b18659fae3d8d29da73a/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313534333232303435)　

　　

- Ａ： schema，已经由Android所规定为：content://．　 　　　
- Ｂ：主机名（Authority），是URI的授权部分，是唯一标识符，用来定位ContentProvider。

> Ｃ部分和D部分：是每个ContentProvider内部的路径部分

- Ｃ：指向一个对象集合，一般用表的名字，如果没有指定D部分，则返回全部记录。

- Ｄ：指向特定的记录，这里表示操作user表id为7的记录。如果要操作user表中id为7的记录的name字段， D部分变为       **/7/name**即可。

> URI模式匹配通配符
>
> *：匹配的任意长度的任何有效字符的字符串。
>
> ＃：匹配的任意长度的数字字符的字符串。
>
> 如：
>
> content://com.example.app.provider/* 匹配provider的任何内容url
>
> content://com.example.app.provider/table3/# 匹配table3的所有行

**2.１MIME**

　　MIME是指定某个扩展名的文件用一种应用程序来打开，就像你用浏览器查看PDF格式的文件，浏览器会选择合适的应用来打开一样。Android中的工作方式跟HTTP类似，ContentProvider会根据URI来返回MIME类型，ContentProvider会返回一个包含两部分的字符串。MIME类型一般包含两部分，如：

> text/html text/css text/xml application/pdf

　　分为类型和子类型，Android遵循类似的约定来定义MIME类型，每个内容类型的Android MIME类型有两种形式：多条记录（集合）和单条记录。

　　集合记录：

```
vnd.android.cursor.dir/自定义
```

　　单条记录：

```
vnd.android.cursor.item/自定义
```

　　vnd表示这些类型和子类型具有非标准的、供应商特定的形式。Android中类型已经固定好了，不能更改，只能区别是集合还是单条具体记录，子类型可以按照格式自己填写。在使用Intent时，会用到MIME，根据Mimetype打开符合条件的活动。

　　下面分别介绍Android系统提供了两个用于操作Uri的工具类：ContentUris和UriMatcher。

**2.２ ContentUris**

　　ContetnUris包含一个便利的函数withAppendedId()来向URI追加一个id。

```
Uri uri = Uri.parse("content://cn.scu.myprovider/user")
Uri resultUri = ContentUris.withAppendedId(uri, 7); 

//生成后的Uri为：content://cn.scu.myprovider/user/7
```

　　同时提供parseId(uri)方法用于从URL中获取ID:

```
Uri uri = Uri.parse("content://cn.scu.myprovider/user/7")
long personid = ContentUris.parseId(uri);
//获取的结果为:7
```

**2.３UriMatcher**

　　UriMatcher本质上是一个文本过滤器，用在contentProvider中帮助我们过滤，分辨出查询者想要查询哪个数据表。

　　举例说明：

- 第一步，初始化：

```
UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码
```

- 第二步，注册需要的Uri：

```
//USER 和 USER_ID是两个int型数据
matcher.addURI("cn.scu.myprovider", "user", USER);
matcher.addURI("cn.scu.myprovider", "user/#",USER_ID);
//如果match()方法匹配content://cn.scu.myprovider/user路径，返回匹配码为USER
```

- 第三部，与已经注册的Uri进行匹配:

```
/* 
     * 如果操作集合，则必须以vnd.android.cursor.dir开头 
     * 如果操作非集合，则必须以vnd.android.cursor.item开头 
     * */  
    @Override  
    public String getType(Uri uri) {  
    Uri uri = Uri.parse("content://" + "cn.scu.myprovider" + "/user");  
        switch(matcher.match(uri)){  
        case USER:  
            return "vnd.android.cursor.dir/user";  
        case USER_ID:  
            return "vnd.android.cursor.item/user";  
        }  
    } 
```

##### [3] ContentProvider的主要方法

> public boolean onCreate()

　　ContentProvider创建后或打开系统后其它应用第一次访问该ContentProvider时调用。

> public Uri insert(Uri uri, ContentValues values)

　　外部应用向ContentProvider中添加数据。

> public int delete(Uri uri, String selection, String[] selectionArgs)

　　外部应用从ContentProvider删除数据。

> public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)：

　　外部应用更新ContentProvider中的数据。

> public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　

　　供外部应用从ContentProvider中获取数据。 　

> public String getType(Uri uri)

　　该方法用于返回当前Url所代表数据的MIME类型。

##### [4] ContentResolver

　　ContentResolver通过URI来查询ContentProvider中提供的数据。除了URI以 外，还必须知道需要获取的数据段的名称，以及此数据段的数据类型。如果你需要获取一个特定的记录，你就必须知道当前记录的ID，也就是URI中D部分。

　　ContentResolver 类提供了与ContentProvider类相同签名的四个方法：

> public Uri insert(Uri uri, ContentValues values)　//添加

> public int delete(Uri uri, String selection, String[] selectionArgs)　//删除
>
> public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新
>
> public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取

实例代码：

```
ContentResolver resolver =  getContentResolver();
Uri uri = Uri.parse("content://cn.scu.myprovider/user");

//添加一条记录
ContentValues values = new ContentValues();
values.put("name", "fanrunqi");
values.put("age", 24);
resolver.insert(uri, values);  

//获取user表中所有记录
Cursor cursor = resolver.query(uri, null, null, null, "userid desc");
while(cursor.moveToNext()){
   //操作
}

//把id为1的记录的name字段值更改新为finch
ContentValues updateValues = new ContentValues();
updateValues.put("name", "finch");
Uri updateIdUri = ContentUris.withAppendedId(uri, 1);
resolver.update(updateIdUri, updateValues, null, null);

//删除id为2的记录
Uri deleteIdUri = ContentUris.withAppendedId(uri, 2);
resolver.delete(deleteIdUri, null, null);
```

##### [5] ContentObserver

　　　 ContentObserver(内容观察者)，目的是观察特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它.

```
下面是使用内容观察者监听短信的例子：
public class MainActivity extends Activity {
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
         
//注册观察者Observser    
this.getContentResolver().registerContentObserver(Uri.parse("content://sms"),true,new SMSObserver(new Handler()));
 
    }
 
    private final class SMSObserver extends ContentObserver {
 
        public SMSObserver(Handler handler) {
            super(handler);
 
        }
 
     
        @Override
        public void onChange(boolean selfChange) {
 
 Cursor cursor = MainActivity.this.getContentResolver().query(
Uri.parse("content://sms/inbox"), null, null, null, null);
 
            while (cursor.moveToNext()) {
                StringBuilder sb = new StringBuilder();
 
                sb.append("address=").append(
                        cursor.getString(cursor.getColumnIndex("address")));
 
                sb.append(";subject=").append(
                        cursor.getString(cursor.getColumnIndex("subject")));
 
                sb.append(";body=").append(
                        cursor.getString(cursor.getColumnIndex("body")));
 
                sb.append(";time=").append(
                        cursor.getLong(cursor.getColumnIndex("date")));
 
                System.out.println("--------has Receivered SMS::" + sb.toString());
 
                 
            }
 
        }
 
    }
}
```

同时可以在ContentProvider发生数据变化时调用 getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者。

　　

```
public class UserContentProvider extends ContentProvider {
   public Uri insert(Uri uri, ContentValues values) {
      db.insert("user", "userid", values);
      getContext().getContentResolver().notifyChange(uri, null);
   }
}
```

##### [6] 实例说明

　　数据源是SQLite, 用ContentResolver操作ContentProvider。

![img](https://camo.githubusercontent.com/1302cfe3a60f9edf38daa5202d006ea98ae7d9af/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313935313433303939)

Constant.java（储存一些常量）

```
public class Constant {  
      
    public static final String TABLE_NAME = "user";  
      
    public static final String COLUMN_ID = "_id";  
    public static final String COLUMN_NAME = "name";  
       
       
    public static final String AUTOHORITY = "cn.scu.myprovider";  
    public static final int ITEM = 1;  
    public static final int ITEM_ID = 2;  
       
    public static final String CONTENT_TYPE = "vnd.android.cursor.dir/user";  
    public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/user";  
       
    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTOHORITY + "/user");  
}  
```

DBHelper.java(操作数据库)

```
public class DBHelper extends SQLiteOpenHelper {  
  
    private static final String DATABASE_NAME = "finch.db";    
    private static final int DATABASE_VERSION = 1;    
  
    public DBHelper(Context context) {  
        super(context, DATABASE_NAME, null, DATABASE_VERSION);  
    }  
  
    @Override  
    public void onCreate(SQLiteDatabase db)  throws SQLException {  
        //创建表格  
        db.execSQL("CREATE TABLE IF NOT EXISTS "+ Constant.TABLE_NAME + "("+ Constant.COLUMN_ID +" INTEGER PRIMARY KEY AUTOINCREMENT," + Constant.COLUMN_NAME +" VARCHAR NOT NULL);");  
    }  
  
    @Override  
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)  throws SQLException {  
        //删除并创建表格  
        db.execSQL("DROP TABLE IF EXISTS "+ Constant.TABLE_NAME+";");  
        onCreate(db);  
    }  
}  
```

　MyProvider.java(自定义的ContentProvider)　

```
public class MyProvider extends ContentProvider {    
    
    DBHelper mDbHelper = null;    
    SQLiteDatabase db = null;    
    
    private static final UriMatcher mMatcher;    
    static{    
        mMatcher = new UriMatcher(UriMatcher.NO_MATCH);    
        mMatcher.addURI(Constant.AUTOHORITY,Constant.TABLE_NAME, Constant.ITEM);    
        mMatcher.addURI(Constant.AUTOHORITY, Constant.TABLE_NAME+"/#", Constant.ITEM_ID);    
    }    
    
  
    @Override    
    public String getType(Uri uri) {    
        switch (mMatcher.match(uri)) {    
        case Constant.ITEM:    
            return Constant.CONTENT_TYPE;    
        case Constant.ITEM_ID:    
            return Constant.CONTENT_ITEM_TYPE;    
        default:    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
    }    
    
    @Override    
    public Uri insert(Uri uri, ContentValues values) {    
        // TODO Auto-generated method stub    
        long rowId;    
        if(mMatcher.match(uri)!=Constant.ITEM){    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
        rowId = db.insert(Constant.TABLE_NAME,null,values);    
        if(rowId>0){    
            Uri noteUri=ContentUris.withAppendedId(Constant.CONTENT_URI, rowId);    
            getContext().getContentResolver().notifyChange(noteUri, null);    
            return noteUri;    
        }    
    
        throw new SQLException("Failed to insert row into " + uri);    
    }    
    
    @Override    
    public boolean onCreate() {    
        // TODO Auto-generated method stub    
        mDbHelper = new DBHelper(getContext());    
    
        db = mDbHelper.getReadableDatabase();    
    
        return true;    
    }    
    
    @Override    
    public Cursor query(Uri uri, String[] projection, String selection,    
            String[] selectionArgs, String sortOrder) {    
        // TODO Auto-generated method stub    
        Cursor c = null;    
        switch (mMatcher.match(uri)) {    
        case Constant.ITEM:    
            c =  db.query(Constant.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);    
            break;    
        case Constant.ITEM_ID:    
            c = db.query(Constant.TABLE_NAME, projection,Constant.COLUMN_ID + "="+uri.getLastPathSegment(), selectionArgs, null, null, sortOrder);    
            break;    
        default:    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
    
        c.setNotificationUri(getContext().getContentResolver(), uri);    
        return c;    
    }    
    
    @Override    
    public int update(Uri uri, ContentValues values, String selection,    
            String[] selectionArgs) {    
        // TODO Auto-generated method stub    
        return 0;    
    }

	@Override
	public int delete(Uri uri, String selection, String[] selectionArgs) {
		// TODO Auto-generated method stub
		return 0;
	}    
    
}    
```

MainActivity.java(ContentResolver操作)

```
public class MainActivity extends Activity {
    private ContentResolver mContentResolver = null; 
    private Cursor cursor = null;  
         @Override
        protected void onCreate(Bundle savedInstanceState) {
        	// TODO Auto-generated method stub
        	super.onCreate(savedInstanceState);
        	setContentView(R.layout.activity_main);
        	
        	   TextView tv = (TextView) findViewById(R.id.tv);
				
        		mContentResolver = getContentResolver();  
        		tv.setText("添加初始数据 ");
                for (int i = 0; i < 10; i++) {  
                    ContentValues values = new ContentValues();  
                    values.put(Constant.COLUMN_NAME, "fanrunqi"+i);  
                    mContentResolver.insert(Constant.CONTENT_URI, values);  
                } 
                
            	tv.setText("查询数据 ");
                cursor = mContentResolver.query(Constant.CONTENT_URI, new String[]{Constant.COLUMN_ID,Constant.COLUMN_NAME}, null, null, null);  
                if (cursor.moveToFirst()) {
                	String s = cursor.getString(cursor.getColumnIndex(Constant.COLUMN_NAME));
                	tv.setText("第一个数据： "+s);
                }
        }
         
}  
```

最后在manifest申明

```
<provider android:name="MyProvider" android:authorities="cn.scu.myprovider" />
```

## 【BroadcastReceiver详细解析】

##### [1] BroadcastReceiver的定义

广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。

在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。

BroadcastReceiver **自身并不实现图形用户界面**，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。

##### [2] BroadcastReceiver使用注意

　　当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。

在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。

##### [3] BroadcastReceiver的注册

　　BroadcastReceiver的注册方式有且只有两种，一种是**静态注册**（推荐使用），另外一种是**动态注册**，广播接收者在注册后就开始监听系统或者应用之间发送的广播消息。

**接收短信广播示例**：

定义自己的BroadcastReceiver 类

```
public class MyBroadcastReceiver extends BroadcastReceiver {
 
// action 名称
String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED" ;
 
    public void onReceive(Context context, Intent intent) {
 
       if (intent.getAction().equals( SMS_RECEIVED )) {
           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。
       }
    }
}
```

**静态方式**

　　在AndroidManifest.xml的application里面定义receiver并设置要接收的action。

```
< receiver android:name = ".MyBroadcastReceiver" > 

 < intent-filter android:priority = "777" >             
<action android:name = "android.provider.Telephony.SMS_RECEIVED" />
</ intent-filter > 

</ receiver >
```

　　这里的priority取值是-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。

```
< uses-permission android:name ="android.permission.RECEIVE_SMS" />
```

　　静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。

**动态方式**

　　在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. 　　　

```
public class MainActivity extends Activity {
	MyBroadcastReceiver receiver;
	@Override
	 protected void onResume() {
		// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)
		receiver = new MyBroadcastReceiver();
		IntentFilter intentFilter = new IntentFilter( "android.provider.Telephony.SMS_RECEIVED" );
		registerReceiver( receiver , intentFilter);	
		super.onResume();
	}
	@Override
	protected void onPause() {  
		// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)
		unregisterReceiver(receiver);
		super.onPause();
	}
}
```

**静态注册和动态注册的区别**

　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。

　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。动态注册的广播接收者将会导致应用报错 而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。　

##### [4] 发送BroadcastReceiver

**发送广播主要有两种类型：**

**普通广播**

应用在需要通知各个广播接收者的情况下使用，如 开机启动

使用方法：sendBroadcast()

```
Intent intent = new Intent("android.provider.Telephony.SMS_RECEIVED"); 
//通过intent传递少量数据
intent.putExtra("data", "finch"); 
// 发送普通广播
sendBroadcast(Intent); 
```

　　普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的 BroadcastReceiver 都会随机地执行其 onReceive() 方法。 　　同级别接收是先后是随机的；级别低的收到广播； 　　消息传递的效率比较高，并且无法中断广播的传播。

**有序广播**

应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。　

使用方法：

　`sendOrderedBroadcast(intent, receiverPermission);`

　`receiverPermission` ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）。

```
//发送有序广播
 sendOrderedBroadcast(intent, null);
```

　　在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。

```
public void onReceive(Context arg0, Intent intent) {
　　//获取上一个广播的bundle数据
　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle
　　bundle.putString("key", "777");
　　//将bundle数据放入广播中传给下一个广播接收者
　　setResultExtras(bundle);　
　　
　　//终止广播传给下一个广播接收者
　　abortBroadcast();
}
```

　　高级别的广播收到该广播后，可以决定把该广播是否截断掉。 　　同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　　

异步广播

使用方法：`sendStickyBroadcast()` ：

　　发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它。

发这个广播需要权限：

```
<uses-permission android:name="android.permission.BROADCAST_STICKY" />
```

卸载该广播：

```
removeStickyBroadcast(intent);
```

　　在卸载之前该intent会保留，接收者在可接收状态都能获得。

**异步有序广播**

　　使用方法：`sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)`：

　　这个方法具有有序广播的特性也有异步广播的特性； 　　同时需要限权：

```
 <uses-permission android:name="android.permission.BROADCAST_STICKY" /> 
```

##### [5] 总结

- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。
- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：

　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。

　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。

- 广播发出的时候，广播接收者接收的顺序如下：

　　１．当广播为**普通广播**时，有如下的接收顺序：

无视优先级

动态优先于静态 

同优先级的动态广播接收器，**先注册的大于后注册的**

同优先级的静态广播接收器，**先扫描的大于后扫描的**　

　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：

优先级高的先接收　 　　

同优先级的动静态广播接收器，**动态优先于静态** 　　

同优先级的动态广播接收器，**先注册的大于后注册的** 　　

同优先级的静态广播接收器，**先扫描的大于后扫描的**　

##### [6]一些常用的系统广播的action 和permission

- 开机启动

```
<action android:name="android.intent.action.BOOT_COMPLETED"/> 
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />  
```

- 网络状态

```
<action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>  
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/> 
```

　　　网络是否可用的方法：

```
  public static boolean isNetworkAvailable(Context context) {  
        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  
        NetworkInfo[] info = mgr.getAllNetworkInfo();  
        if (info != null) {  
            for (int i = 0; i < info.length; i++) {  
      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  
                    return true;  
                }  
            }  
        }  
        return false;  
    } 
```

- 电量变化

```
<action android:name="android.intent.action.BATTERY_CHANGED"/>  
```

BroadcastReceiver 的onReceive方法：

```
public void onReceive(Context context, Intent intent) {  
        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　
        
        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  
        int percent = currLevel * 100 / total;  
        Log.i(TAG, "battery: " + percent + "%");  
    }  
```



# 安卓开发之路第一天（8.16）

### 事件1：阅读《第一行代码》P1-82

#### 第一章：第一行代码

##### 1.  安卓的发展

##### 2. 搭建开发环境

模拟器选择：**pixel**

##### 3. 创建第一个安卓开发环境

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817092618656.png" alt="image-20200817092618656" style="zoom:50%;" />

##### 4.详解安卓开发目录结构

* **grable是什么？**

Gradle 是一个基于 [Apache Ant](https://www.oschina.net/p/apache+ant) 和 [Apache Maven](https://www.oschina.net/p/maven) 概念的项目自动化构建工具，支持依赖管理和多项目，类似 [Maven](https://www.oschina.net/p/maven)，但比之简单轻便。它使用一种基于 [Groovy](https://www.oschina.net/p/groovy) 的特定领域语言来声明项目设置，而不是传统的 XML。

当前其支持的语言限于 Java、Groovy 和 Scala，计划未来将支持更多的语言。

1. **project目录**

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817100902922.png" alt="image-20200817100902922" style="zoom:80%;" />

2. **app目录**



<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817101447841.png" alt="image-20200817101447841" style="zoom:80%;" />

3. **AndroidManifest**

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myfistapp">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

4. **Manifest**

```java
package com.example.myfistapp;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
//AppCompatActivity向下兼容的Activity
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //视图和逻辑分离，所以没有helloword
        super.onCreate(savedInstanceState);
        //引入了一个ContentView布局
        setContentView(R.layout.activity_main);
    }
}
```

5. **R.layout.activity_main**

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />


</androidx.constraintlayout.widget.ConstraintLayout>
~~~

6. **如何引用？**

代码中：R.layout.activity_main

XML中：android:icon="@mipmap/ic_launcher"

7.  外层grable

```java
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    //代码仓库
    repositories {
        google()
        jcenter()
    }
    //
    dependencies {
        classpath "com.android.tools.build:gradle:4.0.1"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories 
        //两个插件
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁.

8. 内层grable

~~~java
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.example.myfistapp"
        minSdkVersion 15
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'

}
~~~

##### 5. 掌握日志工具的使用

专业的！

* 日志开关可控制
* 可添加日志标签
* 日志级别可以区分

#### 第二章：快速入门Kotlin

##### 1.  语言简洁

##### 2  变量

自动转型：

val：对应final变量

var：对应final常量

##### 3.  函数

fun，单行代码可不加{}

##### 4.  逻辑控制语句（if  when for）

if：有返回值，每个条件中最后一行代码的返回值

when：有返回值，可以用->，**判断对象相等可以直接用==，判断引用相等===**

while和for：for-in,并且可以用until跳出区间

##### 5.  类

**类**：class

**方法**：fun

##### 6.  继承与构造函数

**继承**：默认不可被继承，加上open才可以

**构造函数：**这里比较复杂

##### 7.  接口

继承： **：**

实现： **，**

访问修饰符：Kotiln默认是public，另外还有internal关键字

##### 8. 数据类与单例类

class->object

##### 9. Lambda编程

**集合创建（更简洁）和遍历（for-in）！**

**集合的函数式API**：求一个集合里面的最大值，直接list.maxBy

**java函数API**

##### 10. 空指针检查

空指针异常解决：编译时期会直接报错

**？.**  可为空

**？：** 类似于java中的？：

##### 11.小魔术

**字符串内嵌表达式** 

**给参数的默认值**

# 安卓开发之路第二天（8.17）

#### 事件1： 复习+连接到手机

https://www.cnblogs.com/oreox/p/10662066.html

#### 事件2： 学习activty

##### 1. 编写按钮

~~~java
    <Button
        android:id="@+id/button" //定义一个唯一id
        android:layout_width="match_parent" //定义宽度，匹配父元素
        android:layout_height="wrap_content" //定义高度，刚好包含里面的内容wrap_content
        android:text="Button" /> //显示内容
~~~

##### 2. activity调用

~~~java
package com.example.mysecendacticity;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class FristActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //调用父类默认实现
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
    }
}
~~~

##### 3. andoridMainActivity

~~~java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.mysecendacticity">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".FristActivity"
            android:label="This is FristActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            </activity>
    </application>

</manifest>
~~~

##### 4. **toast**

```java
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
        Button button1=(Button) findViewById(R.id.button1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); }
        });
    }
}
```

##### 5.**菜单**

~~~java
    @Override
    //菜单可见
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
    @Override
    //菜单响应时间
    public boolean onOptionsItemSelected(MenuItem item) {
        //使用item.getItemId()判断使用哪个菜单项
        switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
            default:
        }
        return true;
    }
}
~~~

##### 6.**intent**

~~~java
//显示       
button1.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        //第一个参数Context 要求提供一个启动活动的上下文， 第二个参数Class 则是指定想要启动的目标活动
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                        startActivity(intent);
                    }
        });

    }
~~~

~~~xml
//隐式  

<activity android:name=".SecondActivity">
            <intent-filter> 
                <action android:name="com.example.activitytest.ACTION_START" /> 
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity
~~~

在<action> 标签中我们指明了当前活动可以响应 **com.example.activitytest.ACTION_START** 这个action ，而<category> 标签则包含 了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的**category** 。只 有<action> 和<category> 中的内容同时能够匹配上Intent中指定的**action** 和**category** 

时，这个活动才能响应该**Intent**。 

##### 7.[Intent的常用属性action和category](https://www.cnblogs.com/z-cg/p/12356168.html)

**设置隐式跳转时**，首先在我们按钮监听器中添加

```java
Intent i=new Intent();
//参数为字符串，可以添加包名.活动名
i.setAction("com.example.aaaaa.testliandong.MainActivity");
startActivity(i);
```

只是这样还不够，必须得在AndroidMainfest.xml文件中添加如下代码

```xml
 <activity android:name=".NewActivity">
             <intent-filter>
                 <action android:name="com.example.aaaaa.testliandong.MainActivity"/>
                 <category android:name="android.intent.category.DEFAULT"/>
             </intent-filter>
        </activity>
```

其中第一行和活动的声明一样，intent-filter标签中的action中name的值为和之前在Java中setAction的参数一样，category中的name值为android.intent.category.DEFAULT，DEFAULT则表示跳转为隐式跳转

可以看到，我们使用了Intent的另一个构造函数，直接将action 的字符串传了进去，表明我们 

想要启动能够响应com.example.activitytest.ACTION_START 这个action 的活动。那 前面不是说要<action> 和<category> 同时匹配上才能响应的吗？**怎么没看到哪里有指定 category 呢？**这是因为android.intent.category.DEFAULT 是一种默认的category ，在调用startActivity() 方法的时候会自动将这个category 添加到Intent中。 

##### 8.**Activity的Action(单个)和category（多个）属性**

https://blog.csdn.net/itszt888/article/details/76074243

介绍Action和Category的关系 
举一个例子,一个女孩子找男朋友,她有一些要求：男性、高、富、帅。 
男性相当于`Action`,`Action`这能有一个 
高富帅相当于`Category`,`Category`可以有很多 
而一个男性有很多特点,满足了很多女孩系择偶的标准,用如下图表示

![这里写图片描述](https://img-blog.csdn.net/20170725152114852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRzenQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

~~~java
//今天看了Activity，来跟大家分享一下它的Action属性和category属性
//下面页面为第一个页面，页面只有一个跳转按钮，此处不再给出页面布局
package a.a;

import android.app.Activity;
import android.os.Bundle;
import android.widget.*;
import android.view.*;
import android.view.View.OnClickListener;
import android.content.*;
public class Er extends Activity 
{
   private Button jump;
   private static final String MY_ACTION = "ery.src.a.a.MY_ACTION";
   private static final String MY_CATEGORY = "ery.src.a.a.MY_CATEGORY";
   public void onCreate(Bundle savedInstanceState) 
  {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.main);
       jump = (Button)findViewById(R.id.jump);
       jump.setOnClickListener(new OnClickListener()
       {
           public void onClick(View v)
           {
               //此处为intent添加了一个自定义action和一个自定义category属性，因此配置被启                        //动Activity在注册表androidmanifest.xml文件中要包括这样的两行配置:
               //<action android:name="ery.src.a.a.MY_ACTION" />和
               //<category android:name="ery.src.a.a.MY_CATEGORY" />，然而每一个Intent还                          //有一个默认的category，所以这个默认的也得注册，为:
               //<category android:name="android.intent.category.DEFAULT" />
               //总之归结起来，注册表中的Activity要想启动，必须包含对应Intent的Action属性
               //和Intent的所有category属性。(附：一个Intent只能有一个acton，但可以添加多                        //个category)
               Intent  intent = new Intent();
               intent.setAction(MY_ACTION);
               intent.addCategory(MY_CATEGORY);
                Er.this.startActivity(intent);
            }
        });
   }
}
//第二个页面，只有一个TextView，在此不再给出布局文件
package a.a;
import android.app.*;
import android.os.Bundle;
public class Second extends Activity
{
    protected void onCreate(Bundle savedInstanceState) 
    {
       super.onCreate(savedInstanceState);
       super.setContentView(R.layout.second);
    }
}
~~~

~~~xml

//AnaroidManifest.xml文件
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="a.a"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="15" />

    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <activity
            android:label="@string/app_name"
            android:name=".Er" >
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".Second"
            android:theme="@android:style/Theme.Dialog" 
            >
            <intent-filter>
                <action android:name="ery.src.a.a.MY_ACTION" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="ery.src.a.a.MY_CATEGORY" />
                <category android:name="saer"/>
            </intent-filter>
        </activity>
    </application>

</manifest>

~~~

##### 9. 更多隐式**Intent**的用法 

使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得 Android多个应用程序之间的功能共享成为了可能。比如说你的应用程序中需要展示一个网页， 这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器 来打开这个网页就行了。

~~~xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <action android:name="com.example.activitytest.ACTION_START" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="com.example.activitytest.MY_CATEGORY" />
            </intent-filter>
        </activity>
        <activity
~~~



我们在ThirdActivity的<intent-filter> 中配置了当前活动能够响应的action 

是Intent.ACTION_VIEW 的常量值，而category 则毫无疑问指定了默认的category 值， 

另外在<data> 标签中我们通过android:scheme 指定了数据的协议必须是http协议，这样 

ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。



~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                //常量值
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~



 我们还可以在<intent-filter> 标签中再配置一个<data> 标签，用于**更精确地** 

**指定当前活动能够响应什么类型的数据**。<data> 标签中主要可以配置以下内容。 

android:scheme 。用于指定数据的协议部分，如上例中的http部分。 

android:host 。用于指定数据的主机名部分，如上例中的www.baidu.com部分。 

android:port 。用于指定数据的端口部分，一般紧随在主机名之后。 

android:path 。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内 

容。

android:mimeType 。用于指定可以处理的数据类型，允许使用通配符的方式进行指 

定。 

只有<data> 标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该 

Intent。不过一般在<data> 标签中都不会指定过多的内容，如上面浏览器示例中，其实**只需要** 

**指定android:scheme 为http，就可以响应所有的http协议的Intent了。** 

为了让你能够更加直观地理解，我们来自己建立一个活动，让它也能响应打开网页的Intent。

~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~

##### 10.  向下一个activity传输数据

~~~java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            //Intent中提供了一系列putExtra() 方法的重载，可以把 我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出 就可以了
            public void onClick(View v) {
                String data = "Hello SecondActivity";
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                intent.putExtra("extra_data", data);
                startActivity(intent);
            }
        });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.second_layout);
            Intent intent = getIntent();
            String data = ((Intent) intent).getStringExtra("extra_data");
            Log.d("SecondActivity", data); }
~~~

##### 11. 返回数据给上一个活动 

既然可以传递数据给下一个活动，那么能不能够返回数据给上一个活动呢？答案是肯定的。不 过不同的是，返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动的Intent 来传递数据。通过查阅文档你会发现，Activity中还有一个**startActivityForResult() 方 法**也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 毫无疑问，这就是我们所需要的。 

startActivityForResult() 方法接收两个参数，第一个参数还是Intent，第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改FirstActivity中按钮的 点击事件，代码如下所示： 

~~~java
        button1.setOnClickListener(
                new View.OnClickListener() { 
                    @Override 
                    public void onClick(View v) { 
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class); 
                        startActivityForResult(intent, 1); } 
                });
~~~

# 安卓开发之路第三天（8.18）

# 安卓开发之路第四天（8.19）

# 安卓开发之路第五天（8.20）

# 安卓开发之路第六天（8.21）

### 天气预报App

#### 1. 需求分析

**酷欧天气中至少应该具备以下功能：**

1. 可以罗列出全国所有的省、市、县； 

2. 可以查看全国任意城市的天气信息； 

3. 可以自由地切换城市，去查看其他城市的天气； 

4. 提供手动更新以及后台自动更新天气的功能。

#### 2. 技术可行性分析（彩云天气）

我们 如何才能得到全国省市县的数据信息，以及如何才能获取到每个城市的天气信息。比较遗憾的 是，现在网上免费的天气预报接口已经越来越少，很多之前可以使用的接口都慢慢关闭掉了， 包括本书第1版中使用的中国天气网的接口。因此，这次我也是特意用心去找了一些更加稳定的 天气预报服务，比如彩云天气以及和风天气都非常不错。这两个天气预报服务虽说都是收费 的，但它们每天都提供了一定次数的免费天气预报请求。其中彩云天气的数据更加实时和专 业，可以将天气预报精确到分钟级，每天提供1000次免费请求；和风天气的数据相对简单一 些，比较适合新手学习，每天提供3000次免费请求。那么简单起见，这里我们就使用和风天气 来作为天气预报的数据来源，每天3000次的免费请求对于学习而言已经是相当充足了。

>https://id.heweather.com/#/login?redirect=https%3A%2F%2Fconsole.heweather.com%2F%23%2Fconsole

#### 3.  Gitee托管

https://gitee.com/xumingxiao/Sunny-Weather

#### 4.  搭建MVVM项目架构

#### 5 创建数据库和表

~~~java
dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
    //添加依赖项,使用LitePal对数据库进行操作
    implementation 'org.litepal.android:java:3.0.0'
}
~~~

~~~java
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'androidx.appcompat:appcompat:1.3.0-alpha01'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.3.0-rc03'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0-alpha4'
    //
    implementation 'org.litepal.android:java:3.0.0'
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
    implementation 'com.squareup.retrofit2:converter-scalars:2.5.0'
    implementation 'com.github.bumptech.glide:glide:3.7.0'
    def lifecycle_version = "2.0.0"
    // ViewModel and LiveData
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
}
~~~

#### 6 LitePal

https://www.jianshu.com/p/9d0d00b69fe8

https://www.jianshu.com/p/6d3a0f87d637

**学习文档：**

https://github.com/guolindev/LitePal

#### 7 为什么需要实体类

最近因为学习三层架构中的实体类，引发不少问题，下面具体说下三层中的实体类，即数据库表的映射

**为何使用实体类？**

数据库中，DatsSet 不具备OO的优点， 实现数据检索繁琐，易出错， 使数据结构暴露在业务逻辑层和表现层

> “OO，它是英文词组Object Oriented的缩写，它的意思是面向对象

为了消除以上局限我们使用实体类:

![img](https:////upload-images.jianshu.io/upload_images/6923303-2ec385d83393a914.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)



**举例说明**

用实体类之后，代码时变得简介，面向对象**封装**思想，最重要的是，**如果将来有所改动，只需要改动实体类， 方法间调用接口，完全不需要变动，大大减少了程序修改量，迎合了面向对象中接口不变的思想。**

甚至在程序设计时，就把将来可能需要的属性预先放在实体类中，这样以后变动时，连实体类都不用变动了

实体类在三层结构中的主要作用是什么？

Using 语句的主要作用是什么？

**为什么需要实体类？**

 从OOP细想考虑

 它是完全受控制的对象

 它具有面向对象的基本特征

 可以自定义行为

消除了关系数据和对象之间的差异

**为我们在关系数据库和对象之间架起了一座桥梁**

**什么是实体类？**

 **简单的说就是描述一个业务实体的类， 例如： 管理员的信息**

![img](https:////upload-images.jianshu.io/upload_images/6923303-e26ae89a463c6480.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)



**下面几个问题是值得思考的**

**表示层如何使用实体类？**

**业务逻辑层如何使用实体类？**



![img](https:////upload-images.jianshu.io/upload_images/6923303-6a1d13147862af10.png?imageMogr2/auto-orient/strip|imageView2/2/w/667/format/webp)



**数据访问层如何使用实体类？**

他们之间的业务实体的依赖图为

![img](https:////upload-images.jianshu.io/upload_images/6923303-85645b9c7cfc862e.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



 其中Using 语句，用于定义一个范围，在此范围末尾将释放对象



![img](https:////upload-images.jianshu.io/upload_images/6923303-a4c0b2b7ba9ef313.png?imageMogr2/auto-orient/strip|imageView2/2/w/571/format/webp)

https://blog.csdn.net/qq_41386332/article/details/99701010

#### 8 OkHttp用法

https://www.jianshu.com/p/f5320b1e0287

https://github.com/square/okhttp

原理：https://www.jianshu.com/p/7b29b89cd7b5

#### 9. throw new RuntimeException("Stub!")

https://blog.csdn.net/anhenzhufeng/article/details/75268195

这样定义的方法，表示在程序执行的时候，实际由android rom里面相同的类来执行。

**为什么会出现这样的定义？**我猜想可能是，这个类实际只在rom里面提供，而我们有时候要用到这个类的一些方法，那么就以这种方式来提供，因为在编译期间，我们的程序要使用这个类，那必然要提供这个类的定义，不然就引用不了。

就比如在看滴滴的插件化开源软件[VirtualAPK](https://github.com/didi/VirtualAPK) 的时候，在hack AMS服务的时候，需要用到ActivityManagerNative这个类，而这个类我们知道在api里面没有提供，是在framework里面提供的。那么要想引入这个类，要么就是编译一个framework.jar包，工程引用这个jar包，但是这样有个问题，我们的应用要安装在各种版本的系统里面，每个版本的framework都是有差异的，兼容性就低了。所以这里使用了另外一种方法，在我们的工程中声明一个和framework一模一样的类，在运行的时候就能自动运行rom里面的类了。

# 安卓开发之路第六天（8.22）

#### 1 编写ChooseAreaFragment类

**ChooseAreaFragment**用于展示查询界面和实现基本查询功能，继承于**Fragment**

1. 重写**onCreateView**，获取到了一些控件的实例，然后去初始化了ArrayAdapter，并将它设置为ListView的适 配器。
2. **onActivityCreated()**，接着在onActivityCreated() 方法中给**ListView和Button**设置了点击事件，到这里我 们的初始化工作就算是完成了。在onActivityCreated() 方法的最后，调用了queryProvinces() 方法，也就是从这里开 始加载省级数据的。
   * **queryProvinces() 方法**中首先会将头布局的标题设置成中国，将返回 按钮隐藏起来，因为省级列表已经不能再返回了。然后调用LitePal的查询接口来从数据库中读 取省级数据，如果读取到了就直接将数据显示到界面上，如果没有读取到就按照14.1节讲述的接 口组装出一个请求地址，然后调用queryFromServer() 方法来从服务器上查询数据。
     * **queryFromServer() 方法**中会调用HttpUtil的sendOkHttpRequest() 方法来向服务器发送 请求，响应的数据会回调到onResponse() 方法中，然后我们在这里去调用Utility的 handleProvincesResponse() 方法来解析和处理服务器返回的数据，并存储到数据库中。 接下来的一步很关键，在解析和处理完数据之后，我们再次调用了queryProvinces() 方法 来重新加载省级数据，由于queryProvinces() 方法牵扯到了UI操作，因此必须要在主线程 中调用，这里借助了runOnUiThread() 方法来实现从子线程切换到主线程。现在数据库中已 经存在了数据，因此调用queryProvinces() 就会直接将数据显示到界面上了。
3. 当你点击了某个省的时候会进入到ListView的**onItemClick()** 方法中，这个时候会根据当前的 级别来判断是去**调用queryCities()** 方法还是queryCounties() 方法，queryCities() 方法是去查询市级数据，而**queryCounties() 方法**是去查询县级数据，这两个方法内部的流 程和queryProvinces() 方法基本相同，这里就不重复讲解了。 另外还有一点需要注意，在返回按钮的点击事件里，会对当前ListView的列表级别进行判断。如 果当前是县级列表，那么就返回到市级列表，如果当前是市级列表，那么就返回到省级表列表。当返回到省级列表时，返回按钮会自动隐藏，从而也就不需要再做进一步的处理了。 

~~~java
package com.example.sunnywheather.activity;

import android.app.ProgressDialog;
import android.os.Bundle;
import android.telecom.Call;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

import com.example.sunnywheather.R;
import com.example.sunnywheather.db.City;
import com.example.sunnywheather.db.County;
import com.example.sunnywheather.db.Province;
import com.example.sunnywheather.util.HttpUtil;
import com.example.sunnywheather.util.Utility;

import org.litepal.LitePal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.security.auth.callback.Callback;

import okhttp3.Response;
// 新建一个ChooseAreaFragment用于展示查询界面和实现基本查询功能
public class ChooseAreaFragment extends Fragment {
    public static final int LEVEL_PROVINCE = 0;
    public static final int LEVEL_CITY = 1;
    public static final int LEVEL_COUNTY = 2;
    private ProgressDialog progressDialog;
    private TextView titleText;
    private Button backButton;
    private ListView listView;
    private ArrayAdapter<String> adapter;
    private List<String> dataList = new ArrayList<>();
    /*** 省列表 */
    private List<Province> provinceList;
    /*** 市列表 */
    private List<City> cityList;
    /*** 县列表 */
    private List<County> countyList;
    /*** 选中的省份 */
    private Province selectedProvince;
    /*** 选中的城市 */
    private City selectedCity;
    /*** 当前选中的级别*/
    private int currentLevel;

    /**
     * 在onCreateView()方法中先是获取到了一些控件的实例，
     * 然后去初始化了ArrayAdapter，并将它设置为ListView的适配器。
     * 接着在onActivityCreated() 方法中给ListView和Button设置了点击事件，
     * 到这里我们的初始化工作就算是完成了
     * @param inflater
     * @param container
     * @param savedInstanceState
     * @return
     */
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

        View view = inflater.inflate(R.layout.choose_area, container, false);
        titleText = (TextView) view.findViewById(R.id.title_text);
        backButton = (Button) view.findViewById(R.id.back_button);
        listView = (ListView) view.findViewById(R.id.list_view);
        adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_list_item_1, dataList);
        listView.setAdapter(adapter);
        return view;
    }

    /**
     * 在onActivityCreated()方法中设置ListView和Button的点击事件，
     * 在这里完成了基本的初始化操作，调用queryProvinces()方法，加载省级数据
     * @param savedInstanceState
     */
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        //对列表设置监听事件
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if(currentLevel == LEVEL_PROVINCE){
                    //记住选中的省份
                    selectedProvince = provinceList.get(position);
                    //显示出省份对应下city的界面
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //记住选中的City
                    selectedCity = cityList.get(position);
                    //切换到相应的county界面
                    queryCounties();
                }
            }
        });
        //为返回按钮注册监听事件
        backButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View v){
                //若在county切换到City
                if(currentLevel == LEVEL_COUNTY){
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //若在City切换到province
                    queryProvinces();
                }
            }
        });
        //初始状态下显示province
        queryProvinces();
    }

    /*** 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryProvinces() {
        //首先将头布局的标题设为中国
        titleText.setText("中国");
        //隐藏返回按键
        backButton.setVisibility(View.GONE);
        //调用LitePal接口读取省级数据
        provinceList = LitePal.findAll(Province.class);
        //如果读取到了就直接将数据显示在桌面上
        if (provinceList.size() > 0) {
            dataList.clear();
            //遍历链表
            for (Province province : provinceList) {
                dataList.add(province.getProvinceName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_PROVINCE;
        } else {
            //否则向服务器上查询
            String address = "http://guolin.tech/api/china";
            //传入一个地址和回调函数
            queryFromServer(address, "province");
        }
    }

    /*** 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCities() {
        titleText.setText(selectedProvince.getProvinceName());
        backButton.setVisibility(View.VISIBLE);
        cityList = LitePal.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class);
        if (cityList.size() > 0) {
            dataList.clear();
            for (City city : cityList) {
                dataList.add(city.getCityName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_CITY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            String address = "http://guolin.tech/api/china/" + provinceCode;
            queryFromServer(address, "city");
        }
    }

    /*** 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCounties() {
        titleText.setText(selectedCity.getCityName());
        backButton.setVisibility(View.VISIBLE);
        countyList = LitePal.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class);
        if (countyList.size() > 0) {
            dataList.clear();
            for (County county : countyList) {
                dataList.add(county.getCountyName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_COUNTY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            int cityCode = selectedCity.getCityCode();
            String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode;
            queryFromServer(address, "county");
        }
    }

    /*** 根据传入的地址和类型从服务器上查询省市县数据 */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    private void queryFromServer(String address,final String type){
        //未查出之前显示出进度条框
        showProgressDialog();
        //Log.d(TAG,"发送之前");
        HttpUtil.sendOkHttpRequest(address, new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, IOException e) {
                //通过runOnUiThread回到主线程处理逻辑
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        closeProgressDialog();
                        Toast.makeText(getContext(),"加载失败",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            @Override
            public void onResponse(okhttp3.Call call, Response response) throws IOException {
                String responseText = response.body().string();
                boolean result = false;
                if(type.equals("province")){
                    result = Utility.handleProvinceResponse(responseText);
                }else if(type.equals("city")){
                    result = Utility.handleCityResponse(responseText,selectedProvince.getId());
                }else if(type.equals("county")){
                    result = Utility.handleCountyResponse(responseText,selectedCity.getId());
                }
                if(result){
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            closeProgressDialog();
                            if(type.equals("province")){
                                queryProvinces();
                            }else if(type.equals("city")){
                                queryCities();
                            }else if(type.equals("county")){
                                queryCounties();
                            }
                        }
                    });
                }
            }
        });
    }
    /*** 显示进度对话框 */
    private void showProgressDialog() {
        if (progressDialog == null) {
            progressDialog = new ProgressDialog(getActivity());
            progressDialog.setMessage("正在加载...");
            progressDialog.setCanceledOnTouchOutside(false);
        }
        progressDialog.show();
    }

    /*** 关闭进度对话框 */
    private void closeProgressDialog() {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }
}
~~~

# 安卓开发之路第七天（8.23）

# 安卓开发之路第八天（8.24）

# 安卓开发之路第九天（8.25）

# 安卓开发之路第十天（8.26）

# 安卓开发之路第十一天（8.27）

# 安卓开发之路第十一天（8.28）

# 安卓开发之路第十一天（8.29）

# 安卓开发之路第十一天（8.30）

# 安卓开发之路第十一天（8.31）

# 安卓开发之路第十一天（9.1）

##### 1. 学习安卓 https://github.com/linsir6/AndroidNote