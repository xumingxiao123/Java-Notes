[TOC]

# 规划（一个月内）

#### 1. 看什么？

* 《第一行代码》

* github上的开源项目（**5个**）

#### 2. 做什么？

* 自己做两个项目并上架谷歌商城
  * 类似于githu提交记录去制作一个手机使用时间的说明，分为轻度，中度，重度

#### 3. 其他？

* 阅读java全部源码（领悟设计模式，代码规范，实现思想）
* 玩转字节码和虚拟机
* 深入操作系统层面
* 编程：每天2题及以上
* 专业课不能忘！

| 日期 | 书籍                   | 看项目      | 做项目 | Java | 编程       |
| ---- | ---------------------- | ----------- | ------ | ---- | ---------- |
| 8.16 | 《第一行代码》p0-82    |             |        |      |            |
| 8.17 | 《第一行代码》p82-111  |             |        |      |            |
| 8.18 | 《第一行代码》p111-243 |             |        |      | 二叉搜索树 |
| 8.19 | 《第一行代码》p243-400 |             |        |      |            |
| 8.20 | 《第一行代码》p400-600 |             |        |      |            |
| 8.21 |                        | 天气预报App |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |

# 问题总结（10大问题）

## 【Activity专题】

##### [1] Activity是什么？

我们都知道android中有四大组件（Activity 活动，Service 服务，Content Provider 内容提供者，BroadcastReceiver 广播接收器），Activity是我们用的最多也是最基本的组件，因为应用的所有操作都与用户相关，Activity 提供窗口来和用户进行交互。

官方文档这么说： 　　

> An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).
>
> 大概的意思：

> activity是独立平等的，用来处理用户操作。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，开发者可以通过setContentView(View)的接口把UI放到给窗口上。

　　Android中的activity全都归属于task管理 。task 是多个 activity 的集合，这些 activity 按照启动顺序排队存入一个栈（即“back stack”）。android默认会为每个App维持一个task来存放该app的所有activity，task的默认name为该app的packagename。

　　当然我们也可以在AndroidMainfest.xml中申明activity的taskAffinity属性来自定义task，但不建议使用，如果其他app也申明相同的task，它就有可能启动到你的activity，带来各种安全问题（比如拿到你的Intent）。

##### [2] Activity的生命周期

　　上面已经说了，系统通过堆栈来管理activity，当一个新的activity开始时，它被放置在堆栈的顶部和成为运行活动，以前的activity始终保持低于它在堆栈，而不会再次到达前台，直到新的活动退出。

还是上这张官网的activity_lifecycle图： 　　[![这里写图片描述](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)　

1. 首先打开一个新的activity实例的时候，系统会依次调用

> onCreate（）  -> onStart() -> onResume() 然后开始running

2. running的时候被覆盖了（从它打开了新的activity或是被锁屏，但是它**依然在前台**运行， lost focus but is still visible），系统调用onPause();

> 　该方法执行activity暂停，通常用于提交未保存的更改到持久化数据，停止动画和其他的东西。但这个activity还是完全活着（它保持所有的状态和成员信息，并保持连接到**窗口管理器**）

3. 接下来它有三条出路：

 ①用户返回到该activity就调用onResume()方法重新running

 ②用户回到桌面或是打开其他activity，就会调用onStop()进入停止状态（保留所有的状态和成员信息，**对用户不可见**）

 ③系统内存不足，拥有更高限权的应用需要内存，那么该activity的进程就可能会被系统回收。（回收onRause()和onStop()状态的activity进程）要想重新打开就必须重新创建一遍。

4. 如果用户返回到onStop()状态的activity（又显示在前台了），系统会调用

> onRestart() ->  onStart() -> onResume() 然后重新running

5. 在activity结束（调用finish ()）或是被系统杀死之前会调用onDestroy()方法释放所有占用的资源。

> activity生命周期中三个嵌套的循环

- activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。　
- activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。　
- activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。 因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，**这两个方法中的代码应该相当地轻量化**。

##### [3] activity被回收的状态和信息保存和恢复过程

```java
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
   @Override
protected void onSaveInstanceState(Bundle outState) {
	// TODO Auto-generated method stub
	 //可能被回收内存前保存状态和信息，
	   Bundle data = new Bundle(); 
	   data.putString("key", "last words before be kill");
	   outState.putAll(data);
	super.onSaveInstanceState(outState);
}
   @Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
	// TODO Auto-generated method stub
	   if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
	super.onRestoreInstanceState(savedInstanceState);
}
}
```

**onSaveInstanceState方法**

　　在activity　可能被回收之前　调用,用来保存自己的状态和信息，以便回收后重建时恢复数据（在onCreate()或onRestoreInstanceState()中恢复）。旋转屏幕重建activity会调用该方法，但其他情况在onRause()和onStop()状态的activity不一定会调用 ，下面是该方法的文档说明。

> One example of when onPause and onStop is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause is called and not onSaveInstanceState is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact.

也就是说，系统灵活的来决定调不调用该方法，**但是如果要调用就一定发生在onStop方法之前，但并不保证发生在onPause的前面还是后面。**

**onRestoreInstanceState方法**

　　这个方法在onStart 和 onPostCreate之间调用，在onCreate中也可以状态恢复，但有时候需要所有布局初始化完成后再恢复状态。

　　onPostCreate：一般不实现这个方法，当程序的代码开始运行时，它调用系统做最后的初始化工作。

##### [4] activity启动模式

**启动模式什么？**简单的说就是定义activity 实例与task 的关联方式。 　　

**为什么要定义启动模式？**

　　 为了实现一些默认启动（standard）模式之外的需求： 　　

- 让某个 activity 启动一个新的 task （而不是被放入当前 task ）
- 让 activity 启动时只是调出已有的某个实例（而不是在 back stack 顶创建一个新的实例）　
- 或者，你想在用户离开 task 时只保留根 activity，而 back stack 中的其它 activity 都要清空

**怎样定义启动模式？**

　　定义启动模式的方法有两种：

**使用 manifest 文件**

　　在 manifest 文件中activity声明时，利用 activity 元素的 launchMode 属性来设定 activity 与 task 的关系。

```
 <activity
            ．．．．．．
            android:launchMode="standard"
             >
           ．．．．．．．
        </activity>
```

> 注意： 你用 launchMode 属性为 activity 设置的模式可以被启动 activity 的 intent 标志所覆盖。

**有哪些启动模式？**

- **"standard"** （默认模式）　

　　当通过这种模式来启动Activity时,　Android总会为目标 Activity创建一个新的实例,并将该Activity添加到当前Task栈中。这种方式不会启动新的Task,只是将新的 Activity添加到原有的Task中。　 　　

- **"singleTop"**　

　　该模式和standard模式基本一致,但有一点不同: 当将要被启动的Activity已经位于Task栈顶时,系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- **"singleTask"**

　　Activity在同一个Task内只有一个实例。如果将要启动的Activity不存在,那么系统将会创建该实例,并将其加入Task栈顶；　

　　如果将要启动的Activity已存在,且存在栈顶,直接复用Task栈顶的Activity。　

　　如果Activity存在但是没有位于栈顶,那么此时系统会把位于该Activity上面的所有其他Activity全部移出Task,从而使得该目标Activity位于栈顶。

- **"singleInstance"**　

　　无论从哪个Task中启动目标Activity,只会创建一个目标Activity实例且会用一个全新的Task栈来装载该Activity实例（全局单例）.

　　如果将要启动的Activity不存在,那么系统将会先创建一个全新的Task,再创建目标Activity实例并将该Activity实例放入此全新的Task中。

　　如果将要启动的Activity已存在,那么无论它位于哪个应用程序,哪个Task中;系统都会把该Activity所在的Task转到前台,从而使该Activity显示出来。

**使用 Intent 标志**

　　在要启动 activity 时，你可以在传给 startActivity() 的 **intent** 中包含相应标志，以修改 **activity 与 task** 的默认关系。

```java
　　　　　Intent i = new Intent(this,ＮewActivity.class);
		i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		startActivity(i);
```

**可以通过标志修改的默认模式有哪些？**

- FLAG_ACTIVITY_NEW_TASK

　　与"singleTask"模式相同，在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台。

- FLAG_ACTIVITY_SINGLE_TOP

　　与 "singleTop"模式相同，如果要启动的 activity位于back stack 顶，系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- FLAG_ACTIVITY_CLEAR_TOP

　　**此种模式在launchMode中没有对应的属性值。**如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁。

**关于启动模式的一些建议**

　　 一般不要改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持谨慎，并确保 activity 在启动和从其它 activity 返回时的可用性，多做测试和安全方面的工作。

##### [5] Intent Filter

　　android的3个核心组件——Activity、services、广播接收器——是通过intent传递消息的。intent消息用于在运行时绑定不同的组件。在 Android 的 AndroidManifest.xml 配置文件中可以通过 intent-filter 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。

**intent-filter 的三大属性**

**Action**

　　一个 Intent Filter 可以包含多个 Action，Action 列表用于标示 Activity 所能接受的“动作”，它是一个用户自定义的字符串。

```
<intent-filter > 
 <action android:name="android.intent.action.MAIN" /> 
 <action android:name="com.scu.amazing7Action" /> 
……
 </intent-filter>
```

在代码中使用以下语句便可以启动该Intent 对象：

```
Intent i=new Intent(); 
i.setAction("com.scu.amazing7Action");
```

Action 列表中包含了“com.scu.amazing7Action”的 Activity 都将会匹配成功

**URL**

　　在 intent-filter 节点中，通过 data节点匹配外部数据，也就是通过 URI 携带外部数据给目标组件。

```
<data android:mimeType="mimeType" 
	android:scheme="scheme" 
	 android:host="host"
	 android:port="port" 
	 android:path="path"/>
```

注意：只有data的所有的属性都匹配成功时 URI 数据匹配才会成功

**Category**

　　为组件定义一个 类别列表，当 Intent 中包含这个类别列表的所有项目时才会匹配成功。

```
<intent-filter . . . >
   <action android:name="code android.intent.action.MAIN" />
   <category android:name="code　android.intent.category.LAUNCHER" />
</intent-filter>
```

**Activity 中 Intent Filter 的匹配过程**

① 加载所有的Intent Filter列表 　　

② 去掉action匹配失败的Intent Filter 　　

③ 去掉url匹配失败的Intent Filter 　

④ 去掉Category匹配失败的Intent Filter 　

⑤ 判断剩下的Intent Filter数目是否为0。如果为0查找失败返回异常；如果大于0，就按优先级排序，返回最高优先级的Intent Filter

##### [6] 开发中Activity的一些问题

一般设置Activity为非公开的

```java
<activity  
．．．．．． 
android:exported="false" /> 
```

注意：非公开的Activity不能设置intent-filter，以免被其他activity唤醒（如果拥有相同的intent-filter）。

- 不要指定activity的taskAffinity属性
- 不要设置activity的LaunchMode（保持默认）

　　注意Activity的intent最好也不要设定为FLAG_ACTIVITY_NEW_TASK

- 在匿名内部类中使用this时加上activity类名（类名.this,不一定是当前activity）
- 设置activity全屏

　　在其 onCreate()方法中加入：

```java
// 设置全屏模式
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 
 // 去除标题栏
 requestWindowFeature(Window.FEATURE_NO_TITLE);
```

## 【Service详细解析】

##### [1] 什么是服务？　　

　　Service是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与content provider进行交互，所有这些都是后台进行的。

##### [2] Service 与Thread的区别

　　服务仅仅是一个组件，即使用户不再与你的应用程序发生交互，它仍然能在后台运行。因此，应该只在需要时才创建一个服务。

　　如果你需要在主线程之外执行一些工作，但仅当用户与你的应用程序交互时才会用到，那你应该创建一个新的线程而不是创建服务。 比如，如果你需要播放一些音乐，但只是当你的activity在运行时才需要播放，你可以在onCreate()中创建一个线程，在onStart()中开始运行，然后在onStop()中终止运行。还可以考虑使用AsyncTask或HandlerThread来取代传统的Thread类。

　　**由于无法在不同的 Activity 中对同一 Thread 进行控制**，这个时候就要考虑用服务实现。如果你使用了服务，它默认就运行于应用程序的主线程中。因此，如果服务执行密集计算或者阻塞操作，你仍然应该在服务中创建一个新的线程来完成（避免ANR）。

##### [3] 服务的分类

**1. 按运行分类**

- 前台服务

　　前台服务是指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，并会置于“正在进行的”（“Ongoing”）组之下。这意味着只有在服务被终止或从前台移除之后，此通知才能被解除。 　　例如，用服务来播放音乐的播放器就应该运行在前台，因为用户会清楚地知晓它的运行情况。 状态栏通知可能会标明当前播放的歌曲，并允许用户启动一个activity来与播放器进行交互。

　　要把你的服务请求为前台运行，可以调用startForeground()方法。此方法有两个参数：唯一标识通知的整数值、状态栏通知Notification对象。例如：

```java
Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());

Intent notificationIntent = new Intent(this,ExampleActivity.class);

PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);

notification.setLatestEventInfo(this, getText(R.string.notification_title),
        getText(R.string.notification_message), pendingIntent);
        
startForeground(ONGOING_NOTIFICATION, notification);
```

　　要从前台移除服务，请调用stopForeground()方法，这个方法接受个布尔参数，表示是否同时移除状态栏通知。此方法不会终止服务。不过，如果服务在前台运行时被你终止了，那么通知也会同时被移除。

- 后台服务

**2. 按使用分类**　　

- 本地服务

　　用于应用程序内部，实现一些耗时任务，并不占用应用程序比如Activity所属线程，而是单开线程后台执行。 　　调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。

- 远程服务

　　用于Android系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用 Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。

##### [4] Service生命周期

　                                   ![img](https://upload-images.jianshu.io/upload_images/4625401-84380bfeb9c4b0ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



【链接：https://www.jianshu.com/p/cc25fbb5c0b3】

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200901224652977.png" alt="image-20200901224652977" style="zoom:80%;" />



**Service生命周期方法：**

```java
public class ExampleService extends Service {
    int mStartMode;       // 标识服务被杀死后的处理方式
    IBinder mBinder;      // 用于客户端绑定的接口
    boolean mAllowRebind; // 标识是否使用onRebind

    @Override
    public void onCreate() {
        // 服务正被创建
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // 服务正在启动，由startService()调用引发
        return mStartMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // 客户端用bindService()绑定服务
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        // 所有的客户端都用unbindService()解除了绑定
        return mAllowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        // 某客户端正用bindService()绑定到服务,
        // 而onUnbind()已经被调用过了
    }
    @Override
    public void onDestroy() {
        // 服务用不上了，将被销毁
    }
}
```

> 请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行。onStartCommand()的返回值必须是以下常量之一：

> START_NOT_STICKY 　 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。　 　 START_STICKY 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。　

> START_REDELIVER_INTENT 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。

　　服务的生命周期与activity的非常类似。不过，更重要的是你需密切关注服务的创建和销毁环节，因为后台运行的服务是不会引起用户注意的。

　　服务的生命周期——从创建到销毁——可以有两种路径：

- **一个started服务**

　　这类服务由其它组件调用startService()来创建。然后保持运行，且必须通过调用stopSelf()自行终止。其它组件也可通过调用stopService() 终止这类服务。服务终止后，系统会把它销毁。

　　如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且系统只会创建Service的一个实例（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。

- **一个bound服务**

　　服务由其它组件（客户端）调用bindService()来创建。然后客户端通过一个IBinder接口与服务进行通信。客户端可以通过调用unbindService()来关闭联接。多个客户端可以绑定到同一个服务上，当所有的客户端都解除绑定后，系统会销毁服务。（服务不需要自行终止。）

　　如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。

![img](https://upload-images.jianshu.io/upload_images/4625401-756d89b600d55081.png?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

　　这两条路径并不是完全隔离的。也就是说，你可以绑定到一个已经用startService()启动的服务上。例如，一个后台音乐服务可以通过调用startService()来启动，传入一个指明所需播放音乐的 Intent。 之后，用户也许需要用播放器进行一些控制，或者需要查看当前歌曲的信息，这时一个activity可以通过调用bindService()与此服务绑定。在类似这种情况下，stopService()或stopSelf()不会真的终止服务，除非所有的客户端都解除了绑定。

> 　　当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。

**在manifest中声明服务**

　　无论是什么类型的服务都必须在manifest中申明，格式如下：

```
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```

Service 元素的属性有：

> android:name　　-------------　　服务类名

> android:label　　--------------　　服务的名字，如果此项不设置，那么默认显示的服务名则为类名

> android:icon　　--------------　　服务的图标

> android:permission　　-------　　申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务

> android:process　　----------　　表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字

> android:enabled　　----------　　如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false

> android:exported　　---------　　表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false　

　　android:name是唯一必需的属性——它定义了服务的类名。与activity一样，服务可以定义intent过滤器，使得其它组件能用隐式intent来调用服务。如果你想让服务只能内部使用（其它应用程序无法调用），那么就不必（也不应该）提供任何intent过滤器。 　　此外，如果包含了android:exported属性并且设置为"false"， 就可以确保该服务是你应用程序的私有服务。即使服务提供了intent过滤器，本属性依然生效。　

**startService 启动服务**

　　从activity或其它应用程序组件中可以启动一个服务，调用startService()并传入一个Intent（指定所需启动的服务）即可。

```
	Intent intent = new Intent(this, MyService.class);
	startService(intent);
```

服务类：

```
public class MyService extends Service {

	  /**
     * onBind 是 Service 的虚方法，因此我们不得不实现它。
     * 返回 null，表示客服端不能建立到此服务的连接。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return null;
	}
    
	@Override
    public void onCreate() {
        super.onCreate();
    }
     
    @Override
 public int onStartCommand(Intent intent, int flags, int startId)  　　 {  	
    //接受传递过来的intent的数据 
     return START_STICKY; 
    };
     
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
	
}
```

　　一个started服务必须自行管理生命周期。也就是说，系统不会终止或销毁这类服务，除非必须恢复系统内存并且服务返回后一直维持运行。 因此，服务必须通过调用stopSelf()自行终止，或者其它组件可通过调用stopService()来终止它。

**bindService 启动服务**　　

　　当应用程序中的activity或其它组件需要与服务进行交互，或者应用程序的某些功能需要暴露给其它应用程序时，你应该创建一个bound服务，并通过进程间通信（IPC）来完成。

方法如下：

```
 Intent intent=new Intent(this,BindService.class); 
 bindService(intent, ServiceConnection conn, int flags)  
```

> 注意bindService是Context中的方法，当没有Context时传入即可。

在进行服务绑定的时，其flags有：

- Context.BIND_AUTO_CREATE

　　表示收到绑定请求的时候，如果服务尚未创建，则即刻创建，在系统内存不足需要先摧毁优先级组件来释放内存，且只有驻留该服务的进程成为被摧毁对象时，服务才被摧毁　

- Context.BIND_DEBUG_UNBIND    　

　　通常用于调试场景中判断绑定的服务是否正确，但容易引起内存泄漏，因此非调试目的的时候不建议使用

- Context.BIND_NOT_FOREGROUND    　

　　表示系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行。

服务类：

```
public class BindService extends Service {

	 // 实例化MyBinder得到mybinder对象；
	private final MyBinder binder = new MyBinder();
	
	  /**
     * 返回Binder对象。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return binder;
	}
    
     /**
      * 新建内部类MyBinder，继承自Binder(Binder实现IBinder接口),
      * MyBinder提供方法返回BindService实例。
      */
　　public class MyBinder extends Binder{
        
        public BindService getService(){
            return BindService.this;
        }
    }
     

	@Override
	public boolean onUnbind(Intent intent) {
		// TODO Auto-generated method stub
		return super.onUnbind(intent);
	}
}
```

启动服务的activity代码：

```
public class MainActivity extends Activity {

	/** 是否绑定 */  
	boolean mIsBound = false; 
	BindService mBoundService;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		doBindService();
	}
	/**
	 * 实例化ServiceConnection接口的实现类,用于监听服务的状态
	 */
	private ServiceConnection conn = new ServiceConnection() {  
		  
	    @Override  
	    public void onServiceConnected(ComponentName name, IBinder service) {  
	        BindService mBoundService = ((BindService.MyBinder) service).getService();  
	        
	    }  
	  
	    @Override  
	    public void onServiceDisconnected(ComponentName name) {  
	        mBoundService = null;  
	     
	    }  
	}; 
	
	/** 绑定服务 */  
	public void doBindService() {  
	    bindService(new Intent(MainActivity.this, BindService.class), conn,Context.BIND_AUTO_CREATE);  
	    mIsBound = true;  
	}  
	
	/** 解除绑定服务 */  
	public void doUnbindService() {  
	    if (mIsBound) {  
	        // Detach our existing connection.  
	        unbindService(conn);  
	        mIsBound = false;  
	    }  
	} 
	
	@Override
	protected void onDestroy() {
		// TODO Auto-generated method stub
		super.onDestroy();
		
		doUnbindService();
	}
}
```

> 注意在AndroidMainfest.xml中对Service进行显式声明

判断Service是否正在运行：

```
private boolean isServiceRunning() {
    ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    
 　{
        if ("com.example.demo.BindService".equals(service.service.getClassName())) 　　{
            return true;
        }
    }
    return false;
}
```

# 安卓开发之路第一天（8.16）

### 事件1：阅读《第一行代码》P1-82

#### 第一章：第一行代码

##### 1.  安卓的发展

##### 2. 搭建开发环境

模拟器选择：**pixel**

##### 3. 创建第一个安卓开发环境

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817092618656.png" alt="image-20200817092618656" style="zoom:50%;" />

##### 4.详解安卓开发目录结构

* **grable是什么？**

Gradle 是一个基于 [Apache Ant](https://www.oschina.net/p/apache+ant) 和 [Apache Maven](https://www.oschina.net/p/maven) 概念的项目自动化构建工具，支持依赖管理和多项目，类似 [Maven](https://www.oschina.net/p/maven)，但比之简单轻便。它使用一种基于 [Groovy](https://www.oschina.net/p/groovy) 的特定领域语言来声明项目设置，而不是传统的 XML。

当前其支持的语言限于 Java、Groovy 和 Scala，计划未来将支持更多的语言。

1. **project目录**

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817100902922.png" alt="image-20200817100902922" style="zoom:80%;" />

2. **app目录**



<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817101447841.png" alt="image-20200817101447841" style="zoom:80%;" />

3. **AndroidManifest**

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myfistapp">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

4. **Manifest**

```java
package com.example.myfistapp;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
//AppCompatActivity向下兼容的Activity
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //视图和逻辑分离，所以没有helloword
        super.onCreate(savedInstanceState);
        //引入了一个ContentView布局
        setContentView(R.layout.activity_main);
    }
}
```

5. **R.layout.activity_main**

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />


</androidx.constraintlayout.widget.ConstraintLayout>
~~~

6. **如何引用？**

代码中：R.layout.activity_main

XML中：android:icon="@mipmap/ic_launcher"

7.  外层grable

```java
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    //代码仓库
    repositories {
        google()
        jcenter()
    }
    //
    dependencies {
        classpath "com.android.tools.build:gradle:4.0.1"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories 
        //两个插件
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁.

8. 内层grable

~~~java
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.example.myfistapp"
        minSdkVersion 15
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'

}
~~~

##### 5. 掌握日志工具的使用

专业的！

* 日志开关可控制
* 可添加日志标签
* 日志级别可以区分

#### 第二章：快速入门Kotlin

##### 1.  语言简洁

##### 2  变量

自动转型：

val：对应final变量

var：对应final常量

##### 3.  函数

fun，单行代码可不加{}

##### 4.  逻辑控制语句（if  when for）

if：有返回值，每个条件中最后一行代码的返回值

when：有返回值，可以用->，**判断对象相等可以直接用==，判断引用相等===**

while和for：for-in,并且可以用until跳出区间

##### 5.  类

**类**：class

**方法**：fun

##### 6.  继承与构造函数

**继承**：默认不可被继承，加上open才可以

**构造函数：**这里比较复杂

##### 7.  接口

继承： **：**

实现： **，**

访问修饰符：Kotiln默认是public，另外还有internal关键字

##### 8. 数据类与单例类

class->object

##### 9. Lambda编程

**集合创建（更简洁）和遍历（for-in）！**

**集合的函数式API**：求一个集合里面的最大值，直接list.maxBy

**java函数API**

##### 10. 空指针检查

空指针异常解决：编译时期会直接报错

**？.**  可为空

**？：** 类似于java中的？：

##### 11.小魔术

**字符串内嵌表达式** 

**给参数的默认值**

# 安卓开发之路第二天（8.17）

#### 事件1： 复习+连接到手机

https://www.cnblogs.com/oreox/p/10662066.html

#### 事件2： 学习activty

##### 1. 编写按钮

~~~java
    <Button
        android:id="@+id/button" //定义一个唯一id
        android:layout_width="match_parent" //定义宽度，匹配父元素
        android:layout_height="wrap_content" //定义高度，刚好包含里面的内容wrap_content
        android:text="Button" /> //显示内容
~~~

##### 2. activity调用

~~~java
package com.example.mysecendacticity;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class FristActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //调用父类默认实现
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
    }
}
~~~

##### 3. andoridMainActivity

~~~java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.mysecendacticity">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".FristActivity"
            android:label="This is FristActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            </activity>
    </application>

</manifest>
~~~

##### 4. **toast**

```java
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
        Button button1=(Button) findViewById(R.id.button1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); }
        });
    }
}
```

##### 5.**菜单**

~~~java
    @Override
    //菜单可见
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
    @Override
    //菜单响应时间
    public boolean onOptionsItemSelected(MenuItem item) {
        //使用item.getItemId()判断使用哪个菜单项
        switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
            default:
        }
        return true;
    }
}
~~~

##### 6.**intent**

~~~java
//显示       
button1.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        //第一个参数Context 要求提供一个启动活动的上下文， 第二个参数Class 则是指定想要启动的目标活动
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                        startActivity(intent);
                    }
        });

    }
~~~

~~~xml
//隐式  

<activity android:name=".SecondActivity">
            <intent-filter> 
                <action android:name="com.example.activitytest.ACTION_START" /> 
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity
~~~

在<action> 标签中我们指明了当前活动可以响应 **com.example.activitytest.ACTION_START** 这个action ，而<category> 标签则包含 了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的**category** 。只 有<action> 和<category> 中的内容同时能够匹配上Intent中指定的**action** 和**category** 

时，这个活动才能响应该**Intent**。 

##### 7.[Intent的常用属性action和category](https://www.cnblogs.com/z-cg/p/12356168.html)

**设置隐式跳转时**，首先在我们按钮监听器中添加

```java
Intent i=new Intent();
//参数为字符串，可以添加包名.活动名
i.setAction("com.example.aaaaa.testliandong.MainActivity");
startActivity(i);
```

只是这样还不够，必须得在AndroidMainfest.xml文件中添加如下代码

```xml
 <activity android:name=".NewActivity">
             <intent-filter>
                 <action android:name="com.example.aaaaa.testliandong.MainActivity"/>
                 <category android:name="android.intent.category.DEFAULT"/>
             </intent-filter>
        </activity>
```

其中第一行和活动的声明一样，intent-filter标签中的action中name的值为和之前在Java中setAction的参数一样，category中的name值为android.intent.category.DEFAULT，DEFAULT则表示跳转为隐式跳转

可以看到，我们使用了Intent的另一个构造函数，直接将action 的字符串传了进去，表明我们 

想要启动能够响应com.example.activitytest.ACTION_START 这个action 的活动。那 前面不是说要<action> 和<category> 同时匹配上才能响应的吗？**怎么没看到哪里有指定 category 呢？**这是因为android.intent.category.DEFAULT 是一种默认的category ，在调用startActivity() 方法的时候会自动将这个category 添加到Intent中。 

##### 8.**Activity的Action(单个)和category（多个）属性**

https://blog.csdn.net/itszt888/article/details/76074243

介绍Action和Category的关系 
举一个例子,一个女孩子找男朋友,她有一些要求：男性、高、富、帅。 
男性相当于`Action`,`Action`这能有一个 
高富帅相当于`Category`,`Category`可以有很多 
而一个男性有很多特点,满足了很多女孩系择偶的标准,用如下图表示

![这里写图片描述](https://img-blog.csdn.net/20170725152114852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRzenQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

~~~java
//今天看了Activity，来跟大家分享一下它的Action属性和category属性
//下面页面为第一个页面，页面只有一个跳转按钮，此处不再给出页面布局
package a.a;

import android.app.Activity;
import android.os.Bundle;
import android.widget.*;
import android.view.*;
import android.view.View.OnClickListener;
import android.content.*;
public class Er extends Activity 
{
   private Button jump;
   private static final String MY_ACTION = "ery.src.a.a.MY_ACTION";
   private static final String MY_CATEGORY = "ery.src.a.a.MY_CATEGORY";
   public void onCreate(Bundle savedInstanceState) 
  {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.main);
       jump = (Button)findViewById(R.id.jump);
       jump.setOnClickListener(new OnClickListener()
       {
           public void onClick(View v)
           {
               //此处为intent添加了一个自定义action和一个自定义category属性，因此配置被启                        //动Activity在注册表androidmanifest.xml文件中要包括这样的两行配置:
               //<action android:name="ery.src.a.a.MY_ACTION" />和
               //<category android:name="ery.src.a.a.MY_CATEGORY" />，然而每一个Intent还                          //有一个默认的category，所以这个默认的也得注册，为:
               //<category android:name="android.intent.category.DEFAULT" />
               //总之归结起来，注册表中的Activity要想启动，必须包含对应Intent的Action属性
               //和Intent的所有category属性。(附：一个Intent只能有一个acton，但可以添加多                        //个category)
               Intent  intent = new Intent();
               intent.setAction(MY_ACTION);
               intent.addCategory(MY_CATEGORY);
                Er.this.startActivity(intent);
            }
        });
   }
}
//第二个页面，只有一个TextView，在此不再给出布局文件
package a.a;
import android.app.*;
import android.os.Bundle;
public class Second extends Activity
{
    protected void onCreate(Bundle savedInstanceState) 
    {
       super.onCreate(savedInstanceState);
       super.setContentView(R.layout.second);
    }
}
~~~

~~~xml

//AnaroidManifest.xml文件
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="a.a"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="15" />

    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <activity
            android:label="@string/app_name"
            android:name=".Er" >
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".Second"
            android:theme="@android:style/Theme.Dialog" 
            >
            <intent-filter>
                <action android:name="ery.src.a.a.MY_ACTION" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="ery.src.a.a.MY_CATEGORY" />
                <category android:name="saer"/>
            </intent-filter>
        </activity>
    </application>

</manifest>

~~~

##### 9. 更多隐式**Intent**的用法 

使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得 Android多个应用程序之间的功能共享成为了可能。比如说你的应用程序中需要展示一个网页， 这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器 来打开这个网页就行了。

~~~xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <action android:name="com.example.activitytest.ACTION_START" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="com.example.activitytest.MY_CATEGORY" />
            </intent-filter>
        </activity>
        <activity
~~~



我们在ThirdActivity的<intent-filter> 中配置了当前活动能够响应的action 

是Intent.ACTION_VIEW 的常量值，而category 则毫无疑问指定了默认的category 值， 

另外在<data> 标签中我们通过android:scheme 指定了数据的协议必须是http协议，这样 

ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。



~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                //常量值
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~



 我们还可以在<intent-filter> 标签中再配置一个<data> 标签，用于**更精确地** 

**指定当前活动能够响应什么类型的数据**。<data> 标签中主要可以配置以下内容。 

android:scheme 。用于指定数据的协议部分，如上例中的http部分。 

android:host 。用于指定数据的主机名部分，如上例中的www.baidu.com部分。 

android:port 。用于指定数据的端口部分，一般紧随在主机名之后。 

android:path 。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内 

容。

android:mimeType 。用于指定可以处理的数据类型，允许使用通配符的方式进行指 

定。 

只有<data> 标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该 

Intent。不过一般在<data> 标签中都不会指定过多的内容，如上面浏览器示例中，其实**只需要** 

**指定android:scheme 为http，就可以响应所有的http协议的Intent了。** 

为了让你能够更加直观地理解，我们来自己建立一个活动，让它也能响应打开网页的Intent。

~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~

##### 10.  向下一个activity传输数据

~~~java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            //Intent中提供了一系列putExtra() 方法的重载，可以把 我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出 就可以了
            public void onClick(View v) {
                String data = "Hello SecondActivity";
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                intent.putExtra("extra_data", data);
                startActivity(intent);
            }
        });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.second_layout);
            Intent intent = getIntent();
            String data = ((Intent) intent).getStringExtra("extra_data");
            Log.d("SecondActivity", data); }
~~~

##### 11. 返回数据给上一个活动 

既然可以传递数据给下一个活动，那么能不能够返回数据给上一个活动呢？答案是肯定的。不 过不同的是，返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动的Intent 来传递数据。通过查阅文档你会发现，Activity中还有一个**startActivityForResult() 方 法**也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 毫无疑问，这就是我们所需要的。 

startActivityForResult() 方法接收两个参数，第一个参数还是Intent，第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改FirstActivity中按钮的 点击事件，代码如下所示： 

~~~java
        button1.setOnClickListener(
                new View.OnClickListener() { 
                    @Override 
                    public void onClick(View v) { 
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class); 
                        startActivityForResult(intent, 1); } 
                });
~~~

# 安卓开发之路第三天（8.18）

# 安卓开发之路第四天（8.19）

# 安卓开发之路第五天（8.20）

# 安卓开发之路第六天（8.21）

### 天气预报App

#### 1. 需求分析

**酷欧天气中至少应该具备以下功能：**

1. 可以罗列出全国所有的省、市、县； 

2. 可以查看全国任意城市的天气信息； 

3. 可以自由地切换城市，去查看其他城市的天气； 

4. 提供手动更新以及后台自动更新天气的功能。

#### 2. 技术可行性分析（彩云天气）

我们 如何才能得到全国省市县的数据信息，以及如何才能获取到每个城市的天气信息。比较遗憾的 是，现在网上免费的天气预报接口已经越来越少，很多之前可以使用的接口都慢慢关闭掉了， 包括本书第1版中使用的中国天气网的接口。因此，这次我也是特意用心去找了一些更加稳定的 天气预报服务，比如彩云天气以及和风天气都非常不错。这两个天气预报服务虽说都是收费 的，但它们每天都提供了一定次数的免费天气预报请求。其中彩云天气的数据更加实时和专 业，可以将天气预报精确到分钟级，每天提供1000次免费请求；和风天气的数据相对简单一 些，比较适合新手学习，每天提供3000次免费请求。那么简单起见，这里我们就使用和风天气 来作为天气预报的数据来源，每天3000次的免费请求对于学习而言已经是相当充足了。

>https://id.heweather.com/#/login?redirect=https%3A%2F%2Fconsole.heweather.com%2F%23%2Fconsole

#### 3.  Gitee托管

https://gitee.com/xumingxiao/Sunny-Weather

#### 4.  搭建MVVM项目架构

#### 5 创建数据库和表

~~~java
dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
    //添加依赖项,使用LitePal对数据库进行操作
    implementation 'org.litepal.android:java:3.0.0'
}
~~~

~~~java
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'androidx.appcompat:appcompat:1.3.0-alpha01'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.3.0-rc03'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0-alpha4'
    //
    implementation 'org.litepal.android:java:3.0.0'
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
    implementation 'com.squareup.retrofit2:converter-scalars:2.5.0'
    implementation 'com.github.bumptech.glide:glide:3.7.0'
    def lifecycle_version = "2.0.0"
    // ViewModel and LiveData
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
}
~~~

#### 6 LitePal

https://www.jianshu.com/p/9d0d00b69fe8

https://www.jianshu.com/p/6d3a0f87d637

**学习文档：**

https://github.com/guolindev/LitePal

#### 7 为什么需要实体类

最近因为学习三层架构中的实体类，引发不少问题，下面具体说下三层中的实体类，即数据库表的映射

**为何使用实体类？**

数据库中，DatsSet 不具备OO的优点， 实现数据检索繁琐，易出错， 使数据结构暴露在业务逻辑层和表现层

> “OO，它是英文词组Object Oriented的缩写，它的意思是面向对象

为了消除以上局限我们使用实体类:

![img](https:////upload-images.jianshu.io/upload_images/6923303-2ec385d83393a914.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)



**举例说明**

用实体类之后，代码时变得简介，面向对象**封装**思想，最重要的是，**如果将来有所改动，只需要改动实体类， 方法间调用接口，完全不需要变动，大大减少了程序修改量，迎合了面向对象中接口不变的思想。**

甚至在程序设计时，就把将来可能需要的属性预先放在实体类中，这样以后变动时，连实体类都不用变动了

实体类在三层结构中的主要作用是什么？

Using 语句的主要作用是什么？

**为什么需要实体类？**

 从OOP细想考虑

 它是完全受控制的对象

 它具有面向对象的基本特征

 可以自定义行为

消除了关系数据和对象之间的差异

**为我们在关系数据库和对象之间架起了一座桥梁**

**什么是实体类？**

 **简单的说就是描述一个业务实体的类， 例如： 管理员的信息**

![img](https:////upload-images.jianshu.io/upload_images/6923303-e26ae89a463c6480.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)



**下面几个问题是值得思考的**

**表示层如何使用实体类？**

**业务逻辑层如何使用实体类？**



![img](https:////upload-images.jianshu.io/upload_images/6923303-6a1d13147862af10.png?imageMogr2/auto-orient/strip|imageView2/2/w/667/format/webp)



**数据访问层如何使用实体类？**

他们之间的业务实体的依赖图为

![img](https:////upload-images.jianshu.io/upload_images/6923303-85645b9c7cfc862e.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



 其中Using 语句，用于定义一个范围，在此范围末尾将释放对象



![img](https:////upload-images.jianshu.io/upload_images/6923303-a4c0b2b7ba9ef313.png?imageMogr2/auto-orient/strip|imageView2/2/w/571/format/webp)

https://blog.csdn.net/qq_41386332/article/details/99701010

#### 8 OkHttp用法

https://www.jianshu.com/p/f5320b1e0287

https://github.com/square/okhttp

原理：https://www.jianshu.com/p/7b29b89cd7b5

#### 9. throw new RuntimeException("Stub!")

https://blog.csdn.net/anhenzhufeng/article/details/75268195

这样定义的方法，表示在程序执行的时候，实际由android rom里面相同的类来执行。

**为什么会出现这样的定义？**我猜想可能是，这个类实际只在rom里面提供，而我们有时候要用到这个类的一些方法，那么就以这种方式来提供，因为在编译期间，我们的程序要使用这个类，那必然要提供这个类的定义，不然就引用不了。

就比如在看滴滴的插件化开源软件[VirtualAPK](https://github.com/didi/VirtualAPK) 的时候，在hack AMS服务的时候，需要用到ActivityManagerNative这个类，而这个类我们知道在api里面没有提供，是在framework里面提供的。那么要想引入这个类，要么就是编译一个framework.jar包，工程引用这个jar包，但是这样有个问题，我们的应用要安装在各种版本的系统里面，每个版本的framework都是有差异的，兼容性就低了。所以这里使用了另外一种方法，在我们的工程中声明一个和framework一模一样的类，在运行的时候就能自动运行rom里面的类了。

# 安卓开发之路第六天（8.22）

#### 1 编写ChooseAreaFragment类

**ChooseAreaFragment**用于展示查询界面和实现基本查询功能，继承于**Fragment**

1. 重写**onCreateView**，获取到了一些控件的实例，然后去初始化了ArrayAdapter，并将它设置为ListView的适 配器。
2. **onActivityCreated()**，接着在onActivityCreated() 方法中给**ListView和Button**设置了点击事件，到这里我 们的初始化工作就算是完成了。在onActivityCreated() 方法的最后，调用了queryProvinces() 方法，也就是从这里开 始加载省级数据的。
   * **queryProvinces() 方法**中首先会将头布局的标题设置成中国，将返回 按钮隐藏起来，因为省级列表已经不能再返回了。然后调用LitePal的查询接口来从数据库中读 取省级数据，如果读取到了就直接将数据显示到界面上，如果没有读取到就按照14.1节讲述的接 口组装出一个请求地址，然后调用queryFromServer() 方法来从服务器上查询数据。
     * **queryFromServer() 方法**中会调用HttpUtil的sendOkHttpRequest() 方法来向服务器发送 请求，响应的数据会回调到onResponse() 方法中，然后我们在这里去调用Utility的 handleProvincesResponse() 方法来解析和处理服务器返回的数据，并存储到数据库中。 接下来的一步很关键，在解析和处理完数据之后，我们再次调用了queryProvinces() 方法 来重新加载省级数据，由于queryProvinces() 方法牵扯到了UI操作，因此必须要在主线程 中调用，这里借助了runOnUiThread() 方法来实现从子线程切换到主线程。现在数据库中已 经存在了数据，因此调用queryProvinces() 就会直接将数据显示到界面上了。
3. 当你点击了某个省的时候会进入到ListView的**onItemClick()** 方法中，这个时候会根据当前的 级别来判断是去**调用queryCities()** 方法还是queryCounties() 方法，queryCities() 方法是去查询市级数据，而**queryCounties() 方法**是去查询县级数据，这两个方法内部的流 程和queryProvinces() 方法基本相同，这里就不重复讲解了。 另外还有一点需要注意，在返回按钮的点击事件里，会对当前ListView的列表级别进行判断。如 果当前是县级列表，那么就返回到市级列表，如果当前是市级列表，那么就返回到省级表列表。当返回到省级列表时，返回按钮会自动隐藏，从而也就不需要再做进一步的处理了。 

~~~java
package com.example.sunnywheather.activity;

import android.app.ProgressDialog;
import android.os.Bundle;
import android.telecom.Call;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

import com.example.sunnywheather.R;
import com.example.sunnywheather.db.City;
import com.example.sunnywheather.db.County;
import com.example.sunnywheather.db.Province;
import com.example.sunnywheather.util.HttpUtil;
import com.example.sunnywheather.util.Utility;

import org.litepal.LitePal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.security.auth.callback.Callback;

import okhttp3.Response;
// 新建一个ChooseAreaFragment用于展示查询界面和实现基本查询功能
public class ChooseAreaFragment extends Fragment {
    public static final int LEVEL_PROVINCE = 0;
    public static final int LEVEL_CITY = 1;
    public static final int LEVEL_COUNTY = 2;
    private ProgressDialog progressDialog;
    private TextView titleText;
    private Button backButton;
    private ListView listView;
    private ArrayAdapter<String> adapter;
    private List<String> dataList = new ArrayList<>();
    /*** 省列表 */
    private List<Province> provinceList;
    /*** 市列表 */
    private List<City> cityList;
    /*** 县列表 */
    private List<County> countyList;
    /*** 选中的省份 */
    private Province selectedProvince;
    /*** 选中的城市 */
    private City selectedCity;
    /*** 当前选中的级别*/
    private int currentLevel;

    /**
     * 在onCreateView()方法中先是获取到了一些控件的实例，
     * 然后去初始化了ArrayAdapter，并将它设置为ListView的适配器。
     * 接着在onActivityCreated() 方法中给ListView和Button设置了点击事件，
     * 到这里我们的初始化工作就算是完成了
     * @param inflater
     * @param container
     * @param savedInstanceState
     * @return
     */
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

        View view = inflater.inflate(R.layout.choose_area, container, false);
        titleText = (TextView) view.findViewById(R.id.title_text);
        backButton = (Button) view.findViewById(R.id.back_button);
        listView = (ListView) view.findViewById(R.id.list_view);
        adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_list_item_1, dataList);
        listView.setAdapter(adapter);
        return view;
    }

    /**
     * 在onActivityCreated()方法中设置ListView和Button的点击事件，
     * 在这里完成了基本的初始化操作，调用queryProvinces()方法，加载省级数据
     * @param savedInstanceState
     */
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        //对列表设置监听事件
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if(currentLevel == LEVEL_PROVINCE){
                    //记住选中的省份
                    selectedProvince = provinceList.get(position);
                    //显示出省份对应下city的界面
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //记住选中的City
                    selectedCity = cityList.get(position);
                    //切换到相应的county界面
                    queryCounties();
                }
            }
        });
        //为返回按钮注册监听事件
        backButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View v){
                //若在county切换到City
                if(currentLevel == LEVEL_COUNTY){
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //若在City切换到province
                    queryProvinces();
                }
            }
        });
        //初始状态下显示province
        queryProvinces();
    }

    /*** 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryProvinces() {
        //首先将头布局的标题设为中国
        titleText.setText("中国");
        //隐藏返回按键
        backButton.setVisibility(View.GONE);
        //调用LitePal接口读取省级数据
        provinceList = LitePal.findAll(Province.class);
        //如果读取到了就直接将数据显示在桌面上
        if (provinceList.size() > 0) {
            dataList.clear();
            //遍历链表
            for (Province province : provinceList) {
                dataList.add(province.getProvinceName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_PROVINCE;
        } else {
            //否则向服务器上查询
            String address = "http://guolin.tech/api/china";
            //传入一个地址和回调函数
            queryFromServer(address, "province");
        }
    }

    /*** 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCities() {
        titleText.setText(selectedProvince.getProvinceName());
        backButton.setVisibility(View.VISIBLE);
        cityList = LitePal.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class);
        if (cityList.size() > 0) {
            dataList.clear();
            for (City city : cityList) {
                dataList.add(city.getCityName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_CITY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            String address = "http://guolin.tech/api/china/" + provinceCode;
            queryFromServer(address, "city");
        }
    }

    /*** 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCounties() {
        titleText.setText(selectedCity.getCityName());
        backButton.setVisibility(View.VISIBLE);
        countyList = LitePal.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class);
        if (countyList.size() > 0) {
            dataList.clear();
            for (County county : countyList) {
                dataList.add(county.getCountyName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_COUNTY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            int cityCode = selectedCity.getCityCode();
            String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode;
            queryFromServer(address, "county");
        }
    }

    /*** 根据传入的地址和类型从服务器上查询省市县数据 */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    private void queryFromServer(String address,final String type){
        //未查出之前显示出进度条框
        showProgressDialog();
        //Log.d(TAG,"发送之前");
        HttpUtil.sendOkHttpRequest(address, new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, IOException e) {
                //通过runOnUiThread回到主线程处理逻辑
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        closeProgressDialog();
                        Toast.makeText(getContext(),"加载失败",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            @Override
            public void onResponse(okhttp3.Call call, Response response) throws IOException {
                String responseText = response.body().string();
                boolean result = false;
                if(type.equals("province")){
                    result = Utility.handleProvinceResponse(responseText);
                }else if(type.equals("city")){
                    result = Utility.handleCityResponse(responseText,selectedProvince.getId());
                }else if(type.equals("county")){
                    result = Utility.handleCountyResponse(responseText,selectedCity.getId());
                }
                if(result){
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            closeProgressDialog();
                            if(type.equals("province")){
                                queryProvinces();
                            }else if(type.equals("city")){
                                queryCities();
                            }else if(type.equals("county")){
                                queryCounties();
                            }
                        }
                    });
                }
            }
        });
    }
    /*** 显示进度对话框 */
    private void showProgressDialog() {
        if (progressDialog == null) {
            progressDialog = new ProgressDialog(getActivity());
            progressDialog.setMessage("正在加载...");
            progressDialog.setCanceledOnTouchOutside(false);
        }
        progressDialog.show();
    }

    /*** 关闭进度对话框 */
    private void closeProgressDialog() {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }
}
~~~

# 安卓开发之路第七天（8.23）

# 安卓开发之路第八天（8.24）

# 安卓开发之路第九天（8.25）

# 安卓开发之路第十天（8.26）

# 安卓开发之路第十一天（8.27）

# 安卓开发之路第十一天（8.28）

# 安卓开发之路第十一天（8.29）

# 安卓开发之路第十一天（8.30）

# 安卓开发之路第十一天（8.31）

# 安卓开发之路第十一天（9.1）

##### 1. 学习安卓 https://github.com/linsir6/AndroidNote