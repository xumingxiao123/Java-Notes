[TOC]

# 规划（一个月内）

#### 1. 看什么？

* 《第一行代码》

* github上的开源项目（**5个**）

#### 2. 做什么？

* 自己做两个项目并上架谷歌商城
  * 类似于githu提交记录去制作一个手机使用时间的说明，分为轻度，中度，重度

#### 3. 其他？

* 阅读java全部源码（领悟设计模式，代码规范，实现思想）
* 玩转字节码和虚拟机
* 深入操作系统层面
* 编程：每天2题及以上
* 专业课不能忘！

| 日期 | 书籍                   | 看项目      | 做项目 | Java | 编程       |
| ---- | ---------------------- | ----------- | ------ | ---- | ---------- |
| 8.16 | 《第一行代码》p0-82    |             |        |      |            |
| 8.17 | 《第一行代码》p82-111  |             |        |      |            |
| 8.18 | 《第一行代码》p111-243 |             |        |      | 二叉搜索树 |
| 8.19 | 《第一行代码》p243-400 |             |        |      |            |
| 8.20 | 《第一行代码》p400-600 |             |        |      |            |
| 8.21 |                        | 天气预报App |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |
|      |                        |             |        |      |            |

# 问题总结（10大问题）

## 【Activity专题】

##### [1] Activity是什么？

> **Android 程序核心组件:**
>
> **View**: 界面视图,组织 UI 控件 
>
> **Intent**: 意图,支持组件间通信 
>
> **Activity**: 处理界面与 UI 互动 
>
> **Content Provider**: 存储共享数据 
>
> **IntentReceiver**: 接收信息及事件处理
>
> **Service**: 后台服务(如硬件与驱动的服务) 
>
> **Notification**: 消息与通知。

我们都知道android中有四大组件（**Activity 活动，Service 服务，Content Provider 内容提供者，BroadcastReceiver 广播接收器**），Activity是我们用的最多也是最基本的组件，因为应用的所有操作都与用户相关，Activity 提供窗口来和用户进行交互。

官方文档这么说： 　　

> An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).
>
> 大概的意思：

> activity是独立平等的，用来处理用户操作。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，开发者可以通过setContentView(View)的接口把UI放到给窗口上。

　　Android中的activity全都归属于task管理 。task 是多个 activity 的集合，这些 activity 按照启动顺序排队存入一个栈（即“back stack”）。android默认会为每个App维持一个task来存放该app的所有activity，task的默认name为该app的packagename。

　　当然我们也可以在AndroidMainfest.xml中申明activity的taskAffinity属性来自定义task，但不建议使用，如果其他app也申明相同的task，它就有可能启动到你的activity，带来各种安全问题（比如拿到你的Intent）。

##### [2] Activity的生命周期

　　上面已经说了，系统通过堆栈来管理activity，当一个新的activity开始时，它被放置在堆栈的顶部和成为运行活动，以前的activity始终保持低于它在堆栈，而不会再次到达前台，直到新的活动退出。

还是上这张官网的activity_lifecycle图： 　　[![这里写图片描述](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)](https://camo.githubusercontent.com/f986bb2922053692d116dda08d9173371414673d/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343235313731373131303534)　

1. 首先打开一个新的activity实例的时候，系统会依次调用

> onCreate（）  -> onStart() -> onResume() 然后开始running

2. running的时候被覆盖了（从它打开了新的activity或是被锁屏，但是它**依然在前台**运行， lost focus but is still visible），系统调用onPause();

> 　该方法执行activity暂停，通常用于提交未保存的更改到持久化数据，停止动画和其他的东西。但这个activity还是完全活着（它保持所有的状态和成员信息，并保持连接到**窗口管理器**）

3. 接下来它有三条出路：

 ①用户返回到该activity就调用onResume()方法重新running

 ②用户回到桌面或是打开其他activity，就会调用onStop()进入停止状态（保留所有的状态和成员信息，**对用户不可见**）

 ③系统内存不足，拥有更高限权的应用需要内存，那么该activity的进程就可能会被系统回收。（回收onRause()和onStop()状态的activity进程）要想重新打开就必须重新创建一遍。

4. 如果用户返回到onStop()状态的activity（又显示在前台了），系统会调用

> onRestart() ->  onStart() -> onResume() 然后重新running

5. 在activity结束（调用finish ()）或是被系统杀死之前会调用onDestroy()方法释放所有占用的资源。

> activity生命周期中三个嵌套的循环

- activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。　
- activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。　
- activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。 因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，**这两个方法中的代码应该相当地轻量化**。

##### [3] activity被回收的状态和信息保存和恢复过程

```java
public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	}
   @Override
protected void onSaveInstanceState(Bundle outState) {
	// TODO Auto-generated method stub
	 //可能被回收内存前保存状态和信息，
	   Bundle data = new Bundle(); 
	   data.putString("key", "last words before be kill");
	   outState.putAll(data);
	super.onSaveInstanceState(outState);
}
   @Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
	// TODO Auto-generated method stub
	   if(savedInstanceState!=null){ //判断是否有以前的保存状态信息
			 savedInstanceState.get("Key"); 
			 }
	super.onRestoreInstanceState(savedInstanceState);
}
}
```

**onSaveInstanceState方法**

　　在activity　可能被回收之前　调用,用来保存自己的状态和信息，以便回收后重建时恢复数据（在onCreate()或onRestoreInstanceState()中恢复）。旋转屏幕重建activity会调用该方法，但其他情况在onRause()和onStop()状态的activity不一定会调用 ，下面是该方法的文档说明。

> One example of when onPause and onStop is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause is called and not onSaveInstanceState is when activity B is launched in front of activity A: the system may avoid calling onSaveInstanceState on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact.

也就是说，系统灵活的来决定调不调用该方法，**但是如果要调用就一定发生在onStop方法之前，但并不保证发生在onPause的前面还是后面。**

**onRestoreInstanceState方法**

　　这个方法在onStart 和 onPostCreate之间调用，在onCreate中也可以状态恢复，但有时候需要所有布局初始化完成后再恢复状态。

　　onPostCreate：一般不实现这个方法，当程序的代码开始运行时，它调用系统做最后的初始化工作。

##### [4] activity启动模式

**启动模式什么？**简单的说就是定义activity 实例与task 的关联方式。 　　

**为什么要定义启动模式？**

　　 为了实现一些默认启动（standard）模式之外的需求： 　　

- 让某个 activity 启动一个新的 task （而不是被放入当前 task ）
- 让 activity 启动时只是调出已有的某个实例（而不是在 back stack 顶创建一个新的实例）　
- 或者，你想在用户离开 task 时只保留根 activity，而 back stack 中的其它 activity 都要清空

**怎样定义启动模式？**

　　定义启动模式的方法有两种：

**使用 manifest 文件**

　　在 manifest 文件中activity声明时，利用 activity 元素的 launchMode 属性来设定 activity 与 task 的关系。

```
 <activity
            ．．．．．．
            android:launchMode="standard"
             >
           ．．．．．．．
        </activity>
```

> 注意： 你用 launchMode 属性为 activity 设置的模式可以被启动 activity 的 intent 标志所覆盖。

**有哪些启动模式？**

- **"standard"** （默认模式）　

　　当通过这种模式来启动Activity时,　Android总会为目标 Activity创建一个新的实例,并将该Activity添加到当前Task栈中。这种方式不会启动新的Task,只是将新的 Activity添加到原有的Task中。　 　　

- **"singleTop"**　

　　该模式和standard模式基本一致,但有一点不同: 当将要被启动的Activity已经位于Task栈顶时,系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- **"singleTask"**

　　Activity在同一个Task内只有一个实例。如果将要启动的Activity不存在,那么系统将会创建该实例,并将其加入Task栈顶；　

　　如果将要启动的Activity已存在,且存在栈顶,直接复用Task栈顶的Activity。　

　　如果Activity存在但是没有位于栈顶,那么此时系统会把位于该Activity上面的所有其他Activity全部移出Task,从而使得该目标Activity位于栈顶。

- **"singleInstance"**　

　　无论从哪个Task中启动目标Activity,只会创建一个目标Activity实例且会用一个全新的Task栈来装载该Activity实例（全局单例）.

　　如果将要启动的Activity不存在,那么系统将会先创建一个全新的Task,再创建目标Activity实例并将该Activity实例放入此全新的Task中。

　　如果将要启动的Activity已存在,那么无论它位于哪个应用程序,哪个Task中;系统都会把该Activity所在的Task转到前台,从而使该Activity显示出来。

**使用 Intent 标志**

　　在要启动 activity 时，你可以在传给 startActivity() 的 **intent** 中包含相应标志，以修改 **activity 与 task** 的默认关系。

```java
　　　　　Intent i = new Intent(this,ＮewActivity.class);
		i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		startActivity(i);
```

**可以通过标志修改的默认模式有哪些？**

- FLAG_ACTIVITY_NEW_TASK

　　与"singleTask"模式相同，在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台。

- FLAG_ACTIVITY_SINGLE_TOP

　　与 "singleTop"模式相同，如果要启动的 activity位于back stack 顶，系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。

- FLAG_ACTIVITY_CLEAR_TOP

　　**此种模式在launchMode中没有对应的属性值。**如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁。

**关于启动模式的一些建议**

　　 一般不要改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持谨慎，并确保 activity 在启动和从其它 activity 返回时的可用性，多做测试和安全方面的工作。

##### [5] Intent Filter

　　android的3个核心组件——Activity、services、广播接收器——是通过intent传递消息的。intent消息用于在运行时绑定不同的组件。在 Android 的 AndroidManifest.xml 配置文件中可以通过 intent-filter 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。

**intent-filter 的三大属性**

**Action**

　　一个 Intent Filter 可以包含多个 Action，Action 列表用于标示 Activity 所能接受的“动作”，它是一个用户自定义的字符串。

```
<intent-filter > 
 <action android:name="android.intent.action.MAIN" /> 
 <action android:name="com.scu.amazing7Action" /> 
……
 </intent-filter>
```

在代码中使用以下语句便可以启动该Intent 对象：

```
Intent i=new Intent(); 
i.setAction("com.scu.amazing7Action");
```

Action 列表中包含了“com.scu.amazing7Action”的 Activity 都将会匹配成功

**URL**

　　在 intent-filter 节点中，通过 data节点匹配外部数据，也就是通过 URI 携带外部数据给目标组件。

```
<data android:mimeType="mimeType" 
	android:scheme="scheme" 
	 android:host="host"
	 android:port="port" 
	 android:path="path"/>
```

注意：只有data的所有的属性都匹配成功时 URI 数据匹配才会成功

**Category**

　　为组件定义一个 类别列表，当 Intent 中包含这个类别列表的所有项目时才会匹配成功。

```
<intent-filter . . . >
   <action android:name="code android.intent.action.MAIN" />
   <category android:name="code　android.intent.category.LAUNCHER" />
</intent-filter>
```

**Activity 中 Intent Filter 的匹配过程**

① 加载所有的Intent Filter列表 　　

② 去掉action匹配失败的Intent Filter 　　

③ 去掉url匹配失败的Intent Filter 　

④ 去掉Category匹配失败的Intent Filter 　

⑤ 判断剩下的Intent Filter数目是否为0。如果为0查找失败返回异常；如果大于0，就按优先级排序，返回最高优先级的Intent Filter

##### [6] 开发中Activity的一些问题

一般设置Activity为非公开的

```java
<activity  
．．．．．． 
android:exported="false" /> 
```

注意：非公开的Activity不能设置intent-filter，以免被其他activity唤醒（如果拥有相同的intent-filter）。

- 不要指定activity的taskAffinity属性
- 不要设置activity的LaunchMode（保持默认）

　　注意Activity的intent最好也不要设定为FLAG_ACTIVITY_NEW_TASK

- 在匿名内部类中使用this时加上activity类名（类名.this,不一定是当前activity）
- 设置activity全屏

　　在其 onCreate()方法中加入：

```java
// 设置全屏模式
 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); 
 // 去除标题栏
 requestWindowFeature(Window.FEATURE_NO_TITLE);
```

## 【Service详细解析】

##### [1] 什么是服务？　　

　　Service是一个应用程序组件，它能够在后台执行一些耗时较长的操作，并且不提供用户界面。服务能被其它应用程序的组件启动，即使用户切换到另外的应用时还能保持后台运行。此外，应用程序组件还能与服务绑定，并与服务进行交互，甚至能进行进程间通信（IPC）。 比如，服务可以处理网络传输、音乐播放、执行文件I/O、或者与content provider进行交互，所有这些都是后台进行的。

##### [2] Service 与Thread的区别

　　服务仅仅是一个组件，即使用户不再与你的应用程序发生交互，它仍然能在后台运行。因此，应该只在需要时才创建一个服务。

　　如果你需要在主线程之外执行一些工作，但仅当用户与你的应用程序交互时才会用到，那你应该创建一个新的线程而不是创建服务。 比如，如果你需要播放一些音乐，但只是当你的activity在运行时才需要播放，你可以在onCreate()中创建一个线程，在onStart()中开始运行，然后在onStop()中终止运行。还可以考虑使用AsyncTask或HandlerThread来取代传统的Thread类。

　　**由于无法在不同的 Activity 中对同一 Thread 进行控制**，这个时候就要考虑用服务实现。如果你使用了服务，它默认就运行于应用程序的主线程中。因此，如果服务执行密集计算或者阻塞操作，你仍然应该在服务中创建一个新的线程来完成（避免ANR）。

##### [3] 服务的分类

**1. 按运行分类**

- 前台服务

　　前台服务是指那些经常会被用户关注的服务，因此内存过低时它不会成为被杀的对象。 前台服务必须提供一个状态栏通知，并会置于“正在进行的”（“Ongoing”）组之下。这意味着只有在服务被终止或从前台移除之后，此通知才能被解除。例如，用服务来播放音乐的播放器就应该运行在前台，因为用户会清楚地知晓它的运行情况。 状态栏通知可能会标明当前播放的歌曲，并允许用户启动一个activity来与播放器进行交互。

　　要把你的服务请求为前台运行，可以调用**startForeground()**方法。此方法有两个参数：唯一标识通知的整数值、状态栏通知Notification对象。例如：

```java
Notification notification = new Notification(R.drawable.icon, getText(R.string.ticker_text),System.currentTimeMillis());
Intent notificationIntent = new Intent(this,ExampleActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
notification.setLatestEventInfo(this, getText(R.string.notification_title),
        getText(R.string.notification_message), pendingIntent);  
startForeground(ONGOING_NOTIFICATION, notification);
```

　　要从前台移除服务，请调用**stopForeground()**方法，这个方法接受个布尔参数，表示是否同时移除状态栏通知。此方法不会终止服务。不过，如果服务在前台运行时被你终止了，那么通知也会同时被移除。

- 后台服务

**2. 按使用分类**　　

- **本地服务**：用于应用程序内部，实现一些耗时任务，并不占用应用程序比如Activity所属线程，而是单开线程后台执行。调用Context.startService()启动，调用Context.stopService()结束。在内部可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。

- **远程服务**：用于Android系统内部的应用程序之间，可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。可以定义接口并把接口暴露出来，以便其他应用进行操作。客户端建立到服务对象的连接，并通过那个连接来调用服务。调用Context.bindService()方法建立连接，并启动，以调用 Context.unbindService()关闭连接。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。

##### [4] Service生命周期

　                                   ![img](https://upload-images.jianshu.io/upload_images/4625401-84380bfeb9c4b0ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



【链接：https://www.jianshu.com/p/cc25fbb5c0b3】

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200901224652977.png" alt="image-20200901224652977" style="zoom:80%;" />



**Service生命周期方法：**

```java
public class ExampleService extends Service {
    int mStartMode;       // 标识服务被杀死后的处理方式
    IBinder mBinder;      // 用于客户端绑定的接口
    boolean mAllowRebind; // 标识是否使用onRebind

    @Override
    public void onCreate() {
        // 服务正被创建
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // 服务正在启动，由startService()调用引发
        return mStartMode;
    }
    @Override
    public IBinder onBind(Intent intent) {
        // 客户端用bindService()绑定服务
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        // 所有的客户端都用unbindService()解除了绑定
        return mAllowRebind;
    }
    @Override
    public void onRebind(Intent intent) {
        // 某客户端正用bindService()绑定到服务,
        // 而onUnbind()已经被调用过了
    }
    @Override
    public void onDestroy() {
        // 服务用不上了，将被销毁
    }
}
```

> 请注意onStartCommand()方法必须返回一个整数。这个整数是描述系统在杀死服务之后应该如何继续运行。onStartCommand()的返回值必须是以下常量之一：

> START_NOT_STICKY 如果系统在onStartCommand()返回后杀死了服务，则不会重建服务了，除非还存在未发送的intent。 当服务不再是必需的，并且应用程序能够简单地重启那些未完成的工作时，这是避免服务运行的最安全的选项。START_STICKY 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并调用onStartCommand()，但不会再次送入上一个intent， 而是用null intent来调用onStartCommand() 。除非还有启动服务的intent未发送完，那么这些剩下的intent会继续发送。 这适用于媒体播放器（或类似服务），它们不执行命令，但需要一直运行并随时待命。　

> START_REDELIVER_INTENT 如果系统在onStartCommand()返回后杀死了服务，则将重建服务并用上一个已送过的intent调用onStartCommand()。任何未发送完的intent也都会依次送入。这适用于那些需要立即恢复工作的活跃服务，比如下载文件。

　　服务的生命周期与activity的非常类似。不过，更重要的是你需密切关注服务的创建和销毁环节，因为后台运行的服务是不会引起用户注意的。

　　服务的生命周期——从创建到销毁——可以有两种路径：

- **一个started服务**

　　这类服务由其它组件调用startService()来创建。然后保持运行，且**必须通过调用stopSelf()自行终止**。其它组件也可通过调用stopService() 终止这类服务。服务终止后，系统会把它销毁。

　　如果一个Service被startService 方法多次启动，那么onCreate方法只会调用一次，onStart将会被调用多次（对应调用startService的次数），并且**系统只会创建Service的一个实例**（因此你应该知道只需要一次stopService调用）。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。

- **一个bound服务**

　　服务由其它组件（客户端）调用bindService()来创建。然后客户端通过一个**IBinder接口与服务进行通信**。客户端可以通过调用unbindService()来关闭联接。多个客户端可以绑定到同一个服务上，当所有的客户端都解除绑定后，系统会销毁服务。（服务不需要自行终止。）

　　如果一个Service被某个Activity 调用 Context.bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStart方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。

![img](https://upload-images.jianshu.io/upload_images/4625401-756d89b600d55081.png?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

　　这两条路径并不是完全隔离的。也就是说，你可以绑定到一个已经用startService()启动的服务上。例如，一个后台音乐服务可以通过调用startService()来启动，传入一个指明所需播放音乐的 Intent。 之后，用户也许需要用播放器进行一些控制，或者需要查看当前歌曲的信息，这时一个activity可以通过调用bindService()与此服务绑定。在类似这种情况下，stopService()或stopSelf()不会真的终止服务，除非所有的客户端都解除了绑定。

> 　　当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。

**在manifest中声明服务**

　　无论是什么类型的服务都必须在manifest中申明，格式如下：

```
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```

Service 元素的属性有：

> android:name　　-------------　　服务类名

> android:label　　--------------　　服务的名字，如果此项不设置，那么默认显示的服务名则为类名

> android:icon　　--------------　　服务的图标

> android:permission　　-------　　申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务

> android:process　　----------　　表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字

> android:enabled　　----------　　如果此项设置为 true，那么 Service 将会默认被系统启动，不设置默认此项为 false

> android:exported　　---------　　表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false　

　　android:name是唯一必需的属性——它定义了服务的类名。与activity一样，服务可以定义intent过滤器，使得其它组件能用隐式intent来调用服务。如果你想让服务只能内部使用（其它应用程序无法调用），那么就不必（也不应该）提供任何intent过滤器。 　　此外，如果包含了android:exported属性并且设置为"false"， 就可以确保该服务是你应用程序的私有服务。即使服务提供了intent过滤器，本属性依然生效。　

**startService 启动服务**

　　从activity或其它应用程序组件中可以启动一个服务，调用startService()并传入一个Intent（指定所需启动的服务）即可。

```java
	Intent intent = new Intent(this, MyService.class);
	startService(intent);
```

服务类：

```java
public class MyService extends Service {

	  /**
     * onBind 是 Service 的虚方法，因此我们不得不实现它。
     * 返回 null，表示客服端不能建立到此服务的连接。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return null;
	}
    
	@Override
    public void onCreate() {
        super.onCreate();
    }
     
    @Override
 public int onStartCommand(Intent intent, int flags, int startId)  　　 {  	
    //接受传递过来的intent的数据 
     return START_STICKY; 
    };
     
    @Override
    public void onDestroy() {
        super.onDestroy();
    }
	
}
```

　　一个started服务必须自行管理生命周期。也就是说，系统不会终止或销毁这类服务，除非必须恢复系统内存并且服务返回后一直维持运行。 因此，服务必须通过调用stopSelf()自行终止，或者其它组件可通过调用stopService()来终止它。

**bindService 启动服务**　　

　　当应用程序中的activity或其它组件需要与服务进行交互，或者应用程序的某些功能需要暴露给其它应用程序时，你应该创建一个bound服务，并通过进程间通信（IPC）来完成。

方法如下：

```
 Intent intent=new Intent(this,BindService.class); 
 bindService(intent, ServiceConnection conn, int flags)  
```

> 注意bindService是Context中的方法，当没有Context时传入即可。

在进行服务绑定的时，其flags有：

- Context.BIND_AUTO_CREATE

　　表示收到绑定请求的时候，如果服务尚未创建，则即刻创建，在系统内存不足需要先摧毁优先级组件来释放内存，且只有驻留该服务的进程成为被摧毁对象时，服务才被摧毁　

- Context.BIND_DEBUG_UNBIND    　

　　通常用于调试场景中判断绑定的服务是否正确，但容易引起内存泄漏，因此非调试目的的时候不建议使用

- Context.BIND_NOT_FOREGROUND    　

　　表示系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行。

服务类：

```
public class BindService extends Service {

	 // 实例化MyBinder得到mybinder对象；
	private final MyBinder binder = new MyBinder();
	
	  /**
     * 返回Binder对象。
     */
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return binder;
	}
    
     /**
      * 新建内部类MyBinder，继承自Binder(Binder实现IBinder接口),
      * MyBinder提供方法返回BindService实例。
      */
　　public class MyBinder extends Binder{
        
        public BindService getService(){
            return BindService.this;
        }
    }
     

	@Override
	public boolean onUnbind(Intent intent) {
		// TODO Auto-generated method stub
		return super.onUnbind(intent);
	}
}
```

启动服务的activity代码：

```
public class MainActivity extends Activity {

	/** 是否绑定 */  
	boolean mIsBound = false; 
	BindService mBoundService;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		doBindService();
	}
	/**
	 * 实例化ServiceConnection接口的实现类,用于监听服务的状态
	 */
	private ServiceConnection conn = new ServiceConnection() {  
		  
	    @Override  
	    public void onServiceConnected(ComponentName name, IBinder service) {  
	        BindService mBoundService = ((BindService.MyBinder) service).getService();  
	        
	    }  
	  
	    @Override  
	    public void onServiceDisconnected(ComponentName name) {  
	        mBoundService = null;  
	     
	    }  
	}; 
	
	/** 绑定服务 */  
	public void doBindService() {  
	    bindService(new Intent(MainActivity.this, BindService.class), conn,Context.BIND_AUTO_CREATE);  
	    mIsBound = true;  
	}  
	
	/** 解除绑定服务 */  
	public void doUnbindService() {  
	    if (mIsBound) {  
	        // Detach our existing connection.  
	        unbindService(conn);  
	        mIsBound = false;  
	    }  
	} 
	
	@Override
	protected void onDestroy() {
		// TODO Auto-generated method stub
		super.onDestroy();
		
		doUnbindService();
	}
}
```

> 注意在AndroidMainfest.xml中对Service进行显式声明

判断Service是否正在运行：

```
private boolean isServiceRunning() {
    ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    
 　{
        if ("com.example.demo.BindService".equals(service.service.getClassName())) 　　{
            return true;
        }
    }
    return false;
}
```

##### [5] [bindService与startService区别](https://www.cnblogs.com/yesphet/p/4766786.html)

1. Started Service中使用startService（）方法来进行方法的调用，调用者和服务之间没有联系，即使调用者退出了，服务依然在进行 【onCreate()-  >onStartCommand()->startService()->onDestroy()】，注意其中没有 onStart()，主要是被onStartCommand()方法给取代了，onStart方法不推荐使用了。
2. BindService中使用bindService()方法来绑定服务，调用者和绑定者绑在一起，调用者一旦退出服务也就终止了【onCreate()->onBind()->onUnbind()->onDestroy()】。

##### [6] IntentService详细解析

1. **IntentService定义**

　　IntentService继承于Service，用来处理异步请求。客户端可以通过startService(Intent)方法传递请求给IntentService。IntentService在onCreate()函数中通过HandlerThread单独开启一个线程来依次处理所有Intent请求对象所对应的任务。这样以免事务处理阻塞主线程（ＡＮＲ）。执行完所一个Intent请求对象所对应的工作之后，如果没有新的Intent请求达到，则**自动停止**Service；否则执行下一个Intent请求所对应的任务。　 　　    IntentService在处理事务时，还是采用的Handler方式，创建一个名叫ServiceHandler的内部Handler，并把它直接绑定到HandlerThread所对应的子线程。 ServiceHandler把处理一个intent所对应的事务都封装到叫做**onHandleIntent**的虚函数；因此我们直接实现虚函数onHandleIntent，再在里面根据Intent的不同进行不同的事务处理就可以了。 另外，IntentService默认实现了Onbind（）方法，返回值为null。

使用IntentService需要实现的两个方法： 　　

- **构造函数**　

　　IntentService的构造函数一定是**参数为空**的构造函数，然后再在其中调用super("name")这种形式的构造函数。因为Service的实例化是系统来完成的，而且系统是用参数为空的构造函数来实例化Service的

- **实现虚函数onHandleIntent**

　　在里面根据Intent的不同进行不同的事务处理。好处：处理异步请求的时候可以减少写代码的工作量，比较轻松地实现项目的需求。

2. **IntentService与Service的区别**

　　Service不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的，不建议在Service中编写耗时的逻辑和操作，否则会引起ANR。

　　IntentService 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents（把intent插入到工作队列中）。通过工作队列把intent逐个发送给onHandleIntent()。不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。

　　 默认实现的onBind()返回null。

3. **IntentService实例介绍**

　　首先是myIntentService.java

```java
public class myIntentService extends IntentService {

	//------------------必须实现-----------------------------
	
	public myIntentService() {
		super("myIntentService");
		// 注意构造函数参数为空，这个字符串就是worker thread的名字
	}

	@Override
	protected void onHandleIntent(Intent intent) {
		//根据Intent的不同进行不同的事务处理 
        String taskName = intent.getExtras().getString("taskName");  
        switch (taskName) {
		case "task1":
			Log.i("myIntentService", "do task1");
			break;
		case "task2":
			Log.i("myIntentService", "do task2");
			break;
		default:
			break;
		}		
	}
  //--------------------用于打印生命周期--------------------	
   @Override
  public void onCreate() {
		Log.i("myIntentService", "onCreate");
	super.onCreate();
}
	
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		Log.i("myIntentService", "onStartCommand");
		return super.onStartCommand(intent, flags, startId);
	}
	
	@Override
	public void onDestroy() {
		Log.i("myIntentService", "onDestroy");
		super.onDestroy();
	}
}
```

然后记得在Manifest.xml中注册服务

```java
 <service android:name=".myIntentService">
            <intent-filter >  
                <action android:name="cn.scu.finch"/>  
            </intent-filter>     
        </service>
```

最后在Activity中开启服务

```java
public class MainActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		
		//同一服务只会开启一个worker thread，在onHandleIntent函数里依次处理intent请求。
		
        Intent i = new Intent("cn.scu.finch");  
        Bundle bundle = new Bundle();  
        bundle.putString("taskName", "task1");  
        i.putExtras(bundle);  
        startService(i);  
           
        Intent i2 = new Intent("cn.scu.finch");  
        Bundle bundle2 = new Bundle();  
        bundle2.putString("taskName", "task2");  
        i2.putExtras(bundle2);  
        startService(i2); 
        
        startService(i);  //多次启动
	}
}
```

运行结果：

[![这里写图片描述](https://camo.githubusercontent.com/fb6bf8fc2ff7c1713ef558183b6ab0f47cb846e3/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353133313335343131303337)](https://camo.githubusercontent.com/fb6bf8fc2ff7c1713ef558183b6ab0f47cb846e3/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353133313335343131303337)　

　　IntentService在onCreate()函数中通过HandlerThread单独开启一个线程来依次处理所有Intent请求对象所对应的任务。通过onStartCommand()传递给服务intent被**依次**插入到工作队列中。工作队列又把intent逐个发送给onHandleIntent()。

> 注意： 它只有一个工作线程，名字就是构造函数的那个字符串，也就是“myIntentService”，我们知道多次开启service，只会调用一次onCreate方法（创建一个工作线程），多次onStartCommand方法（用于传入intent通过工作队列再发给onHandleIntent函数做处理）。

##### [7] IntentService——Handler与Service的结合 

**综述**

　　我们都知道Service是作为后台服务运行再程序中的。但是Service他依然是运行在主线程中的，所以我们依然不能在Service中进行耗时的操作。所以当我们在Service处理时，我们需要在Service中开启一个子线程，并且在子线程中运行。当然为了简化我们的操作，在Android中为我们提供了IntentService来进行这一处理，下面我们就来看一下这个IntentService用法以及它的工作原理。

**用法简介**

　　IntentService它继承自Service，一来说我们开启一个Service可以通过startService和bindService两个方式进行开启一个服务，但是对于IntentService我们采用startService方法进行开启服务，对于为什么要这么做，在后面会进行分析讲解。下面我们来看一下如何使用这个IntentService的。

**效果演示**

　　在这里我们做一个倒计时的程序，以毫秒为单位。这里先看一下效果演示。 

​                                                ![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTpy8CspBHm5RjmJsZbU6YsKibeaWobtRBCg7ahv5g76bqR8TosABUmDA/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

**代码分析**

　　在这里我们使用到了开源框架EventBus，对于EventBus的使用可以参考 EventBus3.0使用详解这篇文章。由于我们用到这EventBus,首先我们创建一个实体类，在EventBus中进行发送，接收处理。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTkzbscibibDjE0rNJxRhpCgmk7xcZrkkWl3tlu1UWsmibfX3nJ93FlAVCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面我们看一下IntentService中的代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTO8QD9S1YNfsbpseDhazeHJLplSvQv4xiaS6PjRne1AmC2rT5lkFhmCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSThDRPckUxibsNm9yicNEL07HEMW8NFic1dP3ehWYMt2S5VjPFCWejrK4Yg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
    在上面的handleActionFoo方法中进行我们的耗时任务。然后我们在看一下Activity中的代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTwRIh3HDECYkicHnkUIB8SjanSUW59HrKBaNNbc6djlYUHu0pJDPupkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTTTiaDiacJZZmJTCbmBKRuHItpUV1pbrictSPx0oAiaEsia9sH22CdWLSb4Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　最后是布局代码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTXoG5nZJrnP1Exh0KUFjriaVqEInkokB2ZdvLqTdYgz74yRl3mZSSmqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　对于上面代码实现起来都是非常的简单，在这里就不在进行详细介绍。

**IntentService工作原理分析**

　　其实对于IntentService的工作原理也不复杂，既然在IntentService中能够进行耗时操作，也就是说在这个IntentService中必然也创建了一个子线程，在Android中我们称为工作者线程。然后在这个工作者线程中进行我们的任务。在分析IntentService之前，我们先看一下HandlerThread。

**HandlerThread**

　　其实HandlerThread就是一个工作者线程，在这里看一下HandlerThread的源码。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTepsCEdZwVLB1fibYxF4RKttibspqmCrg2AcrsyiaibXibSUkn92aWOf86yA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)　　![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTKkbVSAAU3nkPr7Uybk9pBznvdejYPMZ6uwLAyNJ006t6EMXY6ib8ViaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​    看过上篇文章 Android的消息机制——Handler的工作过程就很容易理解这个HandlerThread了。还记的我们在上篇文章的最后，新建了一个包含Looper的子线程。而这个HandlerThread也就是一个包含Looper的子线程。所以当我们需要创建一个包含Looper的线程时直接使用HandlerThread即可。对于HandlerThread有以下几点需要说明一下。 

　　1. 在构造方法中设置线程优先级的时候，使用的Process是android.os包中的而不是java.lang包内的。 
　　2. 如果在Looper开启消息循环之前我们进行一些设置，我们可以继承HandlerThread并且重写onLooperPrepared方法。 
　　3. 通过getLooper方法我们获取HandlerThread的Looper对象时，有可能Looper还未创建完成。所以在getLooper中未创建Looper是进行了线程等待操作，在创建完Looper以后在返回Looper对象。

**IntentService**

　　下面我们再看一下IntentService。

![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTKvgBvpPOQ2jF5pxJO2cQ0bJnm55xSO7K4EW6m62Zavjadb2hB2JNzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
![img](http://mmbiz.qpic.cn/mmbiz/ibuh47bPhianYgmJ0lbibDDuMmxjwQMlxSTxhw7cqTxFtMs3Y6QvTmRUAjHpDZQFzfVHqEVqowTS0g1RBP1WkxzXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

　　我们看一下这个IntentService的构造是不是很简单。在这里主要看一下onCreate和onStart方法即可。在onCreate中，我们开启了一个HandlerThread线程，之后获取HandlerThread线程中的Looper，并通过这个Looper创建了一个Handler。然后在onStart方法中通过这个Handler将intent与startId作为Message的参数进行发送到消息队列中，然后交由Handler中的handleMessage中进行处理。由于在onStart方法是在主线程内运行的，而Handler是通过工作者线程HandlerThread中的Looper创建的。所以也就是在主线程中发送消息，在工作者接收到消息后便可以进行一些耗时的操作。 
　　我们在看一下handleMessage中的操作，在handleMessage中调用onHandleIntent方法，他是一个抽象方法，所以在我们的Service中复写onHandleIntent方法并且将耗时的操作写在onHandleIntent方法内即可。当执行完onHandleIntent后通过stopSelf来停止服务，这样就不用我们手动停止服务了。所以也就回答了我们上面那个为什么要使用startService而不用onBind来开启一个IntentService。

**总结**

　　从我们的示例和源码分析中可以看出来。对于通过IntentService来执行任务，他是串行的。也就是说只有在上一个任务执行完以后才会执行下一个任务。因为Handler中将消息插入消息队列，而队列又是先进先出的数据结构。所以只有在上个任务执行完成以后才能够获取到下一个任务进行操作。在这里也就说明了对于高并发的任务同过IntentService是不合适.

## 【ContentProvider详解】

##### [1] ContentProvider是什么？

　　**ContentProvider（内容提供者）是Android的四大组件之一**，管理android以结构化方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口供**其他程序**调用。Android的数据存储方式总共有五种，分别是：**Shared Preferences、网络存储、文件存储、外储存储、SQLite**。但一般这些存储都只是在单独的一个应用程序之中达到一个数据的共享，有时候**我们需要操作其他应用程序的一些数据，就会用到ContentProvider**。而且Android为常见的一些数据提供了默认的ContentProvider（包括音频、视频、图片和通讯录等）。

　　但注意**ContentProvider它也只是一个中间人**，真正操作的数据源可能是数据库，也可以是文件、xml或网络等其他存储方式。

##### [2] URL

　　URL（统一资源标识符）代表要操作的数据，可以用来标识每个ContentProvider，这样你就可以通过指定的URI找到想要的ContentProvider, 从中获取或修改数据。在Android中URI的格式如下图所示：

[![这里写图片描述](https://camo.githubusercontent.com/1e138aeb9ce10fa4b788b18659fae3d8d29da73a/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313534333232303435)](https://camo.githubusercontent.com/1e138aeb9ce10fa4b788b18659fae3d8d29da73a/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313534333232303435)　

　　

- Ａ： schema，已经由Android所规定为：content://．　 　　　
- Ｂ：主机名（Authority），是URI的授权部分，是唯一标识符，用来定位ContentProvider。

> Ｃ部分和D部分：是每个ContentProvider内部的路径部分

- Ｃ：指向一个对象集合，一般用表的名字，如果没有指定D部分，则返回全部记录。

- Ｄ：指向特定的记录，这里表示操作user表id为7的记录。如果要操作user表中id为7的记录的name字段， D部分变为       **/7/name**即可。

> URI模式匹配通配符
>
> *：匹配的任意长度的任何有效字符的字符串。
>
> ＃：匹配的任意长度的数字字符的字符串。
>
> 如：
>
> content://com.example.app.provider/* 匹配provider的任何内容url
>
> content://com.example.app.provider/table3/# 匹配table3的所有行

**2.１MIME**

　　MIME是指定某个扩展名的文件用一种应用程序来打开，就像你用浏览器查看PDF格式的文件，浏览器会选择合适的应用来打开一样。Android中的工作方式跟HTTP类似，ContentProvider会根据URI来返回MIME类型，ContentProvider会返回一个包含两部分的字符串。MIME类型一般包含两部分，如：

> text/html text/css text/xml application/pdf

　　分为类型和子类型，Android遵循类似的约定来定义MIME类型，每个内容类型的Android MIME类型有两种形式：多条记录（集合）和单条记录。

　　集合记录：

```
vnd.android.cursor.dir/自定义
```

　　单条记录：

```
vnd.android.cursor.item/自定义
```

　　vnd表示这些类型和子类型具有非标准的、供应商特定的形式。Android中类型已经固定好了，不能更改，只能区别是集合还是单条具体记录，子类型可以按照格式自己填写。在使用Intent时，会用到MIME，根据Mimetype打开符合条件的活动。

　　下面分别介绍Android系统提供了两个用于操作Uri的工具类：ContentUris和UriMatcher。

**2.２ ContentUris**

　　ContetnUris包含一个便利的函数withAppendedId()来向URI追加一个id。

```
Uri uri = Uri.parse("content://cn.scu.myprovider/user")
Uri resultUri = ContentUris.withAppendedId(uri, 7); 

//生成后的Uri为：content://cn.scu.myprovider/user/7
```

　　同时提供parseId(uri)方法用于从URL中获取ID:

```
Uri uri = Uri.parse("content://cn.scu.myprovider/user/7")
long personid = ContentUris.parseId(uri);
//获取的结果为:7
```

**2.３UriMatcher**

　　UriMatcher本质上是一个文本过滤器，用在contentProvider中帮助我们过滤，分辨出查询者想要查询哪个数据表。

　　举例说明：

- 第一步，初始化：

```
UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码
```

- 第二步，注册需要的Uri：

```
//USER 和 USER_ID是两个int型数据
matcher.addURI("cn.scu.myprovider", "user", USER);
matcher.addURI("cn.scu.myprovider", "user/#",USER_ID);
//如果match()方法匹配content://cn.scu.myprovider/user路径，返回匹配码为USER
```

- 第三部，与已经注册的Uri进行匹配:

```
/* 
     * 如果操作集合，则必须以vnd.android.cursor.dir开头 
     * 如果操作非集合，则必须以vnd.android.cursor.item开头 
     * */  
    @Override  
    public String getType(Uri uri) {  
    Uri uri = Uri.parse("content://" + "cn.scu.myprovider" + "/user");  
        switch(matcher.match(uri)){  
        case USER:  
            return "vnd.android.cursor.dir/user";  
        case USER_ID:  
            return "vnd.android.cursor.item/user";  
        }  
    } 
```

##### [3] ContentProvider的主要方法

> public boolean onCreate()

　　ContentProvider创建后或打开系统后其它应用第一次访问该ContentProvider时调用。

> public Uri insert(Uri uri, ContentValues values)

　　外部应用向ContentProvider中添加数据。

> public int delete(Uri uri, String selection, String[] selectionArgs)

　　外部应用从ContentProvider删除数据。

> public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)：

　　外部应用更新ContentProvider中的数据。

> public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)　

　　供外部应用从ContentProvider中获取数据。 　

> public String getType(Uri uri)

　　该方法用于返回当前Url所代表数据的MIME类型。

##### [4] ContentResolver

　　ContentResolver通过URI来查询ContentProvider中提供的数据。除了URI以 外，还必须知道需要获取的数据段的名称，以及此数据段的数据类型。如果你需要获取一个特定的记录，你就必须知道当前记录的ID，也就是URI中D部分。

　　ContentResolver 类提供了与ContentProvider类相同签名的四个方法：

> public Uri insert(Uri uri, ContentValues values)　//添加

> public int delete(Uri uri, String selection, String[] selectionArgs)　//删除
>
> public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)　//更新
>
> public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)//获取

实例代码：

```
ContentResolver resolver =  getContentResolver();
Uri uri = Uri.parse("content://cn.scu.myprovider/user");

//添加一条记录
ContentValues values = new ContentValues();
values.put("name", "fanrunqi");
values.put("age", 24);
resolver.insert(uri, values);  

//获取user表中所有记录
Cursor cursor = resolver.query(uri, null, null, null, "userid desc");
while(cursor.moveToNext()){
   //操作
}

//把id为1的记录的name字段值更改新为finch
ContentValues updateValues = new ContentValues();
updateValues.put("name", "finch");
Uri updateIdUri = ContentUris.withAppendedId(uri, 1);
resolver.update(updateIdUri, updateValues, null, null);

//删除id为2的记录
Uri deleteIdUri = ContentUris.withAppendedId(uri, 2);
resolver.delete(deleteIdUri, null, null);
```

##### [5] ContentObserver

　　　 ContentObserver(内容观察者)，目的是观察特定Uri引起的数据库的变化，继而做一些相应的处理，它类似于数据库技术中的触发器(Trigger)，当ContentObserver所观察的Uri发生变化时，便会触发它.

```
下面是使用内容观察者监听短信的例子：
public class MainActivity extends Activity {
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
         
//注册观察者Observser    
this.getContentResolver().registerContentObserver(Uri.parse("content://sms"),true,new SMSObserver(new Handler()));
 
    }
 
    private final class SMSObserver extends ContentObserver {
 
        public SMSObserver(Handler handler) {
            super(handler);
 
        }
 
     
        @Override
        public void onChange(boolean selfChange) {
 
 Cursor cursor = MainActivity.this.getContentResolver().query(
Uri.parse("content://sms/inbox"), null, null, null, null);
 
            while (cursor.moveToNext()) {
                StringBuilder sb = new StringBuilder();
 
                sb.append("address=").append(
                        cursor.getString(cursor.getColumnIndex("address")));
 
                sb.append(";subject=").append(
                        cursor.getString(cursor.getColumnIndex("subject")));
 
                sb.append(";body=").append(
                        cursor.getString(cursor.getColumnIndex("body")));
 
                sb.append(";time=").append(
                        cursor.getLong(cursor.getColumnIndex("date")));
 
                System.out.println("--------has Receivered SMS::" + sb.toString());
 
                 
            }
 
        }
 
    }
}
```

同时可以在ContentProvider发生数据变化时调用 getContentResolver().notifyChange(uri, null)来通知注册在此URI上的访问者。

　　

```
public class UserContentProvider extends ContentProvider {
   public Uri insert(Uri uri, ContentValues values) {
      db.insert("user", "userid", values);
      getContext().getContentResolver().notifyChange(uri, null);
   }
}
```

##### [6] 实例说明

　　数据源是SQLite, 用ContentResolver操作ContentProvider。

![img](https://camo.githubusercontent.com/1302cfe3a60f9edf38daa5202d006ea98ae7d9af/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353035313935313433303939)

Constant.java（储存一些常量）

```
public class Constant {  
      
    public static final String TABLE_NAME = "user";  
      
    public static final String COLUMN_ID = "_id";  
    public static final String COLUMN_NAME = "name";  
       
       
    public static final String AUTOHORITY = "cn.scu.myprovider";  
    public static final int ITEM = 1;  
    public static final int ITEM_ID = 2;  
       
    public static final String CONTENT_TYPE = "vnd.android.cursor.dir/user";  
    public static final String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/user";  
       
    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTOHORITY + "/user");  
}  
```

DBHelper.java(操作数据库)

```
public class DBHelper extends SQLiteOpenHelper {  
  
    private static final String DATABASE_NAME = "finch.db";    
    private static final int DATABASE_VERSION = 1;    
  
    public DBHelper(Context context) {  
        super(context, DATABASE_NAME, null, DATABASE_VERSION);  
    }  
  
    @Override  
    public void onCreate(SQLiteDatabase db)  throws SQLException {  
        //创建表格  
        db.execSQL("CREATE TABLE IF NOT EXISTS "+ Constant.TABLE_NAME + "("+ Constant.COLUMN_ID +" INTEGER PRIMARY KEY AUTOINCREMENT," + Constant.COLUMN_NAME +" VARCHAR NOT NULL);");  
    }  
  
    @Override  
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)  throws SQLException {  
        //删除并创建表格  
        db.execSQL("DROP TABLE IF EXISTS "+ Constant.TABLE_NAME+";");  
        onCreate(db);  
    }  
}  
```

　MyProvider.java(自定义的ContentProvider)　

```
public class MyProvider extends ContentProvider {    
    
    DBHelper mDbHelper = null;    
    SQLiteDatabase db = null;    
    
    private static final UriMatcher mMatcher;    
    static{    
        mMatcher = new UriMatcher(UriMatcher.NO_MATCH);    
        mMatcher.addURI(Constant.AUTOHORITY,Constant.TABLE_NAME, Constant.ITEM);    
        mMatcher.addURI(Constant.AUTOHORITY, Constant.TABLE_NAME+"/#", Constant.ITEM_ID);    
    }    
    
  
    @Override    
    public String getType(Uri uri) {    
        switch (mMatcher.match(uri)) {    
        case Constant.ITEM:    
            return Constant.CONTENT_TYPE;    
        case Constant.ITEM_ID:    
            return Constant.CONTENT_ITEM_TYPE;    
        default:    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
    }    
    
    @Override    
    public Uri insert(Uri uri, ContentValues values) {    
        // TODO Auto-generated method stub    
        long rowId;    
        if(mMatcher.match(uri)!=Constant.ITEM){    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
        rowId = db.insert(Constant.TABLE_NAME,null,values);    
        if(rowId>0){    
            Uri noteUri=ContentUris.withAppendedId(Constant.CONTENT_URI, rowId);    
            getContext().getContentResolver().notifyChange(noteUri, null);    
            return noteUri;    
        }    
    
        throw new SQLException("Failed to insert row into " + uri);    
    }    
    
    @Override    
    public boolean onCreate() {    
        // TODO Auto-generated method stub    
        mDbHelper = new DBHelper(getContext());    
    
        db = mDbHelper.getReadableDatabase();    
    
        return true;    
    }    
    
    @Override    
    public Cursor query(Uri uri, String[] projection, String selection,    
            String[] selectionArgs, String sortOrder) {    
        // TODO Auto-generated method stub    
        Cursor c = null;    
        switch (mMatcher.match(uri)) {    
        case Constant.ITEM:    
            c =  db.query(Constant.TABLE_NAME, projection, selection, selectionArgs, null, null, sortOrder);    
            break;    
        case Constant.ITEM_ID:    
            c = db.query(Constant.TABLE_NAME, projection,Constant.COLUMN_ID + "="+uri.getLastPathSegment(), selectionArgs, null, null, sortOrder);    
            break;    
        default:    
            throw new IllegalArgumentException("Unknown URI"+uri);    
        }    
    
        c.setNotificationUri(getContext().getContentResolver(), uri);    
        return c;    
    }    
    
    @Override    
    public int update(Uri uri, ContentValues values, String selection,    
            String[] selectionArgs) {    
        // TODO Auto-generated method stub    
        return 0;    
    }

	@Override
	public int delete(Uri uri, String selection, String[] selectionArgs) {
		// TODO Auto-generated method stub
		return 0;
	}    
    
}    
```

MainActivity.java(ContentResolver操作)

```
public class MainActivity extends Activity {
    private ContentResolver mContentResolver = null; 
    private Cursor cursor = null;  
         @Override
        protected void onCreate(Bundle savedInstanceState) {
        	// TODO Auto-generated method stub
        	super.onCreate(savedInstanceState);
        	setContentView(R.layout.activity_main);
        	
        	   TextView tv = (TextView) findViewById(R.id.tv);
				
        		mContentResolver = getContentResolver();  
        		tv.setText("添加初始数据 ");
                for (int i = 0; i < 10; i++) {  
                    ContentValues values = new ContentValues();  
                    values.put(Constant.COLUMN_NAME, "fanrunqi"+i);  
                    mContentResolver.insert(Constant.CONTENT_URI, values);  
                } 
                
            	tv.setText("查询数据 ");
                cursor = mContentResolver.query(Constant.CONTENT_URI, new String[]{Constant.COLUMN_ID,Constant.COLUMN_NAME}, null, null, null);  
                if (cursor.moveToFirst()) {
                	String s = cursor.getString(cursor.getColumnIndex(Constant.COLUMN_NAME));
                	tv.setText("第一个数据： "+s);
                }
        }
         
}  
```

最后在manifest申明

```
<provider android:name="MyProvider" android:authorities="cn.scu.myprovider" />
```

## 【BroadcastReceiver详细解析】

##### [1] BroadcastReceiver的定义

广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。

在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接收系统的广播让应用程序作出相应的处理。

BroadcastReceiver **自身并不实现图形用户界面**，但是当它收到某个通知后， BroadcastReceiver 可以通过启动 Service 、启动 Activity 或是 NotificationMananger 提醒用户。

##### [2] BroadcastReceiver使用注意

　　当系统或应用发出广播时，将会扫描系统中的所有广播接收者，通过action匹配将广播发送给相应的接收者，接收者收到广播后将会产生一个广播接收者的实例，执行其中的onReceiver()这个方法；特别需要注意的是这个实例的生命周期只有10秒，如果10秒内没执行结束onReceiver()，系统将会报错。

在onReceiver()执行完毕之后，该实例将会被销毁，所以不要在onReceiver()中执行耗时操作，也不要在里面创建子线程处理业务（因为可能子线程没处理完，接收者就被回收了，那么子线程也会跟着被回收掉）；正确的处理方法就是通过in调用activity或者service处理业务。

##### [3] BroadcastReceiver的注册

　　BroadcastReceiver的注册方式有且只有两种，一种是**静态注册**（推荐使用），另外一种是**动态注册**，广播接收者在注册后就开始监听系统或者应用之间发送的广播消息。

**接收短信广播示例**：

定义自己的BroadcastReceiver 类

```
public class MyBroadcastReceiver extends BroadcastReceiver {
 
// action 名称
String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED" ;
 
    public void onReceive(Context context, Intent intent) {
 
       if (intent.getAction().equals( SMS_RECEIVED )) {
           // 一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。
       }
    }
}
```

**静态方式**

　　在AndroidManifest.xml的application里面定义receiver并设置要接收的action。

```
< receiver android:name = ".MyBroadcastReceiver" > 

 < intent-filter android:priority = "777" >             
<action android:name = "android.provider.Telephony.SMS_RECEIVED" />
</ intent-filter > 

</ receiver >
```

　　这里的priority取值是-1000到1000，值越大优先级越高，同时注意加上系统接收短信的限权。

```
< uses-permission android:name ="android.permission.RECEIVE_SMS" />
```

　　静态注册的广播接收者是一个常驻在系统中的全局监听器，当你在应用中配置了一个静态的BroadcastReceiver，安装了应用后而无论应用是否处于运行状态，广播接收者都是已经常驻在系统中了。同时应用里的所有receiver都在清单文件里面，方便查看。要销毁掉静态注册的广播接收者，可以通过调用PackageManager将Receiver禁用。

**动态方式**

　　在Activity中声明BroadcastReceiver的扩展对象，在onResume中注册，onPause中卸载. 　　　

```
public class MainActivity extends Activity {
	MyBroadcastReceiver receiver;
	@Override
	 protected void onResume() {
		// 动态注册广播 (代码执行到这才会开始监听广播消息，并对广播消息作为相应的处理)
		receiver = new MyBroadcastReceiver();
		IntentFilter intentFilter = new IntentFilter( "android.provider.Telephony.SMS_RECEIVED" );
		registerReceiver( receiver , intentFilter);	
		super.onResume();
	}
	@Override
	protected void onPause() {  
		// 撤销注册 (撤销注册后广播接收者将不会再监听系统的广播消息)
		unregisterReceiver(receiver);
		super.onPause();
	}
}
```

**静态注册和动态注册的区别**

　　1、静态注册的广播接收者一经安装就常驻在系统之中，不需要重新启动唤醒接收者；动态注册的广播接收者随着应用的生命周期，由registerReceiver开始监听，由unregisterReceiver撤销监听，如果应用退出后，没有撤销已经注册的接收者应用应用将会报错。

　　2、当广播接收者通过intent启动一个activity或者service时，如果intent中无法匹配到相应的组件。动态注册的广播接收者将会导致应用报错 而静态注册的广播接收者将不会有任何报错，因为自从应用安装完成后，广播接收者跟应用已经脱离了关系。　

##### [4] 发送BroadcastReceiver

**发送广播主要有两种类型：**

**普通广播**：应用在需要通知各个广播接收者的情况下使用，如开机启动

使用方法：sendBroadcast()

```
Intent intent = new Intent("android.provider.Telephony.SMS_RECEIVED"); 
//通过intent传递少量数据
intent.putExtra("data", "finch"); 
// 发送普通广播
sendBroadcast(Intent); 
```

　　普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，所有满足条件的BroadcastReceiver 都会随机地执行其 onReceive() 方法。

 　　同级别接收是先后是随机的；级别低的收到广播；

 　　消息传递的效率比较高，并且无法中断广播的传播。

**有序广播**：应用在需要有特定拦截的场景下使用，如黑名单短信、电话拦截。　

使用方法：

　`sendOrderedBroadcast(intent, receiverPermission);`

　`receiverPermission` ：一个接收器必须持以接收您的广播。如果为 null ，不经许可的要求（一般都为null）。

```
//发送有序广播
 sendOrderedBroadcast(intent, null);
```

　　在有序广播中，我们可以在前一个广播接收者将处理好的数据传送给后面的广播接收者，也可以调用abortBroadcast()来终结广播的传播。

```
public void onReceive(Context arg0, Intent intent) {
　　//获取上一个广播的bundle数据
　　Bundle bundle = getResultExtras(true);//true：前一个广播没有结果时创建新的Bundle；false：不创建Bundle
　　bundle.putString("key", "777");
　　//将bundle数据放入广播中传给下一个广播接收者
　　setResultExtras(bundle);　
　　
　　//终止广播传给下一个广播接收者
　　abortBroadcast();
}
```

　　高级别的广播收到该广播后，可以决定把该广播是否截断掉。同级别接收是先后是随机的，如果先接收到的把广播截断了，同级别的例外的接收者是无法收到该广播。 　　

异步广播

使用方法：`sendStickyBroadcast()` ：

　　发出的Intent当接收Activity（动态注册）重新处于onResume状态之后就能重新接受到其Intent.（the Intent will be held to be re-broadcast to future receivers）。就是说sendStickyBroadcast发出的最后一个Intent会被保留，下次当Activity处于活跃的时候又会接受到它。

发这个广播需要权限：

```
<uses-permission android:name="android.permission.BROADCAST_STICKY" />
```

卸载该广播：

```
removeStickyBroadcast(intent);
```

　　在卸载之前该intent会保留，接收者在可接收状态都能获得。

**异步有序广播**

　　使用方法：`sendStickyOrderedBroadcast(intent, resultReceiver, scheduler, initialCode, initialData, initialExtras)`：

　　这个方法具有有序广播的特性也有异步广播的特性； 　　同时需要限权：

```
 <uses-permission android:name="android.permission.BROADCAST_STICKY" /> 
```

##### [5] 总结

- 静态广播接收的处理器是由PackageManagerService负责，当手机启动或者新安装了应用的时候，PackageManagerService会扫描手机中所有已安装的APP应用，将AndroidManifest.xml中有关注册广播的信息解析出来，存储至一个全局静态变量当中。
- 动态广播接收的处理器是由ActivityManagerService负责，当APP的服务或者进程起来之后，执行了注册广播接收的代码逻辑，即进行加载，最后会存储在一个另外的全局静态变量中。需要注意的是：

　　 1、 这个并非是一成不变的，当程序被杀死之后，已注册的动态广播接收器也会被移出全局变量，直到下次程序启动，再进行动态广播的注册，当然这里面的顺序也已经变更了一次。

　　 2、这里也并没完整的进行广播的排序，只记录的注册的先后顺序，并未有结合优先级的处理。

- 广播发出的时候，广播接收者接收的顺序如下：

　　１．当广播为**普通广播**时，有如下的接收顺序：

无视优先级

动态优先于静态 

同优先级的动态广播接收器，**先注册的大于后注册的**

同优先级的静态广播接收器，**先扫描的大于后扫描的**　

　　２．如果广播为**有序广播**，那么会将动态广播处理器和静态广播处理器合并在一起处理广播的消息，最终确定广播接收的顺序：

优先级高的先接收　 　　

同优先级的动静态广播接收器，**动态优先于静态** 　　

同优先级的动态广播接收器，**先注册的大于后注册的** 　　

同优先级的静态广播接收器，**先扫描的大于后扫描的**　

##### [6]一些常用的系统广播的action 和permission

- 开机启动

```
<action android:name="android.intent.action.BOOT_COMPLETED"/> 
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />  
```

- 网络状态

```
<action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>  
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/> 
```

　　　网络是否可用的方法：

```
  public static boolean isNetworkAvailable(Context context) {  
        ConnectivityManager mgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  
        NetworkInfo[] info = mgr.getAllNetworkInfo();  
        if (info != null) {  
            for (int i = 0; i < info.length; i++) {  
      if (info[i].getState() == NetworkInfo.State.CONNECTED) {  
                    return true;  
                }  
            }  
        }  
        return false;  
    } 
```

- 电量变化

```
<action android:name="android.intent.action.BATTERY_CHANGED"/>  
```

BroadcastReceiver 的onReceive方法：

```
public void onReceive(Context context, Intent intent) {  
        int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);  //当前电量  　
        
        int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1);    //总电量  
        int percent = currLevel * 100 / total;  
        Log.i(TAG, "battery: " + percent + "%");  
    }  
```

## 【异步任务机制之AsycTask】

> 在Android中实现异步任务机制有两种方式，**Handler**和**AsyncTask**。
>
> Handler已经在上一篇文章 [异步消息处理机制（Handler 、 Looper 、MessageQueue）源码解析](http://blog.csdn.net/amazing7/article/details/51424038#reply) 说过了。
>
> 本篇就说说AsyncTask的异步实现。

##### [1] 什么时候使用 AsnyncTask

　　在上一篇文章已经说了，主线程主要负责控制UI页面的显示、更新、交互等。  为了有更好的用户体验，UI线程中的操作要求越短越好。

　　我们把耗时的操作（例如网络请求、数据库操作、复杂计算）放到单独的子线程中操作，以避免主线程的阻塞。但是在子线程中不能更新ＵＩ界面，这时候需要使用handler。

　　但如果耗时的操作太多，那么我们需要开启太多的子线程，这就会给系统带来巨大的负担，随之也会带来性能方面的问题。在这种情况下我们就可以考虑使用类AsyncTask来异步执行任务，不需要子线程和handler，就可以完成异步操作和刷新UI。

　　**不要随意使用AsyncTask,除非你必须要与UI线程交互**.默认情况下使用Thread即可,要注意需要将线程优先级调低.AsyncTask适合处理短时间的操作,长时间的操作,比如下载一个很大的视频,这就需要你使用自己的线程来下载,不管是断点下载还是其它的.

##### [2] AsnyncTask原理

　　AsyncTask主要有二个部分：**一个是与主线程的交互，另一个就是线程的管理调度。**虽然可能多个AsyncTask的子类的实例，但是AsyncTask的内部Handler和ThreadPoolExecutor都是进程范围内共享的，其都是static的，也即属于类的，类的属性的作用范围是CLASSPATH，因为一个进程一个VM，所以是AsyncTask控制着进程范围内所有的子类实例。　

　　AsyncTask内部会创建一个进程作用域的线程池来管理要运行的任务，也就就是说当你调用了AsyncTask的execute()方法后，AsyncTask会把任务交给线程池，由线程池来管理创建Thread和运行Therad。

##### [3] AsyncTask介绍

　　Android的AsyncTask比Handler更轻量级一些（只是代码上轻量一些，而实际上要比handler更耗资源），适用于简单的异步处理。 Android之所以有Handler和AsyncTask，都是为了不阻塞主线程（UI线程），因为UI的更新只能在主线程中完成，因此异步处理是不可避免的。

　　**AsyncTask：**对线程间的通讯做了包装，是后台线程和UI线程可以简易通讯：后台线程执行异步任务，将result告知UI线程。

使用AsyncTask分为两步：　

①　继承AsyncTask类实现自己的类

```
public abstract class AsyncTask<Params, Progress, Result> {
```

> Params: 输入参数，对应excute()方法中传递的参数。如果不需要传递参数，则直接设为void即可。
>
> Progress：后台任务执行的百分比
>
> Result：返回值类型，和doInBackground（）方法的返回值类型保持一致。

②复写方法

最少要重写以下这两个方法：

- doInBackground(Params…)

　　在**子线程**（其他方法都在主线程执行）中执行比较耗时的操作，不能更新ＵＩ，可以在该方法中调用publishProgress(Progress…)来更新任务的进度。Progress方法是AsycTask中一个final方法只能调用不能重写。

- onPostExecute(Result)

　　使用在doInBackground 得到的结果处理操作UI， 在主线程执行，任务执行的结果作为此方法的参数返回。 　　 有时根据需求还要实现以下三个方法：

- onProgressUpdate(Progress…)

　　可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。

- onPreExecute()

　　这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。

- onCancelled()

　　用户调用取消时，要做的操作

##### [4] AsyncTask示例

按照上面的步骤定义自己的异步类：

```
public class MyTask extends AsyncTask<String, Integer, String> {  
    //执行的第一个方法用于在执行后台任务前做一些UI操作  
    @Override  
    protected void onPreExecute() {  
       
    }  
   
    //第二个执行方法,在onPreExecute()后执行，用于后台任务,不可在此方法内修改UI
    @Override  
    protected String doInBackground(String... params) {  
         //处理耗时操作
        return "后台任务执行完毕";  
    }  
      
   /*这个函数在doInBackground调用publishProgress(int i)时触发，虽然调用时只有一个参数  
    但是这里取到的是一个数组,所以要用progesss[0]来取值  
    第n个参数就用progress[n]来取值   */
    @Override  
    protected void onProgressUpdate(Integer... progresses) {  
    	//"loading..." + progresses[0] + "%"
        super.onProgressUpdate(progress);  
    }  
      
    /*doInBackground返回时触发，换句话说，就是doInBackground执行完后触发  
    这里的result就是上面doInBackground执行后的返回值，所以这里是"后台任务执行完毕"  */
    @Override  
    protected void onPostExecute(String result) { 
    	
    }  
      
    //onCancelled方法用于在取消执行中的任务时更改UI  
    @Override  
    protected void onCancelled() {  
    	
    }  
}
```

在主线程申明该类的对象，调用对象的execute（）函数开始执行。

```
MyTask ｔ= new MyTask();
t.execute();//这里没有参数
```

##### [5] 使用AsyncTask需要注意的地方

- AsnycTask内部的Handler需要和主线程交互，所以AsyncTask的实例必须在UI线程中创建
- AsyncTaskResult的doInBackground(mParams)方法执行异步任务运行在子线程中，其他方法运行在主线程中，可以操作UI组件。
- 一个AsyncTask任务只能被执行一次。
- 运行中可以随时调用AsnycTask对象的cancel(boolean)方法取消任务，如果成功，调用isCancelled()会返回true，并且不会执行 onPostExecute() 方法了，而是执行 onCancelled() 方法。
- 对于想要立即开始执行的异步任务，要么直接使用Thread，要么单独创建线程池提供给AsyncTask。默认的AsyncTask不一定会立即执行你的任务，除非你提供给他一个单独的线程池。如果不与主线程交互，直接创建一个Thread就可以了。

## 【Handler,Looper,MessageQueue关系】

##### [1] Handler的由来

　　当程序第一次启动的时候，Android会同时启动一条主线程（ Main Thread）来负责处理与UI相关的事件，我们叫做UI线程。

　　Android的UI操作并不是线程安全的（出于性能优化考虑），意味着如果多个线程并发操作UI线程，可能导致线程安全问题。

　　为了解决Android应用多线程问题—Android平台只允许UI线程修改Activity里的UI组建，就会导致新启动的线程无法改变界面组建的属性值。

　　**简单的说：**当主线程队列处理一个消息超过5秒,android 就会抛出一个 ANP(无响应)的异常,所以,我们需要把一些要处理比较长的消息,放在一个单独线程里面处理,把处理以后的结果,返回给主线程运行,就需要用的Handler来进行线程建的通信。

##### [2] Handler的作用

２.１　让线程延时执行

主要用到的两个方法：

- `final boolean	postAtTime(Runnable r, long uptimeMillis)`
- `final boolean	postDelayed(Runnable r, long delayMillis)`

２.２　让任务在其他线程中执行并返回结果

分为两个步骤：

- 在新启动的线程中发送消息

　　使用Handler对象的sendMessage()方法或者SendEmptyMessage()方法发送消息。

- 在主线程中获取处理消息

　　重写Handler类中处理消息的方法（void handleMessage(Message msg)），当新启动的线程发送消息时，消息发送到与之关联的MessageQueue。而Hanlder不断地从MessageQueue中获取并处理消息。

##### [3] Handler更新UI线程一般使用

　　

- 首先要进行Handler 申明，复写handleMessage方法( 放在主线程中)

```
private Handler handler = new Handler() {

		@Override
		public void handleMessage(Message msg) {
			// TODO 接收消息并且去更新UI线程上的控件内容
			if (msg.what == UPDATE) {
				// 更新界面上的textview
				tv.setText(String.valueOf(msg.obj));
			}
			super.handleMessage(msg);
		}
	};
```

- 子线程发送Message给ui线程表示自己任务已经执行完成，主线程可以做相应的操作了。

```
new Thread() {
			@Override
			public void run() {
				// TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值
				try {
					   //do something
						
						Message msg = new Message();
						msg.what = UPDATE;					
						msg.obj = "更新后的值" ;
						handler.sendMessage(msg);
					}
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}.start();
```

##### [4] Handler原理分析

4.1 　Handler的构造函数

①　public　Handler()

②　public　Handler(Callbackcallback)

③　public　Handler(Looperlooper)

④　public　Handler(Looperlooper, Callbackcallback) 　

- 第①个和第②个构造函数都没有传递Looper，这两个构造函数都将通过调用Looper.myLooper()获取当前线程绑定的Looper对象，然后将该Looper对象保存到名为mLooper的成员字段中。 　 　　下面来看①②个函数源码： 　　

```
113    public Handler() {
114        this(null, false);
115    }

127    public Handler(Callback callback) {
128        this(callback, false);
129    }

//他们会调用Handler的内部构造方法

188    public Handler(Callback callback, boolean async) {
189        if (FIND_POTENTIAL_LEAKS) {
190      final Class<? extends Handler> klass = getClass();
191      if ((klass.isAnonymousClass() ||klass.isMemberClass()
         || klass.isLocalClass()) &&
192                    (klass.getModifiers() & Modifier.STATIC) == 0) {
193                Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
194                    klass.getCanonicalName());
195            }
196        }
197//************************************
198        mLooper = Looper.myLooper();
199        if (mLooper == null) {
200            throw new RuntimeException(
201                "Can't create handler inside thread that has not called Looper.prepare()");
202        }
203        mQueue = mLooper.mQueue;
204        mCallback = callback;
205        mAsynchronous = async;
206    }
```

　　我们看到暗红色的重点部分：

　　通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过这个Looper实例获取了其中保存的MessageQueue（消息队列）。**每个Handler 对应一个Looper对象，产生一个MessageQueue** 　　

- 第③个和第④个构造函数传递了Looper对象，这两个构造函数会将该Looper保存到名为mLooper的成员字段中。 　　下面来看③④个函数源码：

```
136    public Handler(Looper looper) {
137        this(looper, null, false);
138    }　

147    public Handler(Looper looper, Callback callback) {
148        this(looper, callback, false);
149    }
//他们会调用Handler的内部构造方法

227    public Handler(Looper looper, Callback callback, boolean async) {
228        mLooper = looper;
229        mQueue = looper.mQueue;
230        mCallback = callback;
231        mAsynchronous = async;
232    }
```

- 第②个和第④个构造函数还传递了Callback对象，Callback是Handler中的内部接口，需要实现其内部的handleMessage方法，Callback代码如下:

```
80     public interface Callback {
81         public boolean More ...handleMessage(Message msg);
82     }
```

　　Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： 　　 　1. 向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法 　 　　 　2. 无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法 　 　　　 　　　也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。

4.2　Handle发送消息的几个方法源码

```
   public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }
   public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
        Message msg = Message.obtain();
        msg.what = what;
        return sendMessageDelayed(msg, delayMillis);
    }
 public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }
 public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
```

我们可以看出他们最后都调用了sendMessageAtTime（），然后返回了enqueueMessage方法，下面看一下此方法源码：

```
626    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
　　　　　　//把当前的handler作为msg的target属性
627        msg.target = this;
628        if (mAsynchronous) {
629            msg.setAsynchronous(true);
630        }
631        return queue.enqueueMessage(msg, uptimeMillis);
632    }
```

在该方法中有两件事需要注意：

1. msg.target = this

　　该代码将Message的target绑定为当前的Handler



1. queue.enqueueMessage 　　 　　变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。

过下图可以看到完整的方法调用顺序：

[![流程图](https://camo.githubusercontent.com/5c14304a7c981723bf57b3035dca0524c31e703f/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353136313235323435343737)](https://camo.githubusercontent.com/5c14304a7c981723bf57b3035dca0524c31e703f/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630353136313235323435343737)　

##### [5] Looper原理分析

　　我们一般在主线程申明Handler，有时我们需要继承Thread类实现自己的线程功能，当我们在里面申明Handler的时候会报错。其原因是主线程中已经实现了两个重要的Looper方法，下面看一看ActivityThread.java中main方法的源码：

```
public static void main(String[] args) {
            //......省略
5205        Looper.prepareMainLooper();//>
5206
5207        ActivityThread thread = new ActivityThread();
5208        thread.attach(false);
5209
5210        if (sMainThreadHandler == null) {
5211            sMainThreadHandler = thread.getHandler();
5212        }
5213
5214        AsyncTask.init();
5215
5216        if (false) {
5217            Looper.myLooper().setMessageLogging(new
5218   LogPrinter(Log.DEBUG, "ActivityThread"));
5219        }
5220
5221        Looper.loop();//>
5222
5223        throw new RuntimeException("Main thread loop unexpectedly exited");
5224    }
5225}
```

5.1　首先看prepare()方法

　　

```
70     public static void prepare() {
71         prepare(true);
72     }
73 
74     private static void prepare(boolean quitAllowed) {
　　　　　//证了一个线程中只有一个Looper实例
75         if (sThreadLocal.get() != null) {
76             throw new RuntimeException("Only one Looper may be created per thread");
77         }
78         sThreadLocal.set(new Looper(quitAllowed));
79     }
```

该方法会调用Looper构造函数同时实例化出MessageQueue和当前thread.

```
186    private Looper(boolean quitAllowed) {
187        mQueue = new MessageQueue(quitAllowed);
188        mThread = Thread.currentThread();
189    } 

182    public static MessageQueue myQueue() {
183        return myLooper().mQueue;
184    }
```

　　prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定。（不清楚的可以查看　[ThreadLocal的使用规则和源码分析](http://blog.csdn.net/amazing7/article/details/51313851)）　

５.2 　loop()方法　　

```
109    public static void loop() {
110        final Looper me = myLooper();
111        if (me == null) {
112            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
113        }
114        final MessageQueue queue = me.mQueue;
115
118        Binder.clearCallingIdentity();
119        final long ident = Binder.clearCallingIdentity();
120
121        for (;;) {
122            Message msg = queue.next(); // might block
123            if (msg == null) {
124               
125                return;
126            }
127
129            Printer logging = me.mLogging;
130            if (logging != null) {
131                logging.println(">>>>> Dispatching to " + msg.target + " " +
132                        msg.callback + ": " + msg.what);
133            }
//重点****
135            msg.target.dispatchMessage(msg);
136
137            if (logging != null) {
138                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
139            }
140
142            // identity of the thread wasn't corrupted.
143            final long newIdent = Binder.clearCallingIdentity();
144            if (ident != newIdent) {
145                Log.wtf(TAG, "Thread identity changed from 0x"
146                        + Long.toHexString(ident) + " to 0x"
147                        + Long.toHexString(newIdent) + " while dispatching to "
148                        + msg.target.getClass().getName() + " "
149                        + msg.callback + " what=" + msg.what);
150            }
151
152            msg.recycleUnchecked();
153        }
154    }
```

　　首先looper对象不能为空，就是说loop()方法调用必须在prepare()方法的后面。

　Looper一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。

Handler的dispatchMessage的源码如下：

```
93     public void dispatchMessage(Message msg) {
94         if (msg.callback != null) {
95             handleCallback(msg);
96         } else {
97             if (mCallback != null) {
98                 if (mCallback.handleMessage(msg)) {
99                     return;
100                }
101            }
102            handleMessage(msg);
103        }
104    }
```

　　我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。

##### [6] 如何在子线程中使用Handler

　　Handler本质是从当前的线程中获取到Looper来监听和操作MessageQueue，当其他线程执行完成后回调当前线程。

　　子线程需要先prepare（）才能获取到Looper的，是因为在子线程只是一个普通的线程，其ThreadLoacl中没有设置过Looper，所以会抛出异常，而在Looper的prepare（）方法中sThreadLocal.set(new Looper())是设置了Looper的。

６.1　实例代码

　定义一个类实现Runnable接口或继承Thread类（一般不继承）。

```
    class Rub implements Runnable {  
  
        public Handler myHandler;  
        // 实现Runnable接口的线程体 
        @Override  
        public void run() {  
        	
         /*①、调用Looper的prepare()方法为当前线程创建Looper对象并，
          创建Looper对象时，它的构造器会自动的创建相对应的MessageQueue*/
            Looper.prepare();  
            
            /*.②、创建Handler子类的实例，重写HandleMessage()方法，该方法处理除当前线程以外线程的消息*/
             myHandler = new Handler() {  
                @Override  
                public void handleMessage(Message msg) {  
                    String ms = "";  
                    if (msg.what == 0x777) {  
                     
                    }  
                }  
  
            };  
            //③、调用Looper的loop()方法来启动Looper让消息队列转动起来
            Looper.loop();  
        }
    }
```

注意分成三步：　

１．调用Looper的prepare()方法为当前线程创建Looper对象，创建Looper对象时，它的构造器会创建与之配套的MessageQueue。 　

２．有了Looper之后，创建Handler子类实例，重写HanderMessage()方法，该方法负责处理来自于其他线程的消息。 　

３．调用Looper的looper()方法启动Looper。

　　然后使用这个handler实例在任何其他线程中发送消息，最终处理消息的代码都会在你创建Handler实例的线程中运行。

##### [7] 总结  　　

**Handler**:

- 发送消息，它能把消息发送给Looper管理的MessageQueue。
- 处理消息，并负责处理Looper分给它的消息。
- Handler的构造方法，会首先得到当前线程中保存的Looper实例，进而与Looper实例中的MessageQueue想关联。　
- Handler的sendMessage方法，会给msg的target赋值为handler自身，然后加入MessageQueue中。　　 　

**Looper**:

- 每个线程只有一个Looper，它负责管理对应的MessageQueue，会不断地从MessageQueue取出消息，并将消息分给对应的Hanlder处理。 　
- 主线程中，系统已经初始化了一个Looper对象，因此可以直接创建Handler即可，就可以通过Handler来发送消息、处理消息。 程序自己启动的子线程，程序必须自己创建一个Looper对象，并启动它，调用`Looper.prepare()`方法。
- prapare()方法：保证每个线程最多只有一个Looper对象。 　
- looper()方法：启动Looper，使用一个死循环不断取出MessageQueue中的消息，并将取出的消息分给对应的Handler进行处理。 　

**MessageQueue**:

- 由Looper负责管理，它采用先进先出的方式来管理Message。　

**Message**:

- Handler接收和处理的消息对象。

##### [8]补充：handler运行机制

**![img](https://img-blog.csdn.net/20180818235134804?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3R0eHM5OTk4OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)** 

 

 Handler机制也可叫异步消息机制，它主要由4个部分组成：**Message,Handler,MessageQueue,Looper**,在上面图中我们已经有了大致印象,接下来我们对4个成员进行着重的了解：

**1.Message**
  Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。使用Message的arg1和arg2便可携带int数据，使用obj便可携带Object类型数据。

**2.Handler**
  Handler顾名思义就是处理者的意思，它只要用于**在子线程发送消息对象Message**,**在UI线程处理消息对象Message**，在子线程调用sendMessage方法发送消息对象Message，而发送的消息经过一系列地辗转之后最终会被传递到Handler的handleMessage方法中,最终在handleMessage方法中消息对象Message被处理。

**3.MessageQueue**
  MessageQueue就是消息队列的意思,它只要用于存放所有通过Handler发送过来的消息。这部分消息会一直存放于消息队列当中，等待被处理。每个线程中只会有一个MessageQueue对象，请牢记这句话。其实从字面上就可以看出，MessageQueue底层数据结构是队列，而且这个队列只存放Message对象。

**4.Looper**
  Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当MesssageQueue中存在一条消息，Looper就会将这条消息取出，并将它传递到Handler的handleMessage()方法中。每个线程只有一个Looper对象。

  了解了上述Handler机制的4个成员后，我们再来把思路理一遍：**首先在UI线程我们创建了一个Handler实例对象，无论是匿名内部类还是自定义类生成的Handler实例对象，我们都需要对handleMessage方法进行重写，在handleMessage方法中我们可以通过参数msg来写接受消息过后UIi线程的逻辑处理，接着我们创建子线程，在子线程中需要更新UI的时候，新建一个Message对象，并且将消息的数据记录在这个消息对象Message的内部，比如arg1,arg2,obj等，然后通过前面的Handler实例对象调用sendMessge方法把这个Message实例对象发送出去，之后这个消息会被存放于MessageQueue中等待被处理，此时MessageQueue的管家Looper正在不停的把MessageQueue存在的消息取出来，通过回调dispatchMessage方法将消息传递给Handler的handleMessage方法，最终前面提到的消息会被Looper从MessageQueue中取出来传递给handleMessage方法，最终得到处理。这就是Handler机制整个的工作流程。应该都差不多懂了吧，感觉我写的很接地气啊。**

## 【Android数据存储的五种方式】

##### [1] 概述

　　Android提供了5种方式来让用户保存持久化应用程序数据。根据自己的需求来做选择，比如数据是否是应用程序私有的，是否能被其他程序访问，需要多少数据存储空间等，分别是：　 　　 

①　使用SharedPreferences存储数据　

②　文件存储数据

③　 SQLite数据库存储数据

④　使用ContentProvider存储数据

⑤　网络存储数据　

Android提供了一种方式来暴露你的数据（甚至是私有数据）给其他应用程序 - ContentProvider。它是一个可选组件，可公开读写你应用程序数据。

##### [2] SharedPreferences存储

　　SharedPreference类提供了一个总体框架，使您可以保存和检索的任何基本数据类型（ boolean, float, int, long, string）的持久键-值对（基于XML文件存储的“key-value”键值对数据）。

　　通常用来存储程序的一些配置信息。其存储在“data/data/程序包名/shared_prefs目录下。

　　xml 处理时Dalvik会通过自带底层的本地XML Parser解析，比如XMLpull方式，这样对于内存资源占用比较好。　

**2.1** 　我们可以通过以下两种方法获取SharedPreferences对象（通过Context）：

> ①　getSharedPreferences (String name, int mode)

　　当我们有多个SharedPreferences的时候，根据第一个参数name获得相应的SharedPreferences对象。

> ②　getPreferences (int mode)

　　如果你的Activity中只需要一个SharedPreferences的时候使用。

这里的mode有四个选项：

```
Context.MODE_PRIVATE
```

　　该SharedPreferences数据只能被本应用程序读、写。

```
Context.MODE_WORLD_READABLE
```

　　该SharedPreferences数据能被其他应用程序读，但不能写。

```
Context.MODE_WORLD_WRITEABLE
```

　　该SharedPreferences数据能被其他应用程序读和写。

```
Context.MODE_MULTI_PROCESS
```

　　sdk2.3后添加的选项，当多个进程同时读写同一个SharedPreferences时它会检查文件是否修改。

**2.2** 　向Shared Preferences中**写入值** 　 首先要通过 SharedPreferences.Editor获取到Editor对象；

然后通过Editor的putBoolean() 或 putString()等方法存入值；

最后调用Editor的commit()方法提交；

```
//Use 0 or MODE_PRIVATE for the default operation 
SharedPreferences settings = getSharedPreferences("fanrunqi", 0);
SharedPreferences.Editor editor = settings.edit();
editor.putBoolean("isAmazing", true); 

// 提交本次编辑
editor.commit();
```

同时Edit还有两个常用的方法：

> editor.remove(String key) ：下一次commit的时候会移除key对应的键值对
>
> editor.clear()：移除所有键值对

**2.3** 　从Shared Preferences中**读取值**

　　读取值使用 SharedPreference对象的getBoolean()或getString()等方法就行了（没Editor 啥子事）。

```
SharedPreferences settings = getSharedPreferences("fanrunqi", 0);
boolean isAmazing= settings.getBoolean("isAmazing",true);
```

**2.４** 　Shared Preferences的优缺点

　　可以看出来Preferences是很轻量级的应用，使用起来也很方便，简洁。但存储数据类型比较单一（只有基本数据类型），无法进行条件查询，只能在不复杂的存储需求下使用，比如保存配置信息等。

##### [3] 文件数据存储

**3.1 使用内部存储**

　　当文件被保存在内部存储中时，默认情况下，文件是应用程序私有的，其他应用不能访问。当用户卸载应用程序时这些文件也跟着被删除。

　　文件默认存储位置：/data/data/包名/files/文件名。

**3.1.1 创建和写入一个内部存储的私有文件：**

①　调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。

②　通过FileOutputStream对象的write()函数写入数据。

③　 FileOutputStream对象的close ()函数关闭流。

例如：

```
		String FILENAME = "a.txt";
		String string = "fanrunqi";

		try {
			FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);
			fos.write(string.getBytes());
			fos.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
```

在 `openFileOutput(String name, int mode)`方法中

- name参数:　用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。
- mode参数：用于指定操作模式，分为四种：

> Context.MODE_PRIVATE = 0

　　为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。

> Context.MODE_APPEND = 32768

　　该模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。　

> Context.MODE_WORLD_READABLE = 1

　　表示当前文件可以被其他应用读取。

> MODE_WORLD_WRITEABLE

　　表示当前文件可以被其他应用写入。

**3.1.2 读取一个内部存储的私有文件：**

① 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。

② 使用流对象的 read()方法读取字节

③ 调用流的close()方法关闭流

例如：

```
	String FILENAME = "a.txt";
		try {
            FileInputStream inStream = openFileInput(FILENAME);
            int len = 0;
            byte[] buf = new byte[1024];
            StringBuilder sb = new StringBuilder();
            while ((len = inStream.read(buf)) != -1) {
                sb.append(new String(buf, 0, len));
            }
            inStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        } 
```

其他一些经常用到的方法：

- getFilesDir()：　得到内存储文件的绝对路径
- getDir()：　在内存储空间中**创建**或**打开一个已经存在**的目录
- deleteFile()：　删除保存在内部存储的文件。　　
- fileList()：　返回当前由应用程序保存的文件的数组（内存储目录下的全部文件）。　

**3.1.３　保存编译时的静态文件**

　　如果你想在应用编译时保存静态文件，应该把文件保存在项目的　**res/raw/**　目录下，你可以通过 openRawResource()方法去打开它（传入参数R.raw.filename），这个方法返回一个 InputStream流对象你可以读取文件但是不能修改原始文件。

```
InputStream is = this.getResources().openRawResource(R.raw.filename);
```

**3.1.４　保存内存缓存文件**

　　有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir（）去打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。

　　当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。

**3.２ 使用外部存储（sdcard）**

　　因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：

**3.2.1　添加外部存储访问限权**

　 　　首先，要在AndroidManifest.xml中加入访问SDCard的权限，如下:

```
　<!-- 在SDCard中创建与删除文件权限 --> 
    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/> 

   <!-- 往SDCard写入数据权限 --> 
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```

**3.2.２　检测外部存储的可用性**

　　在使用外部存储时我们需要检测其状态，它可能被连接到计算机、丢失或者只读等。下面代码将说明如何检查状态：

```
//获取外存储的状态
String state = Environment.getExternalStorageState();
if (Environment.MEDIA_MOUNTED.equals(state)) {
    // 可读可写
    mExternalStorageAvailable = mExternalStorageWriteable = true;
} else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
    // 可读
} else {
    // 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  
}
```

**3.2.3　访问外部存储器中的文件**

**１、如果 API 版本大于或等于８**，使用

> getExternalFilesDir (String type)

　　该方法打开一个外存储目录，此方法需要一个类型，指定你想要的子目录，如类型参数DIRECTORY_MUSIC和 DIRECTORY_RINGTONES（传null就是你应用程序的文件目录的根目录）。通过指定目录的类型，确保Android的媒体扫描仪将扫描分类系统中的文件（例如，铃声被确定为铃声）。如果用户卸载应用程序，这个目录及其所有内容将被删除。

例如：

```
File file = new File(getExternalFilesDir(null), "fanrunqi.jpg");
```

**２、如果API 版本小于 8** （7或者更低）

> getExternalStorageDirectory ()

通过该方法打开外存储的根目录，你应该在以下目录下写入你的应用数据，这样当卸载应用程序时该目录及其所有内容也将被删除。

```
/Android/data/<package_name>/files/
```

读写数据：

```
if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){  
		    File sdCardDir = Environment.getExternalStorageDirectory();//获取SDCard目录  "/sdcard"        

		       File saveFile = new File(sdCardDir,"a.txt"); 
		        
		       //写数据
		        try {
		        	FileOutputStream fos= new FileOutputStream(saveFile); 
		        	fos.write("fanrunqi".getBytes()); 
					fos.close();
				} catch (Exception e) {
					e.printStackTrace();
				} 
				
				//读数据
				 try {
		        	FileInputStream fis= new FileInputStream(saveFile); 
		        	int len =0;
		        	byte[] buf = new byte[1024];
		        	StringBuffer sb = new StringBuffer();
		        	while((len=fis.read(buf))!=-1){
		        		sb.append(new String(buf, 0, len));
		        	}
		        	fis.close();
				} catch (Exception e) {
					e.printStackTrace();
				}  
		}
```

　　我们也可以在　/Android/data/package_name/cache/目录下做外部缓存。

部分翻译于：[android-data-storage](http://www.android-doc.com/guide/topics/data/data-storage.html)

##### [4]  网络存储数据

**HttpUrlConnection**

　　HttpUrlConnection是Java.net包中提供的API，我们知道Android SDK是基于Java的，所以当然优先考虑HttpUrlConnection这种最原始最基本的API，其实大多数开源的联网框架基本上也是基于JDK的HttpUrlConnection进行的封装罢了，掌握HttpUrlConnection需要以下几个步骤： 　　 1、将访问的路径转换成URL。

> URL url = new URL(path);

2、通过URL获取连接。

> HttpURLConnection conn = (HttpURLConnection) url.openConnection();

3、设置请求方式。

> conn.setRequestMethod(GET);

4、设置连接超时时间。

> conn.setConnectTimeout(5000);

5、设置请求头的信息。

> conn.setRequestProperty(User-Agent, Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0));

7、针对不同的响应码，做不同的操作（请求码200，表明请求成功，获取返回内容的输入流）

工具类：

```
public class StreamTools {
	/**
	 * 将输入流转换成字符串
	 * 
	 * @param is
	 *            从网络获取的输入流
	 * @return
	 */
	public static String streamToString(InputStream is) {
		try {
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			byte[] buffer = new byte[1024];
			int len = 0;
			while ((len = is.read(buffer)) != -1) {
				baos.write(buffer, 0, len);
			}
			baos.close();
			is.close();
			byte[] byteArray = baos.toByteArray();
			return new String(byteArray);
		} catch (Exception e) {
			Log.e(tag, e.toString());
			return null;
		}
	}
}
```

**HttpUrlConnection发送GET请求**

```
public static String loginByGet(String username, String password) {
		String path = http://192.168.0.107:8080/WebTest/LoginServerlet?username= + username + &password= + password;
		try {
			URL url = new URL(path);
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setConnectTimeout(5000);
			conn.setRequestMethod(GET);
			int code = conn.getResponseCode();
			if (code == 200) {
				InputStream is = conn.getInputStream(); // 字节流转换成字符串
				return StreamTools.streamToString(is);
			} else {
				return 网络访问失败;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return 网络访问失败;
		}
	}
```

HttpUrlConnection发送POST请求

```
public static String loginByPost(String username, String password) {
		String path = http://192.168.0.107:8080/WebTest/LoginServerlet;
		try {
			URL url = new URL(path);
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			conn.setConnectTimeout(5000);
			conn.setRequestMethod(POST);
			conn.setRequestProperty(Content-Type, application/x-www-form-urlencoded);
			String data = username= + username + &password= + password;
			conn.setRequestProperty(Content-Length, data.length() + );
			// POST方式，其实就是浏览器把数据写给服务器
			conn.setDoOutput(true); // 设置可输出流
			OutputStream os = conn.getOutputStream(); // 获取输出流
			os.write(data.getBytes()); // 将数据写给服务器
			int code = conn.getResponseCode();
			if (code == 200) {
				InputStream is = conn.getInputStream();
				return StreamTools.streamToString(is);
			} else {
				return 网络访问失败;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return 网络访问失败;
		}
	}
```

**HttpClient**

　　HttpClient是开源组织Apache提供的Java请求网络框架，其最早是为了方便Java服务器开发而诞生的，是对JDK中的HttpUrlConnection各API进行了封装和简化，提高了性能并且降低了调用API的繁琐，Android因此也引进了这个联网框架，我们再不需要导入任何jar或者类库就可以直接使用，值得注意的是Android官方已经宣布不建议使用HttpClient了。

**HttpClient发送GET请求**

1、 创建HttpClient对象

2、创建HttpGet对象，指定请求地址（带参数）

3、使用HttpClient的execute(),方法执行HttpGet请求，得到HttpResponse对象

4、调用HttpResponse的getStatusLine().getStatusCode()方法得到响应码

5、调用的HttpResponse的getEntity().getContent()得到输入流，获取服务端写回的数据

```
public static String loginByHttpClientGet(String username, String password) {
		String path = http://192.168.0.107:8080/WebTest/LoginServerlet?username=
				+ username + &password= + password;
		HttpClient client = new DefaultHttpClient(); // 开启网络访问客户端
		HttpGet httpGet = new HttpGet(path); // 包装一个GET请求
		try {
			HttpResponse response = client.execute(httpGet); // 客户端执行请求
			int code = response.getStatusLine().getStatusCode(); // 获取响应码
			if (code == 200) {
				InputStream is = response.getEntity().getContent(); // 获取实体内容
				String result = StreamTools.streamToString(is); // 字节流转字符串
				return result;
			} else {
				return 网络访问失败;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return 网络访问失败;
		}
	}
```

**HttpClient发送POST请求**

1，创建HttpClient对象

2，创建HttpPost对象，指定请求地址

3，创建List，用来装载参数

4，调用HttpPost对象的setEntity()方法，装入一个UrlEncodedFormEntity对象，携带之前封装好的参数

5，使用HttpClient的execute()方法执行HttpPost请求，得到HttpResponse对象

6， 调用HttpResponse的getStatusLine().getStatusCode()方法得到响应码

7， 调用的HttpResponse的getEntity().getContent()得到输入流，获取服务端写回的数据

```
public static String loginByHttpClientPOST(String username, String password) {
		String path = http://192.168.0.107:8080/WebTest/LoginServerlet;
		try {
			HttpClient client = new DefaultHttpClient(); // 建立一个客户端
			HttpPost httpPost = new HttpPost(path); // 包装POST请求
			// 设置发送的实体参数
			List parameters = new ArrayList();
			parameters.add(new BasicNameValuePair(username, username));
			parameters.add(new BasicNameValuePair(password, password));
			httpPost.setEntity(new UrlEncodedFormEntity(parameters, UTF-8));
			HttpResponse response = client.execute(httpPost); // 执行POST请求
			int code = response.getStatusLine().getStatusCode();
			if (code == 200) {
				InputStream is = response.getEntity().getContent();
				String result = StreamTools.streamToString(is);
				return result;
			} else {
				return 网络访问失败;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return 访问网络失败;
		}
	}
```

参考：

　　[Android开发请求网络方式详解](http://www.2cto.com/kf/201501/368943.html)

**Android提供的其他网络访问框架**

　　HttpClient和HttpUrlConnection的两种网络访问方式编写网络代码，需要自己考虑很多，获取数据或许可以，但是如果要将手机本地数据上传至网络，根据不同的web端接口，需要组织不同的数据内容上传，给手机端造成了很大的工作量。 　　 　　目前有几种快捷的网络开发开源框架，给我们提供了非常大的便利。下面是这些项目Github地址，有文档和Api说明。 　　 [android-async-http](https://github.com/loopj/android-async-http)　

[http-request](https://github.com/kevinsawicki/http-request)

[okhttp](https://github.com/square/okhttp)

##### [5] SQLite数据库存储数据

　　 　　前面的文章[ SQLite的使用入门](http://blog.csdn.net/amazing7/article/details/51375012)已经做了详细说明，这里就不在多说了。

##### [6] 使用ContentProvider存储数据

　　同样可以查看　[ContentProvider实例详解](http://blog.csdn.net/amazing7/article/details/51324022)

## 【recyclerView和ListView的异同】

------

- ViewHolder是用来保存视图引用的类，无论是ListView亦或是RecyclerView。只不过在ListView中，ViewHolder需要自己来定义，且这只是一种推荐的使用方式，不使用当然也可以，这不是必须的。只不过不使用ViewHolder的话，ListView每次getView的时候都会调用findViewById(int)，这将导致ListView性能展示迟缓。而在RecyclerView中使用RecyclerView.ViewHolder则变成了必须，尽管实现起来稍显复杂，但它却解决了ListView面临的上述不使用自定义ViewHolder时所面临的问题。

- 我们知道ListView只能在垂直方向上滚动，Android API没有提供ListView在水平方向上面滚动的支持。或许有多种方式实现水平滑动，但是请相信我，ListView并不是设计来做这件事情的。但是RecyclerView相较于ListView，在滚动上面的功能扩展了许多。它可以支持多种类型列表的展示要求，主要如下：

  1. LinearLayoutManager，可以支持水平和竖直方向上滚动的列表。
  2. StaggeredGridLayoutManager，可以支持交叉网格风格的列表，类似于瀑布流或者Pinterest。
  3. GridLayoutManager，支持网格展示，可以水平或者竖直滚动，如展示图片的画廊。

- 列表动画是一个全新的、拥有无限可能的维度。起初的Android API中，删除或添加item时，item是无法产生动画效果的。后面随着Android的进化，Google的Chat Hasse推荐使用ViewPropertyAnimator属性动画来实现上述需求。 相比较于ListView，RecyclerView.ItemAnimator则被提供用于在RecyclerView添加、删除或移动item时处理动画效果。同时，如果你比较懒，不想自定义ItemAnimator，你还可以使用DefaultItemAnimator。

- ListView的Adapter中，getView是最重要的方法，它将视图跟position绑定起来，是所有神奇的事情发生的地方。同时我们也能够通过registerDataObserver在Adapter中注册一个观察者。RecyclerView也有这个特性，RecyclerView.AdapterDataObserver就是这个观察者。ListView有三个Adapter的默认实现，分别是ArrayAdapter、CursorAdapter和SimpleCursorAdapter。然而，RecyclerView的Adapter则拥有除了内置的内DB游标和ArrayList的支持之外的所有功能。RecyclerView.Adapter的实现的，我们必须采取措施将数据提供给Adapter，正如BaseAdapter对ListView所做的那样。

- 在ListView中如果我们想要在item之间添加间隔符，我们只需要在布局文件中对ListView添加如下属性即可：

  ```
    android:divider="@android:color/transparent"
    android:dividerHeight="5dp"
  ```

- ListView通过AdapterView.OnItemClickListener接口来探测点击事件。而RecyclerView则通过RecyclerView.OnItemTouchListener接口来探测触摸事件。它虽然增加了实现的难度，但是却给予开发人员拦截触摸事件更多的控制权限。

- ListView可以设置选择模式，并添加MultiChoiceModeListener，如下所示：

```
listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
listView.setMultiChoiceModeListener(new MultiChoiceModeListener() {
public boolean onCreateActionMode(ActionMode mode, Menu menu) { ... }
public void onItemCheckedStateChanged(ActionMode mode, int position,
long id, boolean checked) { ... }
    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_item_delete_crime:
            CrimeAdapter adapter = (CrimeAdapter)getListAdapter();
            CrimeLab crimeLab = CrimeLab.get(getActivity());
            for (int i = adapter.getCount() - 1; i >= 0; i--) {
                if (getListView().isItemChecked(i)) {
                    crimeLab.deleteCrime(adapter.getItem(i));
                }
          }
        mode.finish();
        adapter.notifyDataSetChanged();
        return true;
        default:
            return false;
}
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) { ... }
    public void onDestroyActionMode(ActionMode mode) { ... }
});
而RecyclerView则没有此功能。
```

http://www.cnblogs.com/littlepanpc/p/4497290.html

## 【Android事件分发机制】

> 在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。

##### [1] 涉及到事件响应的常用方法构成

　　用户在手指与屏幕接触过程中通过MotionEvent对象产生一系列事件，它有四种状态： 　　

- MotionEvent.ACTION_DOWN　：手指按下屏幕的瞬间（一切事件的开始）
- MotionEvent.ACTION_MOVE　：手指在屏幕上移动
- MotionEvent.ACTION_UP　：手指离开屏幕瞬间
- MotionEvent.ACTION_CANCEL 　：取消手势，一般由程序产生，不会由用户产生

　　Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。

　　android 事件响应机制是先 **分发**（先由外部的View接收，然后依次传递给其内层的最小View）再 **处理** （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。

　　复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。

##### [2] android事件处理涉及到的三个重要函数

> **事件分发：public boolean dispatchTouchEvent(MotionEvent ev)**

　　　当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。 　　

- return true  ：表示该View内部消化掉了所有事件。
- return false  ：事件在本层不再继续进行分发，并交由**上层**控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　
- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理

> **事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)**

- return true  ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；
- return false  ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　
- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。

> **事件响应：public boolean onTouchEvent(MotionEvent ev)**

　　在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。

　

- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；
- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　
- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。

> 从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。

[![这里写图片描述](https://camo.githubusercontent.com/d0cf3f58f4a42af93085a1b9ab45baa5a45450a1/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343238313631313034333339)](https://camo.githubusercontent.com/d0cf3f58f4a42af93085a1b9ab45baa5a45450a1/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343238313631313034333339)

（图来自网络）

##### [3] View源码分析

　　Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。 　　 　　看View重要函数部分源码：

```
public boolean dispatchTouchEvent(MotionEvent event) {
//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。

    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&
            mOnTouchListener.onTouch(this, event)) {
  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法
        return true;
    }
    return onTouchEvent(event);
}
```

　首先进行三个条件的判断：

（1）查看是否给button设置了OnTouchListener()事件；

（2）控件是否Enable；（控件默认都是enable的）

（3）button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；

　如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。

```
 public boolean onTouchEvent(MotionEvent event) {
    ...
 
   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。
 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／
 
    if (((viewFlags & CLICKABLE) == CLICKABLE ||  
            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_UP:
                ...
                            if (!post(mPerformClick)) {
                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法
                            }
                 ...
                break;
 
            case MotionEvent.ACTION_DOWN:
               ...
                break;
 
            case MotionEvent.ACTION_CANCEL:
                ...
                break;
 
            case MotionEvent.ACTION_MOVE:
               ...
                break;
        }
        return true;
    }
 
    return false;
}
public boolean performClick() {
    ...
 ／／
    if (li != null && li.mOnClickListener != null) {
        ...
        li.mOnClickListener.onClick(this);
        return true;
    }
 
    return false;
}
 public void setOnClickListener(OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}
```

　　

> 只有我们注册OnTouchListener时重写的 onTouch()方法中
>
> 返回false  —> 执行onTouchEvent方法 —>  导致onClick()回调方法执行　

返回true —> onTouchEvent方法不执行 —>  导致onClick()回调方法不会执行

##### [4] ViewGroup源码分析

　　Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。

　　 部分源码：

```
public boolean dispatchTouchEvent(MotionEvent ev) {  
       final int action = ev.getAction();  
       final float xf = ev.getX();  
       final float yf = ev.getY();  
       final float scrolledXFloat = xf + mScrollX;  
       final float scrolledYFloat = yf + mScrollY;  
       final Rect frame = mTempRect;  
  
       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  
       //来改变disallowIntercept的值  
       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  
  
       //这里是ACTION_DOWN的处理逻辑  
       if (action == MotionEvent.ACTION_DOWN) {  
        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  
           if (mMotionTarget != null) {  
               mMotionTarget = null;  
           }  
  
           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  
           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点
               ev.setAction(MotionEvent.ACTION_DOWN);  
               final int scrolledXInt = (int) scrolledXFloat;  
               final int scrolledYInt = (int) scrolledYFloat;  
               final View[] children = mChildren;  
               final int count = mChildrenCount;  
               //遍历其子View  
               for (int i = count - 1; i >= 0; i--) {  //第二点
                   final View child = children[i];  
                     
                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  
                   //可以接受到Touch事件  
                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  
                           || child.getAnimation() != null) {  
                    //获取子View的位置范围  
                       child.getHitRect(frame);  
                         
                       //如Touch到屏幕上的点在该子View上面  
                       if (frame.contains(scrolledXInt, scrolledYInt)) {  
                           // offset the event to the view's coordinate system  
                           final float xc = scrolledXFloat - child.mLeft;  
                           final float yc = scrolledYFloat - child.mTop;  
                           ev.setLocation(xc, yc);  
                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
                             
                           //调用该子View的dispatchTouchEvent()方法  
                           if (child.dispatchTouchEvent(ev))  {  
                               // 如果child.dispatchTouchEvent(ev)返回true表示  
                            //该事件被消费了，设置mMotionTarget为该子View  
                               mMotionTarget = child;  
                               //直接返回true  
                               return true;  
                           }  
                           // The event didn't get handled, try the next view.  
                           // Don't reset the event's location, it's not  
                           // necessary here.  
                       }  
                   }  
               }  
           }  
       }  
  
       //判断是否为ACTION_UP或者ACTION_CANCEL  
       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
               (action == MotionEvent.ACTION_CANCEL);  
  
       if (isUpOrCancel) {  
           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  
        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  
        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  
        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  
           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  
       }  
  
       // The event wasn't an ACTION_DOWN, dispatch it to our target if  
       // we have one.  
       final View target = mMotionTarget;  
       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  
       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  
       if (target == null) {  
           // We don't have a target, this means we're handling the  
           // event as a regular view.  
           ev.setLocation(xf, yf);  
           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
               ev.setAction(MotionEvent.ACTION_CANCEL);  
               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           }  
           return super.dispatchTouchEvent(ev);  
       }  
  
       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  
       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  
       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  
       //表示消费了此Touch事件  
       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  
           final float xc = scrolledXFloat - (float) target.mLeft;  
           final float yc = scrolledYFloat - (float) target.mTop;  
           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           ev.setAction(MotionEvent.ACTION_CANCEL);  
           ev.setLocation(xc, yc);  
             
           if (!target.dispatchTouchEvent(ev)) {  
           }  
           // clear the target  
           mMotionTarget = null;  
           // Don't dispatch this event to our own view, because we already  
           // saw it when intercepting; we just want to give the following  
           // event to the normal onTouchEvent().  
           return true;  
       }  
  
       if (isUpOrCancel) {  
           mMotionTarget = null;  
       }  
  
       // finally offset the event to the target's coordinate system and  
       // dispatch the event.  
       final float xc = scrolledXFloat - (float) target.mLeft;  
       final float yc = scrolledYFloat - (float) target.mTop;  
       ev.setLocation(xc, yc);  
  
       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
           ev.setAction(MotionEvent.ACTION_CANCEL);  
           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           mMotionTarget = null;  
       }  
  
       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  
       return target.dispatchTouchEvent(ev);  
   }
```

> 1、dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）

> 2、onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理

> 3、onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失

　　

##### [5] 总结

- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　
- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。
- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true);  阻止ViewGroup对其MOVE或者UP事件进行拦截；　　
- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　
- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。
- ViewGroup默认不拦截任何事件。　
- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　
- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...

## 【深入了解MVXX模式】

> 前言：做客户端开发、前端开发，大致都应该听说过这么几个名词MVC、MVP、MVVM，这些架构的思想大多是为了解决界面应用程序复杂的逻辑问题。同时这些框架的核心目的在于，职责分离，不同的层次要做不同的事情。

无论是哪种MV**系列，都涉及到了Model和View，如果单纯的只有Model和View，他们是没有办法一起协同工作的，所以就有了各种MV..的设计模式

**MVXX模式：**

- MVC
- MVP
- MVVM

这三种架构模式都是现在比较流行的，在不同的项目中，可能采用不同的架构模式，今天我们就围绕着这三种架构模式的试用场景介绍一下他们的概念，以及异同。

##### [1] MVC

[![img](https://camo.githubusercontent.com/8de6460e4d41c88ad2cf5432caae6b10f82d196e/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76632d6465702e706e67)](https://camo.githubusercontent.com/8de6460e4d41c88ad2cf5432caae6b10f82d196e/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76632d6465702e706e67)

**MVC(Model-View-Controller),Model:逻辑模型，View:视图模型，Controller控制器**。简单说这就是一种设计应用程序的思想，目的在于将业务逻辑、数据、界面分离，将业务逻辑聚集到一个部件里面，在改进或者想要定制界面及用户交互时，不需要重写编写业务逻辑。Controller和View都依赖Model层，Controller和View相互依赖。

操作的过程：用户在界面上进行操作(例如手机屏幕)，这个时候View会捕捉到用户的操作，然后将这个操作的处理权利交给Controller，Controller会对来自View的数据进行预处理，决定调用哪个Model的接口，然后由Model执行相应的逻辑，当Model变更之后，再利用观察者模式通知View，View通过观察者模式收到Model的消息之后，向Model请求最新的数据，然后更新页面，如下图：

[![img](https://camo.githubusercontent.com/b89ac314c2fd554e7bf33ba1553e10dd91be44fc/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76632d63616c6c2e706e67)](https://camo.githubusercontent.com/b89ac314c2fd554e7bf33ba1553e10dd91be44fc/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76632d63616c6c2e706e67)

看似没有什么特别的地方，但是由几个需要特别关注的关键点：

1. View是把控制权交移给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。
2. Controller操作Model，Model执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。
3. View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。

需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很多对于MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同的MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接受到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。我们每天都在用的观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。

**优点**

1. 首先最重要的一点是多个视图能共享一个模型，同一个模型可以被不同的视图重用，大大提高了代码的可重用性。
2. 由于MVC的三个模块相互独立，在其中改变一个，其他两个可以保持不变，这样可以把耦合降得很低，这样可以使开发人员可以只关注整个系统中的某一层
3. 控制器提高了应用程序的灵活性和可配置型。控制器可以用来连接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提供强有力的手段

**缺点**

1. 增加了系统结构的实现的复杂性
2. 视图与控制器之间的联系过于紧密，视图如果没有控制器的存在，能够做的事情少之又少，这样视图就很难独立应用了
3. 视图对模型的数据的访问效率过低，因为之间需要多次的调用
4. View无法组件化，View依赖于特定的Model，如果需要把这个View抽出来用在下一个应用程序复用就比较困难了

##### [2] MVP

Model(Model View Presenter),Model:逻辑模型，View:视图模型，Presenter:接口。

关于MVP的定义：

```
- MVC的演化版本，让Model和View完全解耦
- 代码清晰，不过增加了很多类
```

MVP中的P，是Presenter的含义，和MVC比较类似，都是将用户对View的操作交付给Presenter，Presenter会执行相应的逻辑，在这过程中会操作Model，当Model执行完业务逻辑之后，同样是通过观察者模式把自己的结果传递出去，不过不是告诉View，而是告诉Presenter，Presenter得到消息后，通过View的接口更新页面。

在Android中，我们的View可能仅仅就是个布局文件，它能做的事情少之又少，真正与布局文件进行数据绑定操作的事Activity，所以这样做就使Activity即像View又像Controller。

应用了MVP之后：

```
- View:对应Activity，负责View的绘制以及与用户交互
- Model:业务逻辑和实体模型
- Presenter:负责完成View与Model之间的交互
```

应用两张图来说明上述内容:

[![img](https://camo.githubusercontent.com/e2b5d4479225546bfafa3702069e7a7e035e5e48/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132383335353534)](https://camo.githubusercontent.com/e2b5d4479225546bfafa3702069e7a7e035e5e48/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132383335353534)

[![img](https://camo.githubusercontent.com/ab02cad1c475e9abde495cec526bc6744c3eceae/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132383536303131)](https://camo.githubusercontent.com/ab02cad1c475e9abde495cec526bc6744c3eceae/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132383536303131)

**MVP的优点**

1. 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。
2. View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。

**MVP的缺点**

1. 代码量会一些，实现的难度也会增加一些

**MVP与MVC区别**

如下图所示：

[![img](https://camo.githubusercontent.com/ffe3507510be194890acf2d449e35e3df123c941/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132393136303534)](https://camo.githubusercontent.com/ffe3507510be194890acf2d449e35e3df123c941/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313530363232323132393136303534)

##### [3] MVVM

MVVM是Model-View-ViewModel的简写，MVVM是思想上的一种变革，也可以看成是MVP的一种变革，它是将"数据模型数据双向绑定"的思想作为核心，因此在View和Model之间便不需要我们写联系了，我们在修改数据的时候视图就可以发生变化，我们在修改视图的时候数据也是会发生变化的，可以在一定程度上提高我们的开发效率的。

**调用关系**

MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。

[![img](https://camo.githubusercontent.com/61ef7578cd46b1d37dd3ea52ce0a3be570e427cc/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76766d2d63616c6c2e706e67)](https://camo.githubusercontent.com/61ef7578cd46b1d37dd3ea52ce0a3be570e427cc/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f6d76632f6d76766d2d63616c6c2e706e67)

也就是说，MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。

Android官方推出的MVVM的DataBinding，便是一个双向绑定的库。

**优点**

1. 提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。
2. 简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。

**缺点**

1. 过于简单的图形界面不适用，或说牛刀杀鸡。
2. 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。
3. 数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。

##### [4] 相关资料

- [浅谈MVP in Android](http://blog.csdn.net/lmj623565791/article/details/46596109)
- [MVC三层框架详细解析](http://blog.csdn.net/u011225629/article/details/47857979)
- [还原真实的MV*模式](https://github.com/livoras/blog/issues/11)

## 【Intent】

Intent 是 Android 非常常用的一个用于组件间互相通信的信息对象，常用于启动组件和传递数据，大部分的程序里都有着他的身影。Intent 的用法比较简单，看看示例代码自然而然就用了起来，相信很多人和我之前一样也是没有仔细的去了解过。本文总结了一下 Intent 的结构和用法，除了一般的用法外，像隐式 Intent 的匹配规则之类可能很多人都比较一知半解的内容也会进行深入。

##### [1] Intent 的包含信息与构造

Intent 作为一个负责组件间传递消息的信息对象，最重要的就是其包含的信息。实际上无论是显式还是隐式，Intent 发出的时候，系统对应的行为正是由 Intent 所包含**信息的组合**决定。一个 Intent 所包含的信息如下图：

![img](https:////upload-images.jianshu.io/upload_images/5064136-90a90f76a05437fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/782/format/webp)

**Intent包含信息**

Intent 的各部分信息均为可选值，但是在使用 Intent 的时候，会根据 Intent 设定的信息组合来决定对应行为。先来看看 Intent 的构造方法和一些常用设定信息的方法

**Intent 常用构造方法：**

| 方法 | 描述 |
|::|:-----|
|Intent() | 构造一个空 Intent |
| Intent(String action)| 构造一个指定 action 的 Intent |
| Intent(String action，Uri uri)| 构造一个指定 action 和 uri（相当于同时设定了 data）的 Intent|
| Intent(Context packageContext，Class<?> cls)| 构造一个指定目标组件的 Intent，显式 Intent 的主要构造方法 |

**常用的设定信息方法：**

| 方法 | 描述 |
|::|:-----|
|setAction(String action)|指定 action|
|setClass(Context packageContext, Class<?> cls)|指定目标组件类名|
|setData(Uri data)|设置 Data 的 uri|
|setType(String type)|设置 Data 的 MIME 类型|
|setDataAndType(Uri data, String type)|同时设置 Data 的 uri 与 MIME 类型|
|addCategory(String category)|添加一项 Category，Intent 可有多个 Category|
|addFlags(int flags)|设置 Flag，决定目标组件的启动方式|
|putExtra(String name, 基本类型和序列化类 value)|放入附加数据，参 2 可以是各种基本类型，及序列化后的自定义类|
|putExtras(Bundle extras)|把封装了数据信息的 Bundle 对象放入 Intent|

* 若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType()  同时设置  URI  和  MIME  类型。

**目标组件名称**

显式 Intent 的必要信息，指定后 Intent 仅传给指定的组件（也就是所谓**显性 Intent**），否则系统会根据其他信息筛选出可以响应 Intent 的所有组件（即**隐性 Intent**）。可以使用  setComponent()、setClass()、setClassName()  或  Intent  构造函数设置组件名称。

* 由于安全性原因，在5.0后的系统，启动  Service 时，应始终指定组件名称，否则会报错。

**Action**

指 Intent 发向的组件的主要动作，比如：图片应用中主要动作为查看图片的组件、地图应用中主要动作为查看地址的组件。另外，对于广播（Broadcast）组件而言，Intent 的 action 则是指广播具体的值。当  Broadcast Receiver 接收到该值时代表了某事件已经发生。
 通常使用的主要是 Android 系统内置 action，这些 action 实际上是保存在 Intent 类中的静态常量，系统的默认组件（如：默认浏览器、图片浏览器、拨号页面等）都可以响应相应的 action。下面给出几个比较常见内置 action。

**ACTION_VIEW**

 向用户展示某信息，比如使用浏览器打开网址，用图片应用显示图片等

**ACTION_SEND**
 用于发送数据，比如电子邮件应用或者一些社交应用。

**ACTION_DIAL**
 显示带拨号盘的页面，让用户可以进行拨号动作。

有关更多定义通用操作的常量，请参阅 [Intent](https://link.jianshu.com?t=https://developer.android.com/reference/android/content/Intent.html)类参考文档。

除了 Android 内置的 action 之外，也可以**自定义action**， 供 Intent  在自己的应用内使用（或者供其他应用在自己的应用中调用组件）。如果定义自己的操作，请确保将应用的软件包名称作为前缀。 例如：



```dart
static final String ACTION_TIMETRAVEL = "com.example.action.TIMETRAVEL";
```

**Data**

包含了 URI 对象和 memitype 两个部分，分别是待操作数据的引用 uri，以及待操作数据的数据类型。两部分均为可选，但是要注意同时设置时应该使用 `setDataAndType()`方法，防止互相抵消。
 Data 内容一般由 action 决定，比如 action 为 ACTION_VIEW，那么 Data 就可以是一个网址，也可以是图片之类的数据 uri。
 同时指定 Uri 和  MIME  类型有助于  Android  系统找到接收  Intent  的最佳组件，例如可以响应     ACTION_VIEW 的组件可能有非常多，浏览器、播放器、图片应用等等。此时设置`mimeType`为`"image/jpeg"`或者`video/mp4`，则系统可以筛选出更合适的响应组件。

**Category**

目标组件的类型信息字符串，一个 Intent 可以添加多个 Category 。以下是比较常见的 Category：

**CATEGORY_BROWSABLE**
 目标  Activity  允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。

**CATEGORY_LAUNCHER**
 该  Activity  是任务的初始  Activity，在系统的应用启动器中列出。

需要注意的是大部分 Intent 虽然不需要设置 Category，但是在调用使用 Intent 的方法（如`starActivity（）`等）的时候，会默认为该 Intent 添加 CATEGORY_DEFAULT，相应目标组件的Intent过滤器应该添加该类别，具体会在下文 **2、Intent的用法** 中详述。

**以上 4 种（组件类名、Action、Data、Category）是会影响系统对 Intent 的解析从而决定最终启动那个组件的信息，以下两种（Extra、Flag）属于附加的信息，不影响系统解析启动那个组件**

**Extra**

Intent 携带附加数据，也是组件间互相传递信息比较常见的做法。使用各种  `putExtra()`方法添加  extra  数据，每种方法均接受两个参数：键名和值。还可以创建一个包含所有  extra  数据的 Bundle 对象，然后使用 `putExtras()`将 Bundle 插入 Intent 中。
 具体用法在下文 **3、数据传送** 中详述。

**Flag**

指示  Android  系统如何启动  Activity，例如，Activity  应属于哪个任务，以及启动之后如何处理（例如，它是否属于最近的  Activity  列表）。

**Intent 构造示例：**

```java
    Intent intent = new Intent(this,TagerActivity.class);//显式 Intent 构造示例

    //隐式Intent构造示例
    Intent intent=new Intent(Intent.ACTION_VIEW);//设定 action 为展示内容
    intent.setData(Uri.parse("http://www.baidu.com"));//设置 data 的 uri 为一个网址
    intent.addCategory(Intent.CATEGORY_LAUNCHER);//目标组件为某个应用的首页面
    intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);//目标 Activity 的启动方式为 single top
    intent.putExtra("extra_my","Tom");//附加 String 数据
```

##### [2] Intent的用法

Intent 主要分为显式 Intent 和隐式 Intent，根据显隐用法不同。

![img](https:////upload-images.jianshu.io/upload_images/5064136-bf6e0759400efa0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/827/format/webp)

Intent 使用流程

常用发送  Intent  启动组件方法：

| 方法 | 描述 |
|::|:-----|
|startActivity() | 启动 Activity|
|startActivityForResult()| 启动 Activity，该 Activity 销毁后会回调到上个活动的 onActivityResult() 方法 |
| bindService()| 启动 Service，5.0后只能接收显性 Intent 作为参数|
|sendBroadcast()| 发送标准广播 |
|sendOrderedBroadcast()| 发送有序广播 |

**显式**

显式 Intent 通常应用在自己的程序中，启动特定组件。用法比较简单，就是构造一个带有目标组件名的  Intent，作为参数传入上述方法即可，调用方法后会直接启动相应组件。
 **值得注意的就是在5.0之后的系统， Service 只能通过显式 Intent 启动**。

**隐式**

隐式 Intent 允许启动其他应用中的组件，在调用发送 Intent 的方法后，该 Intent 会交由 Android 系统进行匹配，（匹配根据信息是 action、data、category 这3项，即本文第一张图片 Intent 包含信息中标蓝色部分）筛选出整个设备可响应该 Intent 的组件。下图官方文档对隐式 Intent 如何传递启动其他应用组件的图解：

![img](https:////upload-images.jianshu.io/upload_images/5064136-13e8352416db44dd.png?imageMogr2/auto-orient/strip|imageView2/2/w/858/format/webp)

隐式 Intent 如何通过系统传递以启动其他 Activity 的图解： [1] Activity A 创建包含操作描述的 Intent，并将其传递给 startActivity()。 [2] Android 系统搜索所有应用中与 Intent 匹配的 Intent 过滤器。 找到匹配项之后， [3] 该系统通过调用匹配 Activity（Activity B）的 onCreate() 方法并将其传递给 Intent，以此启动匹配 Activity。

**Intent过滤器**

Intent 过滤器是 manifests 里组件的子标签`<intent-filter>`,一个控件可以声明一个或者**多个 **Intent 过滤器，只要其中一个通过匹配，该组件就可以相应相应 Intent。先来看一个官方给出的 Intent 过滤器示例：



```xml
<activity android:name="MainActivity">
    <!-- 应用的首页面，会显示在启动器中 -->
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>

<activity android:name="ShareActivity">
    <!-- 该活动可以处理 SEND这个 aciton，且处理数据类型为无格式文本 -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
     <!--需要响应隐式Intent的活动必须添加 android.intent.category.DEFAULT这个分类，因为starActivity()方法会默认为Intent添加-->
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
    <!-- 此为同一个 Activity 的第二个过滤器  该活动可以处理 "SEND" 和 "SEND_MULTIPLE"两种 aciton  处理数据类型为多媒体数据（包括图片、视频和全景照片） -->
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <action android:name="android.intent.action.SEND_MULTIPLE"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="application/vnd.google.panorama360+jpg"/>
        <data android:mimeType="image/*"/>
        <data android:mimeType="video/*"/>
    </intent-filter>
</activity>
```

这里值得注意的几个点：

- 1 Intent 只能有1个 action，而 Intent 过滤器可有多个 action
- 2 需要响应隐式 Intent 的 Activity 的 Intent 过滤器中必须添加 android.intent.category.DEFAULT这个分类
- 3 data 在构造时传入的是 Uri 对象以及 mimeType 字符串，mimeType 的对应关系比较直观不详述，Uri 对象会被分为 4 个部分`<scheme>://<host>:<port>/<path>`（<协议>://<主机名>:<端口>/<路径>），在 Intent 过滤器中的写法如下：



```xml
<intent-filter>
       <data 
           android:scheme="content" android:host="com.example.project" 
           android:port="200" android:path="/folder/subfolder/etc"/>
      </intent-filter>
```

对应的Uri对象：



```dart
Uri uri=Uri.parse("content://com.example.project:200/folder/subfolder/etc");
```

- 4 path 和 mimeType 允许使用*通配符，实现部分匹配。
- 5 对于所有 Activity，必须在清单文件中声明 Intent 过滤器。
   但是，广播接收器的过滤器可以通过调用 registerReceiver()  动态注册。 且可以使用  unregisterReceiver() 注销该接收器。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。

**匹配规则**

- 隐式 Intent 会与所有设备所有应用组件的 Intent 过滤器进行比对。
- 一个组件可以有多个 Intent 过滤器，某个 Intent 只需与其中任何一个匹配即可启动组件。
- 系统会根据 Intent 与 Intent 过滤器的 action、data、category 进行三次比对（测试），要全部通过才能匹配。
- action 的匹配规则：
   A、Intent 只能包含一项 action，而 Intent 过滤器可以包含多项 action，只要 Intent 的 action 可以在 Intent 过滤器中找到对应项即可通过测试。
   B、当 Intent 过滤器未声明任何 action 时，任何 Intent 都不能通过匹配。
   C、当 Intent 未指定 Action 时，无法通过匹配。
- category 的匹配规则：
   A、Intent 可以包含多项 category，Intent 过滤器也可以包含多项 category。Intent 中的每项 category 必须在Intent过滤器中都有对应项，才能通过匹配。
   B、当目标组件为 Activity 时，如需相应隐式 Intent，必须添加 "android.intent.category.DEFAULT" 到 Intent 过滤器中。因为启动Activity的方法都会默认为Intent添加该 category。
   C、目标组件为广播时，Intent 和 Intent 过滤器都不设置 category，可通过匹配。
- data的匹配规则：

和上面两个元素不同，data 具有子元素，其构成如下图：

![img](https:////upload-images.jianshu.io/upload_images/5064136-86bd9da35beaec08.png?imageMogr2/auto-orient/strip|imageView2/2/w/798/format/webp)

data的构成

在 Intent  中传入的 Uri 对象会被解析成`<scheme>://<host>:<port>/<path>`（<协议>://<主机名>:<端口>/<路径>）4 个部分进行匹配测试。4 项均为可选，但是存在线性依赖关系：
 **如果未指定 scheme，则会忽略 host；
 如果未指定 host，则会忽略 port；
 如果未指定 scheme 和 host，则会忽略 path。**

data 的匹配规则主要有以下几点：

A、将 Intent  中的  URI  与过滤器中的  URI  规范进行比较时，它仅与过滤器中包含的部分  URI  进行比较。 例如：

- 如果过滤器仅指定 scheme，则具有该 scheme 的所有  URI  均与该过滤器匹配。
- 如果过滤器指定 scheme  和 host，但未指定 path，则具有相同 scheme 和 host 的所有  URI  都会通过过滤器，无论其 path 如何均是如此。
- 如果过滤器指定 scheme、host和path，则仅具有相同 scheme、host 和 path 的  URI 才会通过过滤器。
- path 部分可以使用*通配符，仅需部分匹配路径名即可。

B、mimeType 可以部分使用通配符，如：`image/*`(表示匹配所有格式图像数据)，也可以全部使用`*/*` 表示匹配所有类型数据。

C、当Intent同时不指定  uri 与 mimeType 时，只有同样未声明 uri 与 mimeType 的 Intent 过滤器可以通过匹配。

D、当 Intent 只含有 uri 时，只有声明 uri 相互匹配，且未声明 mimeType 的 Intent 过滤器可以通过匹配。

E、当 Intent 只含有 mimeType 时，只有 mimeType 相互匹配，且未声明 uri 的 Intent 过滤器可以通过匹配。

F、当 Intent 同时含有 uri 和 mimeType 时，只有两部分均匹配的 Intent 过滤器可以通过匹配。

G、Intent过滤器只声明mimeType时，默认支持scheme为content: 和 file: 的uri。

H、当 Intent 传入的 uri 为  content: URI  时，表明数据位于设备中，且由  ContentProvider  控制，此时即使不设置 mimeType，mimeType 也对系统可见。

**非空判断**

当隐式  Intent 发出而找不到匹配 Activity 时，调用将会失败，且应用会崩溃。要验证是否存在会接收 Intent 的 Activity ，可以对  Intent  对象调用  resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，且可以安全调用  startActivity()。 如果结果为空，则不应使用该  Intent，应停用发出该  Intent  的功能。

```csharp
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType("text/plain");

// 判断是否存在能够匹配该 Intent 的 Activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
```

**强制使用选择器**

当存在多个 Activity 响应 Intent 时，系统会弹出默认选择器，供用户选择启动 Activity，且用户可以选择为该操作设定默认选项。

![img](https:////upload-images.jianshu.io/upload_images/5064136-6057746273ce416a.png?imageMogr2/auto-orient/strip|imageView2/2/w/426/format/webp)

默认选择器，有just once和always选择让用户决定是否设定默认选项

根据应用场景，有一些  Intent  可能并不适合存在默认选项。例如，当应用使用  ACTION_SEND  操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用。此时可以强制显示选择器（显式的调用选择器），选择器对话框每次都会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。
 具体使用createChooser()方法，接收两个参数，第一个是包含信息的 Intent，第二个是选择器的标题。

```csharp
    Intent viewIntent=new Intent();
    viewIntent.setAction(Intent.ACTION_VIEW);
    //createChooser()方法，显式调用选择器，用户将无法设定默认选项
    Intent intent=Intent.createChooser(viewIntent,"应用选择器");
    //判断该Intent是否存在可响应Activity，用未使用createChooser()方法的原Intent进行判断
    if (viewIntent.resolveActivity(getPackageManager())==null) return;
    startActivity(intent);
```

![img](https:////upload-images.jianshu.io/upload_images/5064136-7db9ab3757d92948.png?imageMogr2/auto-orient/strip|imageView2/2/w/433/format/webp)

createChooser()方法生成的选择器

##### [3] 数据传送

Intent 作为组件间的信息对象，另一个主要作用就是数据的传送。
 Intent传送数据是以键值对的形式，主要通过`putExtra()`方法，该方法接收两个参数，第一个是数据的键，
 第二个是数据的值。**第二个参数的取值范围**包括8种基本数据类型和 String、CharSequence，以及他们的数组，另外还可以是 Parcelable（包含数组）、Serializable，以及包含数据的 Bundle  对象。

**基本类型的传出与回传**

在目标组件中取出 Intent 的方法根据数据类型有非常多，这里不一一列举，只给出一般格式。

| 方法                                           | 描述                    | 默认取值                           |
| :--------------------------------------------- | :---------------------- | ---------------------------------- |
| getXxxExtra(String name，基本数据类型  默认值) | Xxx 为基本数据类型      | Extra 中无对应键名时，取方法参数 2 |
| getXxxExtra(String name)                       | Xxx为Srting等引用类型   | Extra 中无对应键名时，取值 null    |
| getBundleExtra(String name)                    | 取出Bundle对象的方法    | Extra 中无对应键名时，取值 null    |
| getXxxArrayExtra()                             | 取出Xxx类型对应数组方法 | Extra 中无对应键名时，取值 null    |

ps：方法使用驼峰法，单词间首字母大写。



```java
    //添加 Extra 示例
    Intent intent = new Intent(this,TagerActivity.class);
    intent.putExtra("extra_int",1000);
    int[] ints={1,2,3};
    intent.putExtra("extra_int_array",ints);
    intent.putExtra("extra_string","teger Activity");
    startActivity(intent);

------------------------------------------
    //对应取出数据示例
    Intent intent=getIntent();
    int i=intent.getIntExtra("extra_int",0);
    int[] ints=intent.getIntArrayExtra("extra_int_array");
    String a=intent.getStringExtra("extra_string");
```

**数据回传**

把数据传回上个活动也是 Intent 比较常用的方法之一。
 实现的方式是在启动活动时使用`startActivityForResult(Intent intent,int requestCode)`代替`startActivity(Intent intent)`，当被启动活动销毁时，就会携带一个 Intent 回调到调用`startActivityForResult()`方法的Activity的`startActivityForResult()` 方法。关于 Intent 添加 Extra，和数据的取出和普通的用法并没有什么区别。
 基本的步骤是：
 A、调用`startActivityForResult()`方法启动新 Activity，该方法有两个参数，参 1 为 Intent，参 2 为 int 类型的唯一请求码，用于判断数据来源。
 B、在新 Activity 中调用`setResult()`方法把携带希望回传数据的 Intent 作为参数传入。
 C、重写原 Activity 的`onActivityResult()` 方法。该方法携带 3 个参数，参 1 为启动 Activity 的请求码 requestCode，参 2 为表示处理结果是否成功的 resultCode，参 3 为携带数据的 Intent。
 重写的主要逻辑是：先通过 requestCode 判断数据来源（根据场景，原 Activity 可能启动不同新 Activity）；然后通过 resultCode 判断处理结果是否成功；最后取出 Intent 中数据进行处理即可。



```java
    //原 Activity 中启动新 Activity 并请求返回数据
    Intent intent = new Intent(this,TagerActivity.class);
    startActivityForResult(intent,1);

------------------------------------

    //新 Activity 中设定返回 Intent 并销毁，销毁后会回调到原 Activity 的 onActivityResult()方法
    Intent intent=new Intent();
    intent.putExtra("extra_boolean",true);
    setResult(RESULT_OK,intent);
    finish();

------------------------------------

  //原 Activity 中重写 onActivityResult() 方法
  @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch (requestCode){
      case 1:
        if (resultCode==RESULT_OK){
          boolean b=data.getBooleanExtra("extra_boolean",false);
        }
        break;
      default:
    }
  }
```

**自定义类型序列化传送**

使用 Intent 来传递自定义对象主要有两种实现方式：Serializable 和 Parcelable。
 Serializable  是序列化的意思，是指将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。
 Parcelable 也可以实现相同效果，其实现原理是将一个完整的对象进行分解，而分解后的每一部分都是 Intent 所支持的数据类型，这样也就实现传递对象的功能了。
 两种方式对比下 Serializable 比 Parcelable 效率偏低，Parcelable  实现虽然相对复杂，但是在 [parceler](https://link.jianshu.com?t=https://github.com/johncarl81/parceler)之类的第三方库支持下也变得非常简单，所以通常情况比较推荐用 Parcelable 的方式实现 Intent 传递对象。

自定义类实现 Serializable 示例：

```java
public class User implements Serializable {
  private int id;
  private String name;

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }
}
```

非常简单，只要让自定义类实现 Serializable 接口即可。

Parcelable 方式比 Serializable 多出几个步骤：1、重写 describeContents()  返回 0 即可；2、重写writeToParcel()  写出字段；3、提供一个 CREATOR 常量。

自定义类实现Parcelable示例：



```java
public class User implements Parcelable {
  private int id;
  private String name;

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  //步骤1：重写 describeContents()  返回0即可
  @Override public int describeContents() {
    return 0;
  }

  //步骤2：重写 writeToParcel() 写出字段
  @Override public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(name);
    dest.writeInt(id);
  }

  //步骤3：提供一个 CREATOR 常量
  public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {
    @Override public User createFromParcel(Parcel source) {
      User user = new User();
      user.id = source.readInt();
      user.name = source.readString();
      return user;
    }

    @Override public User[] newArray(int size) {
      return new User[size];
    }
  };
}
```

添加 Extra 与取出示例：



```java
    User user=new User();
    user.setId(1);
    user.setName("Tom");

    Intent intent = new Intent(this,TagerActivity.class);
    intent.putExtra("extra_user_data",user);
    startActivity(intent);
------------------------------------------
    Intent intent=getIntent();
    //如果放入自定义类使用了 Serializable 方式，则改用 getSerializableExtra() 方法 ，另外需要取出数据需要转型
    User user=(User)intent.getParcelableExtra("extra_user_data");
```

和基本类型的放入取出基本相同，只需要注意转型即可。

------

本文主要参考自： [https://developer.android.com/guide/components/intents-filters.html](https://link.jianshu.com?t=https://developer.android.com/guide/components/intents-filters.html)

##### [4] Bundle类

intent内部还是用bundle来实现数据传递的，只是封装了一层而已。

![image-20200902114508857](X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200902114508857.png)

## 【五大布局】

![img](https://img2018.cnblogs.com/blog/1417418/201810/1417418-20181023110434812-1986705497.png)

https://www.jianshu.com/p/4fac6304d872

##### [1] LinearLayout线性布局

LinearLayout容器中的组件一个挨一个排列，通过控制android:orientation属性，可控制各组件是横向排列还是纵向排列。

**LinearLayout的常用XML属性及相关方法**

| XML属性             | 相关方法            | 说明                                                         |
| :------------------ | :------------------ | :----------------------------------------------------------- |
| android:gravity     | setGravity(int)     | 设置布局管理器内组件的对齐方式                               |
| android:orientation | setOrientation(int) | 设置布局管理器内组件的排列方式，可以设置为horizontal、vertical两个值之一 |

其中，gravity属性支持top, left, right, center_vertical, fill_vertical, center_horizontal, fill_horizontal, center, fill, clip_vertical, clip_horizontal。也可以同时指定多种对齐方式的组合。

**LinearLayout子元素支持的常用XML属性及方法**

| XML属性                | 说明                                   |
| :--------------------- | :------------------------------------- |
| android:layout_gravity | 指定该子元素在LinearLayout中的对齐方式 |
| android:layout_weight  | 指定子元素在LinearLayout中所占的权重   |

##### [2] TableLayout表格布局

TableLayout继承自Linearout，本质上仍然是线性布局管理器。表格布局采用行、列的形式来管理UI组件，并不需要明确地声明包含多少行、多少列，而是通过添加TableRow、其他组件来控制表格的行数和列数。

每向TableLayout中添加一个TableRow就代表一行；

每向TableRow中添加一个一个子组件就表示一列；

如果直接向TableLayout添加组件，那么该组件将直接占用一行；

在表格布局中，可以为单元格设置如下三种行为方式：

- Shrinkable：该列的所有单元格的宽度可以被收缩，以保证该表格能适应父容器的宽度；
- Strentchable：该列所有单元格的宽度可以被拉伸，以保证组件能完全填满表格空余空间；
- Collapsed：如果该列被设置为Collapsed，那么该列的所有单元格会被隐藏；

**TableLayout的常用XML属性及方法**

| XML属性                 | 相关方法                      | 说明                                           |
| :---------------------- | :---------------------------- | :--------------------------------------------- |
| android:collapseColumns | setColumns(int, boolean)      | 设置需要被隐藏的列的序号，多个序号间用逗号分隔 |
| android:shrinkColumns   | setShrinkAllColumns(boolean)  | 设置需要被收缩的列的序号                       |
| android:stretchColumns  | setStretchAllColumns(boolean) | 设置允许被拉伸的列的序号                       |

##### [3] FrameLayout帧布局

FrameLayout直接继承自ViewGroup组件。帧布局为每个加入其中的组件创建一个空白的区域(称为一帧)，每个子组件占据一帧，这些帧会根据gravity属性执行自动对齐。

**FrameLayout的常用XM了属性及方法**

| XML属性                   | 相关方法                 | 说明                          |
| :------------------------ | :----------------------- | :---------------------------- |
| android:foreground        | setForeground(Drawable)  | 设置该帧布局容器的前景图像    |
| android:foregroundGravity | setForeGroundGraity(int) | 定义绘制前景图像的gravity属性 |

##### [4] RelativeLayout相对布局

**RelativeLayout的XML属性及相关方法说明**

| XML属性               | 相关方法              | 说明                              |
| :-------------------- | :-------------------- | :-------------------------------- |
| android:gravity       | setGravity(int)       |                                   |
| android:ignoreGravity | setIgnoreGravity(int) | 设置哪个组件不受gravity属性的影响 |

为了控制该布局容器的各子组件的布局分布，RelativeLayout提供了一个内部类：RelativeLayout.LayoutParams。

**RelativeLayout.LayoutParams里只能设为boolean的XML属性**

| XML属性                          | 说明                                   |
| :------------------------------- | :------------------------------------- |
| android:layout_centerHorizontal  | 设置该子组件是否位于布局容器的水平居中 |
| android:layout_centerVertical    |                                        |
| android:layout_centerParent      |                                        |
| android:layout_alignParentBottom |                                        |
| android:layout_alignParentLeft   |                                        |
| android:layout_alignParentRight  |                                        |
| android:layout_alignParentTop    |                                        |

**RelativeLayout.LayoutParams里属性值为其他UI组件ID的XML属性**

| XML属性                    | 说明                             |
| :------------------------- | :------------------------------- |
| android:layout_toRightOf   | 控制该子组件位于给出ID组件的右侧 |
| android:layout_toLeftOf    |                                  |
| android:layout_above       |                                  |
| android:layout_below       |                                  |
| android:layout_alignTop    |                                  |
| android:layout_alignBottom |                                  |
| android:layout_alignRight  |                                  |
| android:layout_alignLeft   |                                  |

##### [5] Android 4.0新增的网格布局GridLayout

GridLayout是Android4.0增加的网格布局控件，与之前的TableLayout有些相似，它把整个容器划分为rows × columns个网格，每个网格可以放置一个组件。性能及功能都要比tablelayout好，比如GridLayout布局中的单元格可以跨越多行，而tablelayout则不行，此外，其渲染速度也比tablelayout要快。

GridLayout提供了setRowCount(int)和setColumnCount(int)方法来控制该网格的行和列的数量。

**GridLayout常用的XML属性和方法说明**

| XML属性                      | 相关方法                         | 说明                                 |
| :--------------------------- | :------------------------------- | :----------------------------------- |
| android:alignmentMode        | setAlignmentMode(int)            | 设置该布局管理器采用的对齐模式       |
| android:columnCount          | setColumnCount(int)              | 设置该网格的列数量                   |
| android:columnOrderPreserved | setColumnOrderPreserved(boolean) | 设置该网格容器是否保留序列号         |
| android:roeCount             | setRowCount(int)                 | 设置该网格的行数量                   |
| android:rowOrderPreserved    | setRowOrderPreserved(boolean)    | 设置该网格容器是否保留行序号         |
| android:useDefaultMargins    | setUseDefaultMargins(boolean)    | 设置该布局管理器是否使用默认的页边距 |

为了控制GridLayout布局容器中各子组件的布局分布，GridLayout提供了一个内部类：GridLayout.LayoutParams，来控制Gridlayout布局容器中子组件的布局分布。

**GridLayout.LayoutParams常用的XML属性和方法说明**

| XML属性                   | 说明                                     |
| :------------------------ | :--------------------------------------- |
| android:layout_column     | 设置该组件在GridLayout的第几列           |
| android:layout_columnSpan | 设置该子组件在GridLayout横向上跨几列     |
| android:layout_gravity    | 设置该子组件采用何种方式占据该网格的空间 |
| android:layout_row        | 设置该子组件在GridLayout的第几行         |
| android:layout_rowSpan    | 设置该子组件在GridLayout纵向上跨几行     |

##### [6] AbsoluteLayout绝对布局

即Android不提供任何布局控制，而是由开发人员自己通过X坐标、Y坐标来控制组件的位置。每个组件都可指定如下两个XML属性：

- layour_x;
- layout_y;

绝对布局已经过时，不应使用或少使用。

##### [7] 界面布局类型的选择和性能优化

首先得明确，界面布局类型的嵌套越多越深越复杂，会使布局实例化变慢，使Activity的展开时间延长。建议尽量减少布局嵌套，尽量减少创建View对象的数量。

1 . 减少布局层次，可考虑用RelativeLayout来代替LinearLayout。通过Relative的相对其他元素的位置来布局，可减少块状嵌套；

2 . 另一种减少布局层次的技巧是使用 `<merge />` 标签来合并布局；

3 . 重用布局。Android支持在XML中使用 `<include />` 标签， `<include />` 通过指定android:layout属性来指定要包含的另一个XML布局。

如：

```xml
<include android:id="@+id/id1" android:layout="@layout/mylayout">
<include android:id="@+id/id2" android:layout="@layout/mylayout">
<include android:id="@+id/id3" android:layout="@layout/mylayout">
```

## 【View的绘制流程】

##### [1] 视图坐标系

**1.1 Android坐标系**

![android坐标系](https://img-blog.csdnimg.cn/2018121612352525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)

**1.2 3视图坐标系**

![视图坐标系](https://img-blog.csdnimg.cn/20181216123552974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)

##### [2] View的绘制流程前情提要

**2.1 View 树的绘图流程**

当 Activity 接收到焦点的时候，它会被请求绘制布局,该请求由 Android framework 处理.绘制是从根节点开始，对布局树进行 measure 和 draw。整个 View 树的绘图流程在`ViewRoot.java`类的`performTraversals()`函数展开，该函数所做 的工作可简单概况为是否需要重新计算视图大小(measure)、是否需要重新安置视图的位置(layout)、以及是否需要重绘(draw)，流程图如下：
![View树的绘制流程](https://img-blog.csdnimg.cn/20181216072726412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)
在此之前
![DecorView添加到窗口window的过程](https://img-blog.csdnimg.cn/20181216125700678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)
详见https://blog.csdn.net/jacklam200/article/details/50039189

**2.2 View绘制流程函数调用链**

![函数调用链](https://img-blog.csdnimg.cn/20181216072911606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)
可以说是： （测量）大小 -->（安排）位置 --> （绘制）内容

**2.3 绘制顺序**

![树的遍历](https://img-blog.csdnimg.cn/20181216073643776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)

- DecorView是View树的根
- 树的遍历是有序的，由父视图到子视图，每个ViewGroup负责绘制他所有的子视图，最底层的View负责绘制自身。
  或者说,measure流程分为View的measure流程和ViewGroup的measure流程，只不过ViewGroup的measure流程除了要完成自己的测量还要遍历去调用子元素的measure()方法

**2.4 measure过程传递尺寸的两个类**

- **ViewGroup.LayoutParams**(View自身的布局参数)
- **MeasureSpecs类**（父视图对自视图的测量要求）

**2.4.1 ViewGroup.LayoutParams**

用来指定视图的宽度和高度等参数，对于height和width有以下选择：

- 具体值
- MATCH_PARENT 子视图希望和父视图一样大（不包含padding值）
- WRAP_CONTENT 视图正好能包裹内容大小（包含padding值）
  ViewGroup的子类有其对应的ViewGroup.LayoutParams的子类。
  比如RelativeLayout拥有的ViewGroup.LayoutParams的子类RelativeLayoutParams.
  注意：我们使用view.getLayoutParams()方法获取的是其所在父视图类型的LayoutParams，比如View的父控件为RelativeLayout，那么得到的LayoutParams类型就是RelativeLayoutParams。

**2.4.2 MeasureSpecs	[…speks]**

测量规格，包含测量要求和尺寸信息，有三个模式：

- UNSPECIFIED
  父视图不对子视图有任何约束，它可以达到所期望的任意尺寸。比如 ListView、ScrollView，一般自定义 View 中用不到，
- EXACTLY
  父视图为子视图指定一个确切的尺寸，而且无论子视图期望多大，它都必须在该指定大小的边界内，对应的属性为 match_parent 或具体值，比如 100dp，父控件可以通过MeasureSpec.getSize(measureSpec)直接得到子控件的尺寸。
- AT_MOST
  父视图为子视图指定一个最大尺寸。子视图必须确保它自己所有子视图可以适应在该尺寸范围内，对应的属性为 wrap_content，这种模式下，父控件无法确定子 View 的尺寸，只能由子控件自己根据需求去计算自己的尺寸，这种模式就是我们自定义视图需要实现测量逻辑的情况。

##### [3] View的绘制流程



**3.1 View的measure流程：**

一个View的真正测量工作在onMeasure(int,int)中，由measure()方法调用。
而measure()方法为final所以只有onMeasure（int，int）可以而且必须被子类复写。

```java
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
      ...
      onMeasure(widthMeasureSpec, heightMeasureSpec);
      ...
    }
12345
```

首先看一下onMeasure()方法（View.java）:

```java
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }
1234
```

往里看setMeasuredDimension()方法：

```java
 protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        boolean optical = isLayoutModeOptical(this);
        if (optical != isLayoutModeOptical(mParent)) {
            Insets insets = getOpticalInsets();
            int opticalWidth  = insets.left + insets.right;
            int opticalHeight = insets.top  + insets.bottom;

            measuredWidth  += optical ? opticalWidth  : -opticalWidth;
            measuredHeight += optical ? opticalHeight : -opticalHeight;
        }
        setMeasuredDimensionRaw(measuredWidth, measuredHeight);
    }
123456789101112
```

我们看到`measuredWidth`、`measuredHeight` 显然它是**用来设置View的宽高**的。
我们再来看看getDefaultSize()方法处理了什么：

```java
public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
    }
12345678910111213141516
```

specMode是View的测量模式，而specSize是View的测量大小，我们有必要查看一下MeasureSpec类:

```java
 public static class MeasureSpec {
        private static final int MODE_SHIFT = 30;
        private static final int MODE_MASK  = 0x3 << MODE_SHIFT;

        /**
         * Measure specification mode: The parent has not imposed any constraint
         * on the child. It can be whatever size it wants.
         */
        public static final int UNSPECIFIED = 0 << MODE_SHIFT;

        /**
         * Measure specification mode: The parent has determined an exact size
         * for the child. The child is going to be given those bounds regardless
         * of how big it wants to be.
         */
        public static final int EXACTLY     = 1 << MODE_SHIFT;

        /**
         * Measure specification mode: The child can be as large as it wants up
         * to the specified size.
         */
        public static final int AT_MOST     = 2 << MODE_SHIFT;

...省略

 public static int getMode(int measureSpec) {
            return (measureSpec & MODE_MASK);
        }
  public static int getSize(int measureSpec) {
            return (measureSpec & ~MODE_MASK);
        }
...省略        
}
123456789101112131415161718192021222324252627282930313233
```

MeasureSpec类帮助我们来测量View

我们回头再看getDefaultSize()方法，显然在AT_MOST和EXACTLY模式下，都返回specSize这个值，也就是View测量后的大小，而在UNSPECIFIED模式(未指定模式)返回的是getDefaultSize()方法的第一个参数的值，这第一个参数从onMeasure()方法来看是getSuggestedMinimumWidth()方法和getSuggestedMinimumHeight()得到的，看一下这两个方法：(类似的只放Width)

```java
 protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
    }
123
```

如果View没有设置背景（MBackground==null）则取值为mMinWidth，mMinWidth是可以设置的，它对应于android：minWidth这个属性设置的值或者View的setMinimumWidth的值，若不指定则默认0：

```java
  public void setMinimumWidth(int minWidth) {
        mMinWidth = minWidth;
        requestLayout();

    }
12345
```

如果View设置了背景 在取值为max（mMinWidth,mBackground.getMinimumWidth()）,取值mMinWidth和mBackground.getMinimumWidth()两者中的最大值，mMinWidth上面已经看过，我们接下来看看mBackground.getMinimumWidth()，这个mBackground是Drawable类型的，看一下Drawable类的getMInimumWidth()方法（Drawable.java）:

```java
 public int getMinimumWidth() {
        final int intrinsicWidth = getIntrinsicWidth();
        return intrinsicWidth > 0 ? intrinsicWidth : 0;
    }
1234
```

intrinsicWidth得到的是这个Drawable的固有宽度，如果其大于0则返回固有宽度否则返回0。
我们可以看到，getSuggestedMinimumWidth()方法：如果View没有设置背景则返回mMinWidth,如果设置了背景就返回mMinWidth和Drawable最小宽度两个值的最大值。

**3.1.1 ViewGroup的measure流程**

我们知道对于ViewGroup，它除了需要measure自己本身，还要遍历调用子视图的measure()方法
![ViewGroup_measure](https://img-blog.csdnimg.cn/20181216082736733.png)

ViewGroup中没有定义onMeasure()方法，然而它定义了measureChildren()方法（ViewGroup.java）:

```java
 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
    }
12345678910
```

显然它是一个遍历children的方法，看一下调用的measureChild()方法：

```java
 protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
1234567891011
```

调用child.getLayoutParams()方法来获得子元素的LayoutParams属性，并获取到子元素的MeasureSpec并调用其measure()方法进行测量。
看一下getChildMeasureSpec()方法：

```java
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
...省略
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
1234
```

这是根据父容器的MeasureSpec的模式，结合子元素的LayoutParams属性得出自容器的MeasureSpec属性。

**3.1.2 LinearLayout的measure流程**

ViewGroup没有提供onMeasure方法，而是让其子类来个字实现测量的方法，我们看一下ViewGroup的子类LinearLayout的measure流程，看一下onMeasure()方法（LinearLayout.java）：

```java
 @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mOrientation == VERTICAL) {
            measureVertical(widthMeasureSpec, heightMeasureSpec);
        } else {
            measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        }
    }
12345678
```

复写了View的onMeasure()方法。
看一下measureVertical()方法部分源码：

```java
void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {
        mTotalLength = 0;
     mTotalLength = 0;       
 ...省略
  for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);

            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }

            if (child.getVisibility() == View.GONE) {
               i += getChildrenSkipCount(child, i);
               continue;
            }

            if (hasDividerBeforeChildAt(i)) {
                mTotalLength += mDividerHeight;
            }

            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();

            totalWeight += lp.weight;

             final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
            if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
                // Optimization: don't bother measuring children who are only
                // laid out using excess space. These views will get measured
                // later if we have space to distribute.
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
                skippedMeasure = true;
            } else {
                if (useExcessSpace) {
                    // The heightMode is either UNSPECIFIED or AT_MOST, and
                    // this child is only laid out using excess space. Measure
                    // using WRAP_CONTENT so that we can find out the view's
                    // optimal height. We'll restore the original height of 0
                    // after measurement.
                    lp.height = LayoutParams.WRAP_CONTENT;
                }
                // Determine how big this child would like to be. If this or
                // previous children have given a weight, then we allow it to
                // use all available space (and we will shrink things later
                // if needed).
               final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
                measureChildBeforeLayout(child, i, widthMeasureSpec, 0,
                        heightMeasureSpec, usedHeight);

                final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
                measureChildBeforeLayout(child, i, widthMeasureSpec, 0,
                        heightMeasureSpec, usedHeight);

                final int childHeight = child.getMeasuredHeight();
                if (useExcessSpace) {
                    // Restore the original height and record how much space
                    // we've allocated to excess-only children so that we can
                    // match the behavior of EXACTLY measurement.
                    lp.height = 0;
                    consumedExcessSpace += childHeight;
                }

                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                       lp.bottomMargin + getNextLocationOffset(child));
...省略

        if (useLargestChild &&
                (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
            mTotalLength = 0;

            for (int i = 0; i < count; ++i) {
                final View child = getVirtualChildAt(i);

                if (child == null) {
                    mTotalLength += measureNullChild(i);
                    continue;
                }

                if (child.getVisibility() == GONE) {
                    i += getChildrenSkipCount(child, i);
                    continue;
                }

                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                        child.getLayoutParams();
                // Account for negative margins
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                        lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            }
        }

        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;

        int heightSize = mTotalLength;

        // Check against our minimum height
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100
```

定义了mTotalLength用来储存LinearLayout在垂直方向的高度，然后遍历子元素，根据子元素的MeasureSpec模式分别计算每个子元素的高度，如果是wrap_content则将每个子元素的高度和margin垂直高度等值相加 并且赋值给mTotalLength得出LinearLayout的高度。如果布局高度设置为match_parent，具体数值则和view的测量方法一样。

**3.3 View的layout流程**

先来看一下View的layout()方法：

```java
public void layout(int l, int t, int r, int b) {
...省略
 boolean changed = isLayoutModeOptical(mParent) ?
         setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
 if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
            onLayout(changed, l, t, r, b);
...省略          
    }
12345678
```

传进来的分别是View的四个点的坐标，注意其是对于父布局来说的。
看看setFrame()方法：

```java
protected boolean setFrame(int left, int top, int right, int bottom) {
        boolean changed = false;

        if (DBG) {
            Log.d("View", this + " View.setFrame(" + left + "," + top + ","
                    + right + "," + bottom + ")");
        }
        
        //在setFrame()方法里主要是用来设置View的四个顶点的值，
        //即mLeft、mTop、mRight和mBottom

        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;

            // Remember our drawn bit
            int drawn = mPrivateFlags & PFLAG_DRAWN;

            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;
            int newWidth = right - left;
            int newHeight = bottom - top;
            boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);

            // Invalidate our old position
            invalidate(sizeChanged);

            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;
            mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);

        ...省略  
        }
        return changed;
    }
123456789101112131415161718192021222324252627282930313233343536
```

在setFrame()方法里主要是用来设置View的四个顶点的值，即mLeft、mTop、mRight和mBottom。调用setFrame()方法后调用onLayout()方法：

```java
  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    }
12
```

和onMeasure()方法类似，确定位置时候，不同控件有不同的实现，所以需要子类重写这个方法。我们看一下LinearLayout的onLayout()方法：

```java
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        if (mOrientation == VERTICAL) {
            layoutVertical(l, t, r, b);
        } else {
            layoutHorizontal(l, t, r, b);
        }
    }
12345678
```

看一看layoutVertical()方法：

```java
 void layoutVertical(int left, int top, int right, int bottom) {
     ...省略
        for (int i = 0; i < count; i++) {
            final View child = getVirtualChildAt(i);
           ...
                setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);
                
                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

                i += getChildrenSkipCount(child, i);
            }
        }
    }
12345678910111213
```

该方法会遍历子元素，调用setChildFrame()方法：

```java
private void setChildFrame(View child, int left, int top, int width, int height) {        
        child.layout(left, top, left + width, top + height);
    }
123
```

该方法中调用子元素的layout()方法来确定自己的位置。我们看到childTop这个值逐渐增大，这是为了在垂直方向，子元素一个接一个安排而不重叠。（setChildFrame()传入的第三个参数为childTop + getLocationOffset(child)）;

**3.4 View的draw流程**

![绘制流程图](https://img-blog.csdnimg.cn/20181216120715743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MzAwNg==,size_16,color_FFFFFF,t_70)
先来看下与 draw 过程相关的函数：

- View.draw(Canvas canvas)：
  由于 ViewGroup 并没有复写此方法，因此，所有的视图最终都是调用 View 的 draw 方法进行绘制的。在自定义的视图中，也不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制，如果自定义的视图确实要复写该方法，那么请先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制。
- View.onDraw()：
  View 的onDraw（Canvas）默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。
- dispatchDraw()
  发起对子视图的绘制。View 中默认是空实现，ViewGroup 复写了dispatchDraw()来对其子视图进行绘制。该方法我们不用去管，自定义的 ViewGroup 不应该对dispatchDraw()进行复写。

我们先来看一下ViewGroup的dispatchDraw的源码

```java
protected void dispatchDraw(Canvas canvas){

...省略

 if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {//处理 ChildView 的动画
     final boolean buildCache = !isHardwareAccelerated();
            for (int i = 0; i < childrenCount; i++) {
                final View child = children[i];
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {//只绘制 Visible 状态的布局，因此可以通过延时加载来提高效率
                    final LayoutParams params = child.getLayoutParams();
                    attachLayoutAnimationParameters(child, params, i, childrenCount);// 添加布局变化的动画
                    bindLayoutAnimation(child);//为 Child 绑定动画
                    if (cache) {
                        child.setDrawingCacheEnabled(true);
                        if (buildCache) {
                            child.buildDrawingCache(true);
                        }
                    }
                }
            }

     final LayoutAnimationController controller = mLayoutAnimationController;
            if (controller.willOverlap()) {
                mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
            }

    controller.start();// 启动 View 的动画
}

 // 绘制 ChildView
 for (int i = 0; i < childrenCount; i++) {
            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = (preorderedList == null)
                    ? children[childIndex] : preorderedList.get(childIndex);
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);//在drawChild中调用view.draw
            }
        }

...
if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
            invalidate(true);
        }

}

12345678910111213141516171819202122232425262728293031323334353637383940414243444546
```

- drawChild(canvas, this, drawingTime)
  直接调用了 View 的child.draw(canvas, this,drawingTime)方法，文档中也说明了，除了被ViewGroup.drawChild()方法外，你不应该在其它任何地方去复写或调用该方法，它属于 ViewGroup。而View.draw(Canvas)方法是我们自定义控件中可以复写的方法，具体可以参考上述对view.draw(Canvas)的说明。从参数中可以看到，child.draw(canvas, this, drawingTime) 肯定是处理了和父视图相关的逻辑，但 View 的最终绘制，还是 View.draw(Canvas)方法。
- invalidate()
  请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些调用了invalidate()方法的 View。

dispatchDraw(）–>drawChild()–>view.draw()

> 注意：view.draw()中调用的onDraw（Canvas）默认是空实现，自定义绘制过程需要复写的方法，绘制自身的内容。

我们再来看一下draw():

```java
 public void draw(Canvas canvas) {
 ...省略
        /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */

         // Step 1, draw the background, if needed
        int saveCount;

        if (!dirtyOpaque) {
            drawBackground(canvas);
        }
...省略
   // Step 2, save the canvas' layers
        int paddingLeft = mPaddingLeft;

        final boolean offsetRequired = isPaddingOffsetRequired();
        if (offsetRequired) {
            paddingLeft += getLeftPaddingOffset();
        }
...省略
  // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);	//onDraw空实现

        // Step 4, draw the children
        dispatchDraw(canvas);
...省略
   // Step 5, draw the fade effect and restore layers
        final Paint p = scrollabilityCache.paint;
        final Matrix matrix = scrollabilityCache.matrix;
        final Shader fade = scrollabilityCache.shader;
...省略
  // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);

        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
   }
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647
```

从源码的注释我们看到draw流程有六个步骤，其中第2步和第5步可以跳过：
1.若有背景则绘制
2.保存canvas层
3.绘制自身内容
4.如果有子元素则绘制子元素
5.绘制效果
6.绘制装饰品（scrollbars）

注意：由上面的处理过程，我们也可以得出一些优化的小技巧：当不需要绘制 Layer 的时候第二步和第五步会跳过。因此在绘制的时候，能省的 layer 尽可省，可以提高绘制效率

引用：
https://blog.csdn.net/itachi85/article/details/50708391
http://developer.android.com/guide/topics/ui/how-android-draws.html
http://blog.csdn.net/wangjinyu501/article/details/9008271
http://blog.csdn.net/qinjuning/article/details/7110211
http://blog.csdn.net/qinjuning/article/details/8074262

Android中的View在Android的知识体系中扮演着重要的角色。简单来说，View就是Android在视觉的体现。我们所展现的页面就是Android提供的GUI库中控件的组合。但是当要求不能满足于控件的时候，我们就需要自定义控件/自定义View来满足我们的要求。为了掌握自定义View，我们需要了解View的底层工作原理，了解View的测量流程，布局流程以及绘制流程，还有View常见的回调方法，比如构造方法，onAttach,onVisibilityChanged,onDetach等，以及滑动效果处理。

## 【View的绘制流程】

> https://www.jianshu.com/p/5a71014e7b1b

##### [1] View的绘制流程

View的绘制流程主要就是**measure**，**layout**，**draw**这三个流程，对应的View的方法是onMeasure(),onLayout(),onDraw()这三个方法，即是测量，布局，绘制三个流程。其中**measure** 是测量View的宽高，**layout**确定View的布局内容，设置四个顶点，长宽，最后通过draw将**View**的内容绘制到屏幕上。

  在View绘制前，我们了解下Activity中的**onCreate**的中执行**setContentView()**方法之后View是显示在屏幕上的，这个过程就不分析了，辅助我们理解整个流程。当调用Activity的setContentView()方法之后，会调用PhoneView类的setContentView方法，PhoneView类是抽象类Window的实现类，Window 类用来描述 Activity 视图最顶端的窗口显示和行为操作，PhoneView类的setContentView方法中最终会生成DecorView对象，DecorView是PhoneView类的内部类。下面是DecorView的机构图可以参考一下，需要进入到View层，就需要先进入到DecorView层。



![img](https:////upload-images.jianshu.io/upload_images/1869441-e70ad55695ea1fa8.png?imageMogr2/auto-orient/strip|imageView2/2/w/509/format/webp)

DecorView的结构图

  ViewRoot 对应的实现类是 ViewRootImpl 类，他是连接 WindowManager 和DecorView 的纽带，View 的三大 流程均是通过 ViewRoot 来完成的。在 ActivityThread 中，当 activity 对象被创建完毕后，会将 DecorView 添加到Window 中，同时会创建 ViewRootImpl 对象，并将 ViewRootImpl 对象和 DecorView 建立关联,这个过程参见源码。



```cpp
root = new ViewRootImpl(view.getContext(),display);
root.setView(view,wparms,panelParentView);
```

![img](https:////upload-images.jianshu.io/upload_images/1869441-e99d09ec9901ec9b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

DecorView添加窗口到View的过程

  View的绘制流程就是从ViewRoot的performTraversals方法开始的，它经过measuer，layout和draw三个过程才能最终将一个View绘制出来，针对performTraversals的大致流程。如下图所示：



![img](https:////upload-images.jianshu.io/upload_images/1869441-179a3b0644fec7f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

performTraversals的工作流程

  如图所示，performTraversals会一次调用performMeasure，performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure，layout和draw这三个流程。其中performMeasure会调用measure方法，measure方法又会调用onMeasure方法，在onMeasure方法中则会对所有的子元素进行measure过程，这时候measure流程就从父元素传递到了子元素，这样就完成了一次measure的过程。接着子元素会重复父元素measure的过程，如此反复就完成了父元素View的遍历。同理performLayout和perforDraw也是同样的道理。唯一不同的是，performDraw的传递过程是draw方法中的dispatchDraw方法来实现，本质上原理都是一致的。

  meaure过程决定了view的宽高。我们可以通过getMeasureWidth和getMeasureHeight方法来获取View的宽高。几乎在所有的情况下，这个宽高就是View的最终宽高。layout过程决定了view的四个点的坐标和实际的宽高。可以通过getTop，getRight， getLeft，getBottom来得到四个点的坐标，通过getWidth和getHeight得到实际的宽高。draw的过程就是显示的过程，只有在draw完成之后才能最终显示在屏幕上。

  DecorView 其实是一个 FrameLayout，View层事件都先经过DecorView ，然后才传给View。

##### [2] 理解MeasureSpec

  MeasureSpec，测量规格，测量说明，从名字上看起来都知道它的作用就是决定View的测量过程或者说它在很大程度上决定了View的尺寸规格。除此之外还有父容器也会影响View的创建过程。在测量过程中，系统会将View的LayoutParams根据父容器的规则转换成对应的MeasureSpex，然后再根据这个MeasureSpec来测量View的宽高。

  MeasureSpec代表了一个32位的int的值，高2位代表了SpecMode，低30位代表了SpecSize。SpecMode指测量模式，SpecSize是指在某种测量模式下的规格大小。MeasureSpec 通过将 SpecMode 和 SpecSize 打包成一个 int 值来**避免过多的内存分配**，为了方便操作，其提供了打包和解包方法源码如下:

```cpp
//将 SpecMode 和 SpecSize 打包，获取 MeasureSpec  
public static int makeMeasureSpec(int size, int mode) {
    if (sUseBrokenMakeMeasureSpec) {
        return size + mode;
    } else {
        return (size & ~MODE_MASK) | (mode & MODE_MASK);
    }
}
//将 MeasureSpec 解包获取 SpecMode
public static int getMode(int measureSpec) {
            return (measureSpec & MODE_MASK);
        }
//将 MeasureSpec 解包获取 SpecSize
 public static int getSize(int measureSpec) {
            return (measureSpec & ~MODE_MASK);
        }
```

SpecMode 有三类，每一类都表示特殊的含义：

1. **UNSPECIFIED 父容器不对 View 有任何的限制**，要多大给多大，这种情况下一般用于系统内部，表示一种测量的状态。
2. **EXACTLY 父容器已经检测出 View 所需要的精确大小**，这个时候 View 的最终大小就是 SpecSize 所指定的值，它对应于LayoutParams 中的 match_parent 和具体的数值这两种模式。
3. **AT_MOST 父容器指定了一个可用大小即 SpecSize**，View 的大小不能大于这个值，具体是什么值要看不同 View 的具体实现。它对应于 LayoutParams 中的 wrap_content。

##### [3] 理解MeasureSpec 和 LayoutParams 的对应关系

  对于DecorView，它的 MeasureSpec 由窗口的尺寸和其自身的 LayoutParams 来决定；对于普通 View，它的MeasureSpec 由父容器的 MeasureSpec 和自身的 LayoutParams 来共同决定，MeasureSpec一旦确定，onMeasure中就可以确定View的宽高。

  对普通的 View 来说，View的 measure过程是由其ViewGroup传递而来的，这里先看一下 ViewGroup 的 measureChildWithMargins 方法：

```java
 * @param child 要被测量的 View
 * @param parentWidthMeasureSpec 父容器的 WidthMeasureSpec
 * @param widthUsed 父容器水平方向已经被占用的空间，比如被父容器的其他子 view 所占用的空间
 * @param parentHeightMeasureSpec 父容器的 HeightMeasureSpec
 * @param heightUsed 父容器竖直已经被占用的空间，比如被父容器的其他子 view 所占用的空间
 */
protected void measureChildWithMargins(View child,
        int parentWidthMeasureSpec, int widthUsed,
        int parentHeightMeasureSpec, int heightUsed) {

   //第一步，获取子 View 的 LayoutParams
    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

   //第二步，获取子 view 的 WidthMeasureSpec，其中传入的几个参数说明：
   //parentWidthMeasureSpec 父容器的 WidthMeasureSpec
   //mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值
   //lp.leftMargin + lp.rightMargin view 本身的 Margin 值，即外边距值
   //widthUsed 父容器已经被占用空间值
   // lp.width view 本身期望的宽度 with 值
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                    + widthUsed, lp.width);
     //获取子 view 的 HeightMeasureSpec
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                    + heightUsed, lp.height);

// 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec 
   //对子 view 进行测量
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
```

  上述方法会对子元素进行measure，在调用子元素的measure方法之前就会先通过getChildMeasureSpec方法来得到子元素的MeasureSpec。从代码上来看，子 view 的 MeasureSpec 的创建与父容器的 MeasureSpec 、子 view 本身的 LayoutParams 有关，此外还与 view 本身的 margin 和 padding 值有关，具体看一下ViewGroup的 getChildMeasureSpec 方法：

```cpp
    /*
     * @param spec 父容器的 MeasureSpec，是对子 View 的约束条件
     * @param padding 当前 View 的 padding、margins 和父容器已经被占用空间值
     * @param childDimension View 期望大小值，即layout文件里设置的大小:可以是MATCH_PARENT,
     *WRAP_CONTENT或者具体大小, 代码中分别对三种做不同的处理
     * @return 返回 View 的 MeasureSpec 值
     */
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {

   // 获取父容器的 specMode，父容器的测量模式影响子 View  的测量模式
    int specMode = MeasureSpec.getMode(spec);
  // 获取父容器的 specSize 尺寸，这个尺寸是父容器用来约束子 View 大小的
    int specSize = MeasureSpec.getSize(spec);
  // 父容器尺寸减掉已经被用掉的尺寸
    int size = Math.max(0, specSize - padding);
    int resultSize = 0;
    int resultMode = 0;

    switch (specMode) {
     // 如果父容器是 EXACTLY 精准测量模式
    case MeasureSpec.EXACTLY:
        //如果子 View 期望尺寸为大于 0 的固定值，对应着 xml 文件中给定了 View 的具体尺寸大小
        //如 android:layout_width="100dp"
        if (childDimension >= 0) {
          //那么子 View 尺寸为期望值固定尺寸，测量模式为精准测量模式 EXACTLY
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
             //如果子 View 期望尺寸为 MATCH_PARENT 填充父布局
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
            // 那么子 View 尺寸为 size 最大值，即父容器剩余空间尺寸，为精准测量模式 EXACTLY
          //即子 View 填的是 Match_parent, 那么父 View 就给子 View 自己的size(去掉padding)，
          //即剩余全部未占用的尺寸, 然后告诉子 View 这是 Exactly 精准的大小，你就按照这个大小来设定自己的尺寸
            resultSize = size;
            resultMode = MeasureSpec.EXACTLY;
          //如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
          //子 View 尺寸为 size  最大值，即父容器剩余空间尺寸 ，测量模式为 AT_MOST 最大测量模式
          //即子 View 填的是 wrap_Content,那么父 View 就告诉子 View 自己的size(去掉padding),
          //即剩余全部未占用的尺寸,然后告诉子 View, 你最大的尺寸就这么多，不能超过这个值, 
          //具体大小，你自己根据自身情况决定最终大小。一般当我们继承 View 基类进行自定义 View  的时候
          //需要在这种情况下计算给定 View 一个尺寸，否则当使用自定义的 View 的时候，使用 
          // android:layout_width="wrap_content" 属性就会失效
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;
    // 父容器为 AT_MOST 最大测量模式
    case MeasureSpec.AT_MOST:
           // 子 View 期望尺寸为一个大于 0的具体值，对应着 xml 文件中给定了 View 的具体尺寸大小
        //如 android:layout_width="100dp"
        if (childDimension >= 0) {
           //那么子 View 尺寸为期望固定值尺寸，为精准测量模式 EXACTLY
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
          //如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
             //子 View 尺寸为 size，测量模式为 AT_MOST  最大测量模式
          //即如果子 View 是 Match_parent,那么父 View 就会告诉子 View, 
          //你的尺寸最大为 size 这么大（父容器尺寸减掉已经被用掉的尺寸，即父容器剩余未占用尺寸），
          //你最多有父 View的 size 这么大，不能超过这个尺寸，至于具体多大，你自己根据自身情况决定。
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
             //同上
            resultSize = size;
            resultMode = MeasureSpec.AT_MOST;
        }
        break;
    // 父容器为 UNSPECIFIED 模式
    case MeasureSpec.UNSPECIFIED:
           // 子 View 期望尺寸为一个大于 0的具体值
        if (childDimension >= 0) {
             //那么子 View 尺寸为期望值固定尺寸，为精准测量模式 EXACTLY
            resultSize = childDimension;
            resultMode = MeasureSpec.EXACTLY;
           //如果子 View 期望尺寸为 MATCH_PARENT 最大测量模式
        } else if (childDimension == LayoutParams.MATCH_PARENT) {
              //子 View 尺寸为 0，测量模式为 UNSPECIFIED
           // 父容器不对 View 有任何的限制，要多大给多大
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
           //如果子 View 期望尺寸为 WRAP_CONTENT ，包裹内容
        } else if (childDimension == LayoutParams.WRAP_CONTENT) {
             //子 View 尺寸为 0，测量模式为 UNSPECIFIED
             // 父容器不对 View 有任何的限制，要多大给多大
            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
            resultMode = MeasureSpec.UNSPECIFIED;
        }
        break;
    }
    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
```

  上述方法的主要作用就是根据父容器的MesaureSpec，同时结合View本身的LayoutParams来确定子元素的Measure，参数中的padding是指父容器中的已经占用的控件大小，子元素的可用的控件的大小为父容器的尺寸减去padding。

```cpp
int  specSize = MeasureSpec.getSize(spec);
int  size = Math.max(0,specSize- padding);
```

  getChildMeasureSpec() 清楚展示了普通View的MeasureSpec的创建规则。根据父容器的 MeasureSpec 和 view 本身的 LayoutParams 来确定子元素的 MeasureSpec 的整个过程，这个过程清楚的展示了普通 view 的 MeasureSpec 的创建规则，整理一下（图片来源艺术探索）。



![img](https:////upload-images.jianshu.io/upload_images/1869441-47339072b6fd5478.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



  只要提供了父容器的MeasureSpec和子元素的LayoutParams，就可以快速地确定子元素的MeasureSpec，有了MeasureSpec就可以进一步确定子元素测量后的大小。
 总结：

1. 当View是固定的宽高的时候，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式，并且大小是LayoutParams 中的大小。
2. 当View的宽高是match_parent的时候，如果父容器的模式是精确模式，那么 View 也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么 View 也是最大模式，并且大小是不会超过父容器的剩余空间。
3. 当 View 的宽高是 wrap_content 时，不管父容器的模式是精确模式还是最大模式，View 的模式总是最大模式，并且大小不超过父容器的剩余空间。

##### [4] View 的measure过程

  View 的工作流程主要是指 measure、layout、draw 这三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽和高，layout 确定 View 的最终宽和高及 View 的四个顶点位置，而 draw 是将 View 绘制到屏幕上。

**4.1  measure过程**

  measure过程要分情况，如果只是一个原始的View，那么通过measure方法就完成了测量过程，如果是ViewGroup，那么就需要首先测量自己的过程，然后再遍历调用子元素的measure方法，各个子元素在地柜去执行这个流程，下面是对这两种情况的分别讨论。

**4.1.1 View的Measure过程**

  View 的 measure 过程由 measure 方法来完成， measure 方法是一个 final 类型，子类不可以重写，而 View 的 measure() 方法中会调用 onMeasure 方法，因此我们只需要分析 onMeasure 方法即可，源码如下：



```java
 /**
  * @param widthMeasureSpec 父容器所施加的水平方向约束条件
  * @param heightMeasureSpec 父容器所施加的竖直方向约束条件
  */
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
  //设置 view 高宽的测量值
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
```

  上面方法很简单，setMeasuredDimension方法就是给 View 设置了测量高宽的测量值，而这个测量值是通过 getDefaultSize 方法获取，那么接着分析 getDefaultSize 方法：



```java
 /**
   * @param size view 的默认尺寸，一般表示设置了android:minHeight属性
   *  或者该View背景图片的大小值 
   * @param measureSpec 父容器的约束条件 measureSpec
   * @return 返回 view 的测量尺寸
   */
public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
  //获取测量模式
    int specMode = MeasureSpec.getMode(measureSpec);
  //获取尺寸
    int specSize = MeasureSpec.getSize(measureSpec);
    switch (specMode) {
            case MeasureSpec.UNSPECIFIED:
            //如果 测量模式为 UNSPECIFIED ，表示对父容器对子 view 没有限制，那么 view 的测量尺寸为
          //默认尺寸 size
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        //如果测量模式为 AT_MOST 最大测量模式或者 EXACTLY 精准测量模式，
        //那么 View 的测量尺寸为 MeasureSpec 的 specSize
        //即父容器给定尺寸（父容器当前剩余全部空间大小）。
        result = specSize;
        break;
    }
    return result;
}
```

  getDefaultSize方法的逻辑很简单，如果 测量模式为 UNSPECIFIED ，表示对父容器对子 view 没有限制，那么 view 的测量尺寸为默认尺寸 size。如果测量模式为 AT_MOST 最大测量模式或者 EXACTLY 精准测量模式，那么 View 的测量尺寸为 MeasureSpec 的 specSize，即父容器给定尺寸（父容器当前剩余全部空间大小）。

  这里来分析一下 UNSPECIFIED 条件下 View 的测量高宽默认值 size 是通过 getSuggestedMinimumWidth() 和 getSuggestedMinimumHeight() 函数获取，这两个方法原理一样，这里我们就看一下 getSuggestedMinimumHeight() 源码：



```csharp
protected int getSuggestedMinimumHeight() {
  return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());

protected int getSuggestedMinimumWidth() {
  return (mBackground == null) ? mMinWidth : max(mMinWidth , mBackground.getMinimumWidth());
}
```

  从getSuggestedMinimumHeight代码可以看出，如果 View 没有背景，View 的高度就是 mMinHeight，这个 mMinHeight 是由 android：minHeight 这个属性控制，可以为 默认为0，如果有背景，就返回 mMinHeight 和背景的最小高度两者中的最大值；同理getSuggestedMinimumWidth也是一样。



```java
public  int  getMinimumWidth(){
    final  int  intrinsicWidth =  getInstrinsicWidth();
    return intrinsicWidth >0?intrinsicWidth  : 0;
}
```

  getMinimumWidth方法返回的就是Drawable的原始宽度，前提是这个Drawable的原始宽度，否则就返回0。

  从 getDefaultSize 方法可以看出，View 的高/宽是由 父容器传递进来的 specSize 决定，因此可以得出结论： **直接继承自 View 的自定义控件需要重写 onMeasure 方法并设置 wrap_content 时候的自身大小**，而设置的具体值需要根据实际情况自己去计算或者直接给定一个默认固定值，否则在布局中使用 wrap_content 时候就相当于使用 match_parent ，因为在布局中使用 wrap_content 的时候，它的 specMode 是 AT_MOST 最大测量模式，在这种模式下 View 的宽/高等于 speceSize 大小，即父容器中可使用的大小，也就是父容器当前剩余全部空间大小，这种情况，很显然，View 的宽/高就是等于父容器剩余空间的大小，填充父布局，这种效果和布局中使用 match_parent 一样，解决这个问题代码如下：



```java
  @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec);
  // 在 MeasureSpec.AT_MOST 模式下，给定一个默认值
  //其他情况下沿用系统测量规则即可
    if (widthSpecMode == MeasureSpec.AT_MOST
            && heightSpecMode == MeasureSpec.AT_MOST) {
        setMeasuredDimension(mWith, mHeight);
    } else if (widthSpecMode == MeasureSpec.AT_MOST) {
        setMeasuredDimension(mWith, heightSpecSize);
    } else if (heightSpecMode == MeasureSpec.AT_MOST) {
        setMeasuredDimension(widthSpecSize, mHeight);
    }
}
```

  上面代码中在 widthSpecMode 或 heightSpecMode 为 MeasureSpec.AT_MOST 我们就给定一个对应的 mWith 和 mHeight 默认固定值宽高，而这个默认值没有固定依据，需要我们根据自定义的 view 的具体情况去计算给定。

**4.1.2 ViewGroup 的 measure 过程**

  ViewGroup 除了完成自己的测量过程还会遍历调用所有子 View 的measure方法，而且各个子 View 还会递归执行这个过程，我们知道 View Group 继承自 View ，是一个抽象类，因此没有重写 View onMeasure 方法，也就是没有提供具体如何测量自己的方法，但是它提供了一个 measureChildren 方法，定义了如何测量子 View 的规则，代码如下：



```java
/**
 * @param widthMeasureSpec 该 ViewGroup 水平方向约束条件
 * @param heightMeasureSpec 该 ViewGroup 竖直方向约束条件
 */
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < size; ++i) {
      //逐一遍历获取得到 ViewGroup 中的子 View
        final View child = children[i];
        if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
          //对获取到的 子 view 进行测量
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}
```

我们再看一下对子 View 进行测量的 measureChild 方法 ：



```java
/**
 * @param child 要进行测量的子 view 
 * @param parentWidthMeasureSpec ViewGroup 对要进行测量的子 view 水平方向约束条件
 * @param parentHeightMeasureSpec  ViewGroup 对要进行测量的子 view 竖直方向约束条件
 */
protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
   //第一步，获取 View 的 LayoutParams
    final LayoutParams lp = child.getLayoutParams();
  //第二步，获取 view 的 WidthMeasureSpec，其中传入的几个参数说明：
  //parentWidthMeasureSpec 父容器的 WidthMeasureSpec
  //mPaddingLeft + mPaddingRight view 本身的 Padding 值，即内边距值
  // lp.width view 本身期望的宽度 with 值
    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
  //同上
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);
  // 第三步，根据获取的子 veiw 的 WidthMeasureSpec 和 HeightMeasureSpec 
   //调用子 view 的 measure 方法，对子 view 进行测量，具体后面的测量逻辑就是和我们前面分析 
  // view 的测量过程一样了。
    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
```

  measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着讲MeasureSpec直接传递给View的measure方法来进行测量。

  ViewGroup 并没有定义具体的测量过程，这是因为 ViewGroup 是一个抽象类，其不同子类具有不同的特性，导致他们的测量过程有所不同，不能有一个统一的 onMeasure 方法，所以其测量过程的 onMeasure 方法需要子类去具体实现，比如 LinearLayout 和 RelativeLayout 等，下面通过 LinearLayout 的 onMeasure 方法来分析一下 ViewGroup 的测量过程。



```java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (mOrientation == VERTICAL) {
      //垂直方向的 LinearLayout  测量方式
        measureVertical(widthMeasureSpec, heightMeasureSpec);
    } else {
      //水平方向的 LinearLayout 测量方式
        measureHorizontal(widthMeasureSpec, heightMeasureSpec);
    }
}
```

上面代码可以看出 ViewGroup 内部测量方式分为垂直方向和水平方向，两者原理基本一样，下面看一下垂直方向的 LinearLayout 测量方式，由于这个方法代码比较长，所以贴出重点部分：



```java
void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {
 ......................
    //记录总高度
    float totalWeight = 0;
    final int count = getVirtualChildCount();
  //获取测量模式
    final int widthMode = View.MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = View.MeasureSpec.getMode(heightMeasureSpec);
 ...........
    //第1步，对 LinearLayout 中的子 view 进行第一次测量
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        //获取子 view 的 LayoutParams 参数
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
      //第1.1步，满足该条件，第一次测量时不需要测量该子 view
        if (heightMode == View.MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // 满足该条件的话，不需要现在计算该子视图的高度。
            //因为 LinearLayout 的高度测量规格为 EXACTLY ，说明高度 LinearLayout 是固定的，
            //不依赖子视图的高度计算自己的高度
            //lp.height == 0 && lp.weight > 0 说明子 view 使用了权重模式，即希望使用 LinearLayout 的剩余空间
            // 测量工作会在之后进行
            //相反，如果测量规格为 AT_MOST 或者 UNSPECIFIED ，LinearLayout
            // 只能根据子视图的高度来确定自己的高度，就必须对所有的子视图进行测量。
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            //标记未进行测量
            skippedMeasure = true;
        } else {
          //  else 语句内部是对子 view 进行第一次测量
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // 如果 LiniearLayout 不是 EXACTLY 模式，高度没给定，
              //说明 LiniearLayout 高度需要根据子视图来测量，
                // 而此时子 view 模式为 lp.height == 0 && lp.weight > 0 ，是希望使用 LinearLayout 的剩余空间
                // 这种情况下，无法得出子 view 高度，而为了测量子视图的高度，
              //设置子视图 LayoutParams.height 为 wrap_content。
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            //该方法只是调用了 ViewGroup 的 measureChildWithMargins() 对子 view 进行测量
            // measureChildWithMargins() 方法在上面 4 MeasureSpec和LayoutParams的对应关系已经分析过
            measureChildBeforeLayout(
                    child, i, widthMeasureSpec, 0, heightMeasureSpec,
                    totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            // 获取测量到的子 view 高度
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            //第2步， 重新计算 LinearLayout 的 mTotalLength 总高度
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                    lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
    ..........................
        //以下方法是对 LinearLayout 宽度相关的测量工作，不是我们关心的
        if (widthMode != View.MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            .........................
    //以上方法是对 LinearLayout 宽度相关的测量工作
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    //第3步，如果设置了 android:measureWithLargestChild="true"并且测量模式为 AT_MOST或者 UNSPECIFIED
    // 重新计算 mTotalLength 总高度
    if (useLargestChild &&
            (heightMode == View.MeasureSpec.AT_MOST || heightMode == View.MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)
                    child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            //每个子视图的高度为：最大子视图高度 ＋ 该子视图的上下外边距
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight +
                    lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    //第4步，根据 heightMeasureSpec 测量模式 和已经测量得到的总高度 heightSize
    //来确定得到最终 LinearLayout 高度和状态
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
          
    //分割线=================以上代码就完成了对  LinearLayout 高度和状态 的测量
    //第5步，下面代码是根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 view 的大小
    //获取 LinearLayout 高度值
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    //获取最终测量高度和经过测量各个子 view 得到的总高度差值
    int delta = heightSize - mTotalLength;
    //第5.1步（第5步中第1小步），如果在上面第一次测量子 view 的过程中有未进行测量的 view 那么执行下面代码
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // 计算 weight 属性分配的大小，可能为负值
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,
                        mPaddingLeft + mPaddingRight +
                                lp.leftMargin + lp.rightMargin, lp.width);
                // TODO: Use a field like lp.isMeasured to figure out if this
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != View.MeasureSpec.EXACTLY)) {
                    // 子视图在第一次测量时候已经测量过
                    // 基于上次测量值再次进行新的测量
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    // 调用子 view 的 measure 方法进行测量，后面逻辑就是 view 的测量逻辑
                    child.measure(childWidthMeasureSpec,
                            View.MeasureSpec.makeMeasureSpec(childHeight, View.MeasureSpec.EXACTLY));
                } else {
                    // 子视图第一次测量，即第一步进行测量的时候未得到测量
                    //对 view 进行测量
                    child.measure(childWidthMeasureSpec,
                            View.MeasureSpec.makeMeasureSpec(share > 0 ? share : 0,
                                    View.MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState()
                        & (MEASURED_STATE_MASK>>MEASURED_HEIGHT_STATE_SHIFT));
            }
            // 处理子视图宽度
            final int margin =  lp.leftMargin + lp.rightMargin;
           ...........................
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
        // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        //第5.2步（第5步中第2小步）执行到这里的代码，表明 view 是已经测量过的
        alternativeMaxWidth = Math.max(alternativeMaxWidth,
                weightedMaxWidth);
        // We have no limit, so make all weighted views as tall as the largest child.
        // Children will have already been measured once.
        if (useLargestChild && heightMode != View.MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp =
                        (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                //如果 view 使用了权重即 childExtra > 0，使用最大子视图高度进行重新测量
                //否则不进行测量，保持第一次测量值，那么由于 LinearLayout 的高度使用了子 view 最大高度 ，
                // 但是子视图没有进行重新测量，没有进行拉伸，可能造成空间剩余。
                if (childExtra > 0) {
                    //使用最大子视图高度进行重新测量子 view 
                    child.measure(
                            View.MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(),
                                    View.MeasureSpec.EXACTLY),
                            View.MeasureSpec.makeMeasureSpec(largestChildHeight,
                                    View.MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != View.MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    //第6步，最终设置 LinearLayout 的测量高宽
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
            heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
```

  从上面的这段代码可以看出，系统会遍历子元素并对每个子元measureChildBeforeLayout 方法，这个方法内部会调用子元素的measure方法，这样各个子元素就可以一次进入measure过程，并且系统会通过mTotalLength这个变量来存储LinearLayout在竖直方向的初步高度。每次测量一个子元素，mTotalLength就会增加，增加的部分主要包括了子元素的高度和子元素在竖直方向上的margin等。

  以上代码就是对 LinearLayout onMeasure 分析过程，整个过程原理已经在代码中加以注释说明，这里我们重点分析一下 resolveSizeAndState(heightSize, heightMeasureSpec, 0) 这个方法是如何实现最终确定 LinearLayout 高度值的，方法如下：



```java
/**
 * @param size view 想要的大小，也就是根据子 view 高度测量得到的高度值.
 * @param measureSpec 父容器的约束条件
 * @param childMeasuredState 子 view 的测量信息
 * @return Size 返回得到的测量值和状态
 */
public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {
  //获取测量模式
    final int specMode = MeasureSpec.getMode(measureSpec);
  //获取尺寸值
    final int specSize = MeasureSpec.getSize(measureSpec);
    final int result;
  //根据不同测量模式决定最终测量结果
    switch (specMode) {
        //如果是 AT_MOST 最大测量模式 ，那么总高度值为测量得到的 size 值，但是最大不能超过 specSize 规定值
        case MeasureSpec.AT_MOST:
            if (specSize < size) {
              //如果测量得到的 size 值超过 specSize 值，LinearLayout 高度就为 specSize 值
                result = specSize | MEASURED_STATE_TOO_SMALL;
            } else {
              //如果测量得到的 size 值未超过 specSize 值，LinearLayout 高度就为 size 值
                result = size;
            }
            break;
        case MeasureSpec.EXACTLY:
       //如果是 EXACTLY 精准测量模式，即 LinearLayout 值为固定值，那么 最终 LinearLayout 高度值就为 specSize 值
            result = specSize;
            break;
        case MeasureSpec.UNSPECIFIED:
        // 如果是 UNSPECIFIED 测量模式，即对子 view 没有限制 ， LinearLayout 高度值就为 size
        default:
            result = size;
    }
    return result | (childMeasuredState & MEASURED_STATE_MASK);
}
```

  以上代码总结起来就是 LinearLayout 会根据测量子 View 的情况和 MeasureSpec 约束条件来决定自己最终的大小，具体来说就是如果它的布局中高度才用 具体数值，那么它的测量过程和 View 一致，即高度为 specSize 值，如果它的布局中使用 wrap_content 那么它的高度是所有子 View 高度总和，但是不能超过父容器剩余空间。

最后对整个测量过程总结一下就是分为以下几步：

1. 对 LinearLayout 中的子 View 进行第一次遍历测量，主要是通过 measureChildBeforeLayout 这个方法，这个方法内部会调用 measureChildWithMargins 方法，而在 measureChildWithMargins 方法内部会去调用 child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 方法进行测量。在这次的测量过程中，如果满足了第1.1步测量条件的子 view 不需要进行测量，会在后面的第5.1步中进行测量。
2. 根据测量各个子 View 的高度会得到一个初步的 LinearLayout 总高度 mTotalLength 值。
3. 如果 LinearLayout 设置了 android:measureWithLargestChild=”true” 属性并且测量模式为 AT_MOST或者 UNSPECIFIED 重新计算 mTotalLength 总高度。
4. 根据 LinearLayout 的 heightMeasureSpec 测量模式 和已经测量得到的总高度 mTotalLength ，来确定得到最终 LinearLayout 高度和状态 。
5. 根据已经测量得到的 LinearLayout 高度来重新测量确定各个子 View 的大小。
6. 最终执行 setMeasuredDimension 方法设置 LinearLayout 的测量高宽。

##### [5] 在实际measure中View无法获取宽高信息的问题解决

  View的measure过程和Activity的生命周期实际上是不同步的。所以将当View还没有测量完毕，那么获取的宽高就是0，这里有四种方法解决这个问题：

**1. Activity/View#onWindowFocusChanged**

  onWindowFocusChanged方法表示View已经初始化了，宽高已经准备好了，这时候获取就没有问题。需要注意的是，onWindowFocusChanged会被调用多次，当Activity的窗口得到和失去焦点时均会被调用一次。具体说，当Activity继续执行和暂停执行的时候，onWindowFocusChanged均会被调用，如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用。代码如下：



```java
public void onWindowFocusChanged(boolean hasWindowFocus) {
         super.onWindowFocusChanged(hasWindowFocus);
       if(hasWindowFocus){
       int width=view.getMeasuredWidth();
       int height=view.getMeasuredHeight();
      }      
  }
```

**2. view.post(runnable)**

  通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，View也初始化好了，代码如下：



```java
@Override
protected void onStart() {
    super.onStart();
    view.post(new Runnable() {
        @Override
        public void run() {
            int width=view.getMeasuredWidth();
            int height=view.getMeasuredHeight();
        }
    });
}
```

**3. ViewTreeObsever**

  使用ViewTreeObsever的众多回调可以完成这个功能，比如使用onGlobalLayoutListener 这个接口，当View树状态发生改变或者View树内部的View的可见性发生改变时，onGlobalLayout 方法将被回调。伴随着View树的变化，这个方法也会被多次调用。



```java
@Override
protected void onStart() {
    super.onStart();
    ViewTreeObserver viewTreeObserver=view.getViewTreeObserver();
    viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            int width=view.getMeasuredWidth();
            int height=view.getMeasuredHeight();
        }
    });
}
```

**4. view.measure(int widthMeasureSpec, int heightMeasureSpec)**

通过手动对View进行measure来得到View的宽高。这种方式比较复杂，需要分情况处理。根据View的LayoutParams来分：
 **（1） match_parent ：**无法measure出具体的宽高。因为在View的measure过程中，构造这种MeasureSpec需要知道parentSize，即知道父容器的剩余空间，match_parent是一个不确定值，所以理论上不能测量大小。

**（2） wrap_content ：** 可以采用设置最大值方法进行 measure ：

```cpp
int widthMeasureSpec = MeasureSpec.makeMeasureSpec((1 << 30) - 1, MeasureSpec.AT_MOST);
int heightMeasureSpec = MeasureSpec.makeMeasureSpec((1 << 30) - 1, MeasureSpec.AT_MOST);
view.measure(widthMeasureSpec, heightMeasureSpec);
```

  通过分析 MeasureSpec 的实现可以得知 View 的尺寸是使用 30 位的二进制表示，也就是说最大是 30 个 1 即（2^30-1)，也就是 (1 << 30) - 1 )，在最大化模式下，使用 View 能支持的最大值去构造 MeasureSpec 是合理的。为什么这样就合理呢？我们前面分析在子 View 使用 wrap_content 模式的时候，其测量规则是根据自身的情况去测量尺寸，但是不能超过父容器的剩余空间的最大值，换句话说就是父容器给子 View 一个最大值，然后告诉子 View 你自己看着办，但是别超过这个尺寸就行，但是现在我们自己去测量的时候不知道父容器给定的 MeasureSpec 情况， 也就是不知道父容器给多大的限定值，需要自己去构造一个MeasureSpec ，那么这个最大值我们给定多少合适呢？所以这里干脆就给一个 View 所能支持的最大值，然子 View 根据自身情况去测量，怎么也不能超过这个值就行了。

  关于View的measure,有两个常见的错误用法。理由是首先其违背了系统的内部实现规范（因为不能通过错误的MeasureSpec来得到合法的SpecMode，从而导致measure过程出错），其次是不能保证一定能measure出正确的结果。

1. 



```cpp
int widthMeasureSpec = MeasureSpec.makeMeasureSpec(-1, MeasureSpec.UNSPECIFIED）;
int  heightMeasureSpec = MeasureSpec.makeMeasureSpec(-1,MeasureSpec.UNSPECIFIED);
view.measure (widthMeasureSpec,heightMeasureSpec);
```

1. 



```css
view.measure(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT);
```

**（3）具体的数值（dp/px）:** 例如100px



```cpp
int widthMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100, MeasureSpec.EXACTLY);
view.measure(widthMeasureSpec, heightMeasureSpec);
```

##### [6] View的Layout过程

  Layout过程是ViewGroup的用来确定子元素的位置的，当ViewGroup的位置确定了之后，它在onLayout中会遍历所有的子元素，并调用其layout方法，在layout方法中onLayout方法又会被调用。Layout过程比较简单，layout方法确定了View本身的位置，onlayout方法会确定所有子元素的位置，代码如下：



```csharp
 /* 
 *@param l view 左边缘相对于父布局左边缘距离
 *@param t view 上边缘相对于父布局上边缘位置
 *@param r view 右边缘相对于父布局左边缘距离
 *@param b view 下边缘相对于父布局上边缘距离
 */
 public void layout(int l, int t, int r, int b) {
 if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
      onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
      mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
  }
  //记录 view 原始位置
  int oldL = mLeft;
  int oldT = mTop;
  int oldB = mBottom;
  int oldR = mRight;
//第1步，调用 setFrame 方法 设置新的 mLeft、mTop、mBottom、mRight 值，
//设置 View 本身四个顶点位置
//并返回 changed 用于判断 view 布局是否改变
  boolean changed = isLayoutModeOptical(mParent) ?
          setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
             //第二步，如果 view 位置改变那么调用 onLayout 方法设置子 view 位置
             if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
    //调用 onLayout
      onLayout(changed, l, t, r, b);
      mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;
      ListenerInfo li = mListenerInfo;
      if (li != null && li.mOnLayoutChangeListeners != null) {
          ArrayList<OnLayoutChangeListener> listenersCopy =
                  (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();
          int numListeners = listenersCopy.size();
          for (int i = 0; i < numListeners; ++i) {
              listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
          }
      }
  }
```

  layout 方法大致流程：先通过上面代码第一步调用 setFrame 设置 view 本身四个顶点位置，其中 setOpticalFrame 内部也是调用 setFrame 方法来完成设置的，即为 View 的4个成员变量（mLeft，mTop，mRight，mBottom）赋值，View 的四个顶点一旦确定，那么 View 在父容器中的位置就确定了，接着进行第二步，调用 onLayout 方法，这个方法用途是父容器确定子 View 位置，和 onMeasure 方法类似， onLayout 方法的具体实现同样和具体布局有关，所以 View 和 ViewGroup 中都没有真正实现 onLayout 方法，都是一个空方法。 View 的 onLayout 方法：



```java
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
   if (mOrientation == VERTICAL) {
       layoutVertical(l, t, r, b);
   } else {
       layoutHorizontal(l, t, r, b);
   }
}
```

 和 onMeasure 类似，这里也是分为竖直方向和水平方向的布局安排，二者原理一样，我们选择竖直方向的 layoutVertical 来进行分析，这里给出主要代码如下：



```java
void layoutVertical(int left, int top, int right, int bottom) {
    final int paddingLeft = mPaddingLeft;
  //记录子 View 上边缘相对于父容器上边缘距离
    int childTop;
    //记录子 View 左边缘相对于父容器左边缘距离
    int childLeft;
  //第1步，主要是根据不同的 gravity 属性来确定子元素的 child 的位置
    switch (majorGravity) {
           case Gravity.BOTTOM:
               // mTotalLength contains the padding already
               childTop = mPaddingTop + bottom - top - mTotalLength;
               break;
               // mTotalLength contains the padding already
           case Gravity.CENTER_VERTICAL:
               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
               break;
           case Gravity.TOP:
           default:
               childTop = mPaddingTop;
               break;
        }
   ...............................
//第2步，循环遍历子 view 
    for (int i = 0; i < count; i++) {
      //获取指定位置 view 
        final View child = getVirtualChildAt(i);
        if (child == null) {
            childTop += measureNullChild(i);
        } else if (child.getVisibility() != GONE) {
          //第2.1步，如果 view 可见，获取 view  的测量宽/高
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();
            //获取 view  的 LayoutParams 参数
            final LinearLayout.LayoutParams lp =
                    (LinearLayout.LayoutParams) child.getLayoutParams();
        .............
            if (hasDividerBeforeChildAt(i)) {
                childTop += mDividerHeight;
            }
            
            childTop += lp.topMargin;
          //第3步，设置子 view 位置
            setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                    childWidth, childHeight);
          //第4步，重新计算子 view 的 顶部 top 位置，也就是每增加一个子 view 
          //下一个子 view 的 top 顶部位置就会相应的增加
            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);
            i += getChildrenSkipCount(child, i);
        }
    }
}
```

  简单梳理下整个流程，此方法会遍历所有子 view ，并调用 setChildFrame 方法来设定子元素位置，然后重新计算 childTop ，childTop 随着子元素的遍历而逐渐增大，这就意味着后面的子元素会被放置在当前子元素的下方，这正是我们平时使用竖直方向 LinearLayout 的特性。这里我们看一下第三步执行的 setChildFrame 方法类设置子元素位置方法代码：



```cpp
private void setChildFrame(View child, int left, int top, int width, int height) {        
    child.layout(left, top, left + width, top + height);
}
```

  我们注意到，setChildFrame中的width和height 实际上就是子元素的测量宽高，从下面的代码可以看出：



```dart
final int childWidth  = child.getMeasuredWidth();
final int childHeight = child.getMeasuredHeight();
setChildFrame(child,childLeft,childTop+getLocationOffset(child),childWidth,childHeight);
```

  在layout方法中会设置setFrame去设置子元素的四个顶点的位置，



```swift
mLeft = left;
mTop = top;
mRight = right;
mBottom = bottom;
```

  也就是说在 LinearLayout 中其子视图显示的宽和高由 measure 过程来决定的，因此 measure 过程的意义就是为 layout 过程提供视图显示范围的参考值。为什么说是提供参考值呢？因为 layout 过程中的4个参数 left, top, iwidth, height 完全可以由视图设计者任意指定，而最终视图的布局位置和大小完全由这4个参数决定，measure 过程得到的mMeasuredWidth 和 mMeasuredHeight 提供了视图大小的测量值，只是提供一个参考一般情况下我们使用这个参考值，但我们完全可以不使用这两个值，而自己在 layout 过程中去设定一个值，可见 measure 过程并不是必须的。

  说到这里就不得说一下 getWidth() 、getHeight() 和 getMeasuredWidth()、getMeasuredHeight() 这两对函数之间的区别，即 View 的测量宽/高和最终显示宽/高之间的区别。首先我们看一下 getWith() 和 getHeight() 方法的具体实现：



```java
public final int getWidth() {
    return mRight - mLeft;
}
 public final int getHeight() {
        return mBottom - mTop;
    }
```

  通过 getWith() 和 getHeight() 源码和上面 setChildFrame(View child, int left, int top, int width, int height) 方法设置子元素四个顶点位置的四个变量 mLeft、mTop、mRight、mBottom 的赋值过程来看，默认情况下 getWidth() 、getHeight() 方法返回的值正好就是 view 的测量宽/高，只不过 view 的测量宽/高形成于 view 的measure 过程，而最终宽/高形成于 view 的 layout 方法中，但是对于特殊情况，两者的值是不相等的，就是我们在 layout 过程中不按默认常规套路出牌，即不使用 measure 过程得到的 mMeasuredWidth 和 mMeasuredHeight ，而是人为的去自己根据需要设定的一个值的情况，例如以下代码，重写 view 的 layout 方法：



```java
public void layout(int l, int t, int r, int b) {
  //在得到的测量值基础上加100
    super.layout(int l, int t, int r+100, int b+100);
    }
```

上面代码会导致在任何情况下 view 的最终宽/高总会比测量宽高大100px。

##### [7] View的draw过程

  Draw过程比较简单，它的作用就是讲View绘制到屏幕上。View的绘制过程有以下几步：

1. 绘制背景 background.draw(canvas)
2. 绘制自己 （onDraw）
3. 绘制children（dispatchDraw）
4. 绘制装饰 （onDrawScrollBars）

源码如下：

```java
public void draw(Canvas canvas) {
    final int privateFlags = mPrivateFlags;
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    /*
     * Draw traversal performs several drawing steps which must be executed
     * in the appropriate order:
     *
     *      1. Draw the background
     *      2. If necessary, save the canvas' layers to prepare for fading
     *      3. Draw view's content
     *      4. Draw children
     *      5. If necessary, draw the fading edges and restore layers
     *      6. Draw decorations (scrollbars for instance)
     */
    // Step 1, draw the background, if needed
  //绘制背景
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);
    }
    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
      //调用 onDraw 方法，绘制自己本身内容，这个方法是个空方法，没有具体实现，
      //因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现，
      //如果要自定义 view ，需要重载该方法完成绘制工作
        if (!dirtyOpaque) onDraw(canvas);
        // Step 4, draw the children
      //绘制子视图
      //View 中的 dispatchDraw()方法也是一个空方法，因为 view 本身没有子视图，所以不需要，
      //而 ViewGroup 的 dispatchDraw() 方法中就会有具体的绘制代码，来实现子视图的绘制工作
        dispatchDraw(canvas);
        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }
        // Step 6, draw decorations (foreground, scrollbars)
      //绘制装饰
      //对视图的滚动条进行绘制，其实任何一个视图都是有滚动条的，只是一般情况下都没有让它显示出来，
      //而例如像 ListView 等控件是进行了显示而已。
        onDrawForeground(canvas);
        // we're done...
        return;
    }
```

  View的绘制过程的传递是dispatchDraw来实现的，dispatchDraw会遍历调用所有的子元素的draw方法，如此draw事件就一层层地传递下去。View有一个特殊的方法setWillNotDraw,先看看它的源码：



```dart
/**
 * If this view doesn't do any drawing on its own, set this flag to
 * allow further optimizations. By default, this flag is not set on
 * View, but could be set on some View subclasses such as ViewGroup.
 *
 * Typically, if you override {@link #onDraw(android.graphics.Canvas)}
 * you should clear this flag.
 *
 * @param willNotDraw whether or not this View draw on its own
 */
public void setWillNotDraw(boolean willNotDraw) {
    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
}
```

  看注释部分大概意思是，如果一个 View 不需要绘制任何内容，那么设置这个标记位为 true 后，系统会进行相应的优化，默认情况下 View 没有启动这个默认标记位，但 viewGroup 默认启用这个标记位，这个标记位对实际开发的意义是：当我们的自定义的控件继承自 viewGroup 并且本身不具备绘制功能的时候，就可以开启这个标记位，从而便于系统进行后续的优化工作，当我们明确知道 viewGrop 需要通过 onDraw 来绘制本身内容时，需要我们去关闭 WILL_NOT_DRAW 这个标记位。

**https://www.jianshu.com/p/f4e880f2b390**

作者：忆念成风
链接：https://www.jianshu.com/p/444d4683a1c4
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**https://www.jianshu.com/p/fbc9538487a5**

## 【Android事件分发机制】

> 在android开发中会经常遇到滑动冲突（比如ScrollView或是SliddingMenu与ListView的嵌套）的问题，需要我们深入的了解android事件响应机制才能解决，事件响应机制已经是android开发者必不可少的知识。

##### [1] 涉及到事件响应的常用方法构成

　　用户在手指与屏幕接触过程中通过**MotionEvent对象**产生一系列事件，它有四种状态： 　　

- MotionEvent.ACTION_DOWN：手指按下屏幕的瞬间（一切事件的开始）
- MotionEvent.ACTION_MOVE：手指在屏幕上移动
- MotionEvent.ACTION_UP：手指离开屏幕瞬间
- MotionEvent.ACTION_CANCEL：取消手势，一般由程序产生，不会由用户产生

　　Android中的事件onClick, onLongClick，onScroll, onFling等等，都是由许多个Touch事件构成的（一个ACTION_DOWN， n个ACTION_MOVE，1个ACTION_UP）。

　　android 事件响应机制是先 **分发**（先由外部的View接收，然后依次传递给其内层的最小View）再 **处理** （从最小View单元（事件源）开始依次向外层传递。）的形式实现的。

　　复杂性表现在：可以控制每层事件是否继续传递（分发和拦截协同实现），以及事件的具体消费（事件分发也具有事件消费能力）。

##### [2] android事件处理涉及到的三个重要函数

> **事件分发：public boolean dispatchTouchEvent(MotionEvent ev)**

　　　当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的dispatchTouchEvent(MotionEventev)方法，该方法对事件进行分发。 　　

- return true：表示该View内部消化掉了所有事件。
- return false：事件在本层不再继续进行分发，并交由**上层**控件的onTouchEvent方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。　
- 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent 方法进行处理

> **事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)**

- return true  ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；
- return false  ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　
- 如果返回super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前View的onTouchEvent方法，和return true一样。

> **事件响应：public boolean onTouchEvent(MotionEvent ev)**

　　在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。

- 如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；
- 如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；　　
- 如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。

> 从以上过程中可以看出，dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。

[![这里写图片描述](https://camo.githubusercontent.com/d0cf3f58f4a42af93085a1b9ab45baa5a45450a1/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343238313631313034333339)](https://camo.githubusercontent.com/d0cf3f58f4a42af93085a1b9ab45baa5a45450a1/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630343238313631313034333339)

（图来自网络）

##### [3] View源码分析

　　Android中ImageView、textView、Button等继承于View但没有重写的dispatchTouchEvent方法，所以都用的View的该方法进行事件分发。看View重要函数部分源码：

```java
public boolean dispatchTouchEvent(MotionEvent event) {
//返回true,表示该View内部消化掉了所有事件。返回false，表示View内部只处理了ACTION_DOWN事件，事件继续传递，向上级View(ViewGroup)传递。

    if (mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED &&
            mOnTouchListener.onTouch(this, event)) {
  //此处的onTouch方式就是回调的我们注册OnTouchListener时重写的onTouch()方法
        return true;
    }
    return onTouchEvent(event);
}
```

　首先进行三个条件的判断：

（1）查看是否给button设置了OnTouchListener()事件；

（2）控件是否Enable；（控件默认都是enable的）

（3）button里面实现的OnTouchListener监听里的onTouch()方法是否返回true；

　如果条件都满足，则该事件被消耗掉，不再进入onTouchEvent中处理。否则将事件将交给onTouchEvent方法处理。

```java
 public boolean onTouchEvent(MotionEvent event) {
    ...
 
   /＊ 当前onTouch的组件必须是可点击的比如Button，ImageButton等等，此处CLICKABLE为true，才会进入if方法，最后返回true。
 如果是ImageView、TexitView这些默认为不可点击的View,此处CLICKABLE为false，最后返回false。当然会有特殊情况，如果给这些View设置了onClick监听器，此处CLICKABLE也将为true　　＊／
 
    if (((viewFlags & CLICKABLE) == CLICKABLE ||  
            (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_UP:
                ...
                            if (!post(mPerformClick)) {
                                performClick();// 实际就是回调了我们注册的OnClickListener中重新的onClick()方法
                            }
                 ...
                break;
 
            case MotionEvent.ACTION_DOWN:
               ...
                break;
 
            case MotionEvent.ACTION_CANCEL:
                ...
                break;
 
            case MotionEvent.ACTION_MOVE:
               ...
                break;
        }
        return true;
    }
 
    return false;
}
public boolean performClick() {
    ...
 ／／
    if (li != null && li.mOnClickListener != null) {
        ...
        li.mOnClickListener.onClick(this);
        return true;
    }
 
    return false;
}
 public void setOnClickListener(OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}
```

> 只有我们注册OnTouchListener时重写的 onTouch()方法中
>
> 返回false  —> 执行onTouchEvent方法 —>  导致onClick()回调方法执行　

返回true —> onTouchEvent方法不执行 —>  导致onClick()回调方法不会执行

##### [4] ViewGroup源码分析

　　Android中诸如LinearLayout等的五大布局控件，都是继承自ViewGroup，而ViewGroup本身是继承自View，所以ViewGroup的事件处理机制对这些控件都有效。

　　 部分源码：

```java
public boolean dispatchTouchEvent(MotionEvent ev) {  
       final int action = ev.getAction();  
       final float xf = ev.getX();  
       final float yf = ev.getY();  
       final float scrolledXFloat = xf + mScrollX;  
       final float scrolledYFloat = yf + mScrollY;  
       final Rect frame = mTempRect;  
  
       //这个值默认是false, 然后我们可以通过requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法  
       //来改变disallowIntercept的值  
       boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;  
  
       //这里是ACTION_DOWN的处理逻辑  
       if (action == MotionEvent.ACTION_DOWN) {  
        //清除mMotionTarget, 每次ACTION_DOWN都很设置mMotionTarget为null  
           if (mMotionTarget != null) {  
               mMotionTarget = null;  
           }  
  
           //disallowIntercept默认是false, 就看ViewGroup的onInterceptTouchEvent()方法  
           if (disallowIntercept || !onInterceptTouchEvent(ev)) {  //第一点
               ev.setAction(MotionEvent.ACTION_DOWN);  
               final int scrolledXInt = (int) scrolledXFloat;  
               final int scrolledYInt = (int) scrolledYFloat;  
               final View[] children = mChildren;  
               final int count = mChildrenCount;  
               //遍历其子View  
               for (int i = count - 1; i >= 0; i--) {  //第二点
                   final View child = children[i];  
                     
                   //如果该子View是VISIBLE或者该子View正在执行动画, 表示该View才  
                   //可以接受到Touch事件  
                   if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  
                           || child.getAnimation() != null) {  
                    //获取子View的位置范围  
                       child.getHitRect(frame);  
                         
                       //如Touch到屏幕上的点在该子View上面  
                       if (frame.contains(scrolledXInt, scrolledYInt)) {  
                           // offset the event to the view's coordinate system  
                           final float xc = scrolledXFloat - child.mLeft;  
                           final float yc = scrolledYFloat - child.mTop;  
                           ev.setLocation(xc, yc);  
                           child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
                             
                           //调用该子View的dispatchTouchEvent()方法  
                           if (child.dispatchTouchEvent(ev))  {  
                               // 如果child.dispatchTouchEvent(ev)返回true表示  
                            //该事件被消费了，设置mMotionTarget为该子View  
                               mMotionTarget = child;  
                               //直接返回true  
                               return true;  
                           }  
                           // The event didn't get handled, try the next view.  
                           // Don't reset the event's location, it's not  
                           // necessary here.  
                       }  
                   }  
               }  
           }  
       }  
  
       //判断是否为ACTION_UP或者ACTION_CANCEL  
       boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
               (action == MotionEvent.ACTION_CANCEL);  
  
       if (isUpOrCancel) {  
           //如果是ACTION_UP或者ACTION_CANCEL, 将disallowIntercept设置为默认的false  
        //假如我们调用了requestDisallowInterceptTouchEvent()方法来设置disallowIntercept为true  
        //当我们抬起手指或者取消Touch事件的时候要将disallowIntercept重置为false  
        //所以说上面的disallowIntercept默认在我们每次ACTION_DOWN的时候都是false  
           mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  
       }  
  
       // The event wasn't an ACTION_DOWN, dispatch it to our target if  
       // we have one.  
       final View target = mMotionTarget;  
       //mMotionTarget为null意味着没有找到消费Touch事件的View, 所以我们需要调用ViewGroup父类的  
       //dispatchTouchEvent()方法，也就是View的dispatchTouchEvent()方法  
       if (target == null) {  
           // We don't have a target, this means we're handling the  
           // event as a regular view.  
           ev.setLocation(xf, yf);  
           if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
               ev.setAction(MotionEvent.ACTION_CANCEL);  
               mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           }  
           return super.dispatchTouchEvent(ev);  
       }  
  
       //这个if里面的代码ACTION_DOWN不会执行，只有ACTION_MOVE  
       //ACTION_UP才会走到这里, 假如在ACTION_MOVE或者ACTION_UP拦截的  
       //Touch事件, 将ACTION_CANCEL派发给target，然后直接返回true  
       //表示消费了此Touch事件  
       if (!disallowIntercept && onInterceptTouchEvent(ev)) {  
           final float xc = scrolledXFloat - (float) target.mLeft;  
           final float yc = scrolledYFloat - (float) target.mTop;  
           mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           ev.setAction(MotionEvent.ACTION_CANCEL);  
           ev.setLocation(xc, yc);  
             
           if (!target.dispatchTouchEvent(ev)) {  
           }  
           // clear the target  
           mMotionTarget = null;  
           // Don't dispatch this event to our own view, because we already  
           // saw it when intercepting; we just want to give the following  
           // event to the normal onTouchEvent().  
           return true;  
       }  
  
       if (isUpOrCancel) {  
           mMotionTarget = null;  
       }  
  
       // finally offset the event to the target's coordinate system and  
       // dispatch the event.  
       final float xc = scrolledXFloat - (float) target.mLeft;  
       final float yc = scrolledYFloat - (float) target.mTop;  
       ev.setLocation(xc, yc);  
  
       if ((target.mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
           ev.setAction(MotionEvent.ACTION_CANCEL);  
           target.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
           mMotionTarget = null;  
       }  
  
       //如果没有拦截ACTION_MOVE, ACTION_DOWN的话，直接将Touch事件派发给target  
       return target.dispatchTouchEvent(ev);  
   }
```

> 1、dispatchTouchEvent作用：决定事件是否由onInterceptTouchEvent来拦截处理。 返回super.dispatchTouchEvent时，由onInterceptTouchEvent来决定事件的流向 返回false时，会继续分发事件，自己内部只处理了ACTION_DOWN 返回true时，不会继续分发事件，自己内部处理了所有事件（ACTION_DOWN,ACTION_MOVE,ACTION_UP）

> 2、onInterceptTouchEvent作用：拦截事件，用来决定事件是否传向子View 返回true时，拦截后交给自己的onTouchEvent处理 返回false时，拦截后交给子View来处理

> 3、onTouchEvent作用：事件最终到达这个方法 返回true时，内部处理所有的事件，换句话说，后续事件将继续传递给该view的onTouchEvent()处理 返回false时，事件会向上传递，由onToucEvent来接受，如果最上面View中的onTouchEvent也返回false的话，那么事件就会消失

##### [5] 总结

- 如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；　
- 可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法。
- 子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true);  阻止ViewGroup对其MOVE或者UP事件进行拦截；　　
- 一个点击事件产生后，它的传递过程如下： Activity->Window->View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的onTouchEvent方法返回false，那么将会交给父容器的onTouchEvent方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的onTouchEvent进行处理。　
- 如果某一个View开始处理事件，如果他不消耗ACTION_DOWN事件（也就是onTouchEvent返回false），则同一事件序列比如接下来进行ACTION_MOVE，则不会再交给该View处理。
- ViewGroup默认不拦截任何事件。　
- 诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用onTouchEvent方法，它们本身没有onInterceptTouchEvent方法。正常情况下，它们都会消耗事件（返回true），除非它们是不可点击的（clickable和longClickable都为false），那么就会交由父容器的onTouchEvent处理。　
- 点击事件分发过程如下 dispatchTouchEvent—->OnTouchListener的onTouch方法—->onTouchEvent-->OnClickListener的onClick方法。也就是说，我们平时调用的setOnClickListener，优先级是最低的，所以，onTouchEvent或OnTouchListener的onTouch方法如果返回true，则不响应onClick方法...

# 安卓开发之路第一天（8.16）

### 事件1：阅读《第一行代码》P1-82

#### 第一章：第一行代码

##### 1.  安卓的发展

##### 2. 搭建开发环境

模拟器选择：**pixel**

##### 3. 创建第一个安卓开发环境

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817092618656.png" alt="image-20200817092618656" style="zoom:50%;" />

##### 4.详解安卓开发目录结构

* **grable是什么？**

Gradle 是一个基于 [Apache Ant](https://www.oschina.net/p/apache+ant) 和 [Apache Maven](https://www.oschina.net/p/maven) 概念的项目自动化构建工具，支持依赖管理和多项目，类似 [Maven](https://www.oschina.net/p/maven)，但比之简单轻便。它使用一种基于 [Groovy](https://www.oschina.net/p/groovy) 的特定领域语言来声明项目设置，而不是传统的 XML。

当前其支持的语言限于 Java、Groovy 和 Scala，计划未来将支持更多的语言。

1. **project目录**

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817100902922.png" alt="image-20200817100902922" style="zoom:80%;" />

2. **app目录**



<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200817101447841.png" alt="image-20200817101447841" style="zoom:80%;" />

3. **AndroidManifest**

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myfistapp">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

4. **Manifest**

```java
package com.example.myfistapp;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
//AppCompatActivity向下兼容的Activity
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //视图和逻辑分离，所以没有helloword
        super.onCreate(savedInstanceState);
        //引入了一个ContentView布局
        setContentView(R.layout.activity_main);
    }
}
```

5. **R.layout.activity_main**

~~~xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />


</androidx.constraintlayout.widget.ConstraintLayout>
~~~

6. **如何引用？**

代码中：R.layout.activity_main

XML中：android:icon="@mipmap/ic_launcher"

7.  外层grable

```java
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    //代码仓库
    repositories {
        google()
        jcenter()
    }
    //
    dependencies {
        classpath "com.android.tools.build:gradle:4.0.1"

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories 
        //两个插件
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁.

8. 内层grable

~~~java
apply plugin: 'com.android.application'

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.example.myfistapp"
        minSdkVersion 15
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'

}
~~~

##### 5. 掌握日志工具的使用

专业的！

* 日志开关可控制
* 可添加日志标签
* 日志级别可以区分

#### 第二章：快速入门Kotlin

##### 1.  语言简洁

##### 2  变量

自动转型：

val：对应final变量

var：对应final常量

##### 3.  函数

fun，单行代码可不加{}

##### 4.  逻辑控制语句（if  when for）

if：有返回值，每个条件中最后一行代码的返回值

when：有返回值，可以用->，**判断对象相等可以直接用==，判断引用相等===**

while和for：for-in,并且可以用until跳出区间

##### 5.  类

**类**：class

**方法**：fun

##### 6.  继承与构造函数

**继承**：默认不可被继承，加上open才可以

**构造函数：**这里比较复杂

##### 7.  接口

继承： **：**

实现： **，**

访问修饰符：Kotiln默认是public，另外还有internal关键字

##### 8. 数据类与单例类

class->object

##### 9. Lambda编程

**集合创建（更简洁）和遍历（for-in）！**

**集合的函数式API**：求一个集合里面的最大值，直接list.maxBy

**java函数API**

##### 10. 空指针检查

空指针异常解决：编译时期会直接报错

**？.**  可为空

**？：** 类似于java中的？：

##### 11.小魔术

**字符串内嵌表达式** 

**给参数的默认值**

# 安卓开发之路第二天（8.17）

#### 事件1： 复习+连接到手机

https://www.cnblogs.com/oreox/p/10662066.html

#### 事件2： 学习activty

##### 1. 编写按钮

~~~java
    <Button
        android:id="@+id/button" //定义一个唯一id
        android:layout_width="match_parent" //定义宽度，匹配父元素
        android:layout_height="wrap_content" //定义高度，刚好包含里面的内容wrap_content
        android:text="Button" /> //显示内容
~~~

##### 2. activity调用

~~~java
package com.example.mysecendacticity;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

public class FristActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        //调用父类默认实现
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
    }
}
~~~

##### 3. andoridMainActivity

~~~java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.mysecendacticity">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        //注册MainActivity，不然无法使用
        <activity android:name=".FristActivity"
            android:label="This is FristActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            </activity>
    </application>

</manifest>
~~~

##### 4. **toast**

```java
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class FirstActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.frist_layout);
        Button button1=(Button) findViewById(R.id.button1);
        button1.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Toast.makeText(FirstActivity.this, "You clicked Button 1", Toast.LENGTH_SHORT).show(); }
        });
    }
}
```

##### 5.**菜单**

~~~java
    @Override
    //菜单可见
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
    @Override
    //菜单响应时间
    public boolean onOptionsItemSelected(MenuItem item) {
        //使用item.getItemId()判断使用哪个菜单项
        switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
            default:
        }
        return true;
    }
}
~~~

##### 6.**intent**

~~~java
//显示       
button1.setOnClickListener(
                new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        //第一个参数Context 要求提供一个启动活动的上下文， 第二个参数Class 则是指定想要启动的目标活动
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                        startActivity(intent);
                    }
        });

    }
~~~

~~~xml
//隐式  

<activity android:name=".SecondActivity">
            <intent-filter> 
                <action android:name="com.example.activitytest.ACTION_START" /> 
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
        <activity
~~~

在<action> 标签中我们指明了当前活动可以响应 **com.example.activitytest.ACTION_START** 这个action ，而<category> 标签则包含 了一些附加信息，更精确地指明了当前的活动能够响应的Intent中还可能带有的**category** 。只 有<action> 和<category> 中的内容同时能够匹配上Intent中指定的**action** 和**category** 

时，这个活动才能响应该**Intent**。 

##### 7.[Intent的常用属性action和category](https://www.cnblogs.com/z-cg/p/12356168.html)

**设置隐式跳转时**，首先在我们按钮监听器中添加

```java
Intent i=new Intent();
//参数为字符串，可以添加包名.活动名
i.setAction("com.example.aaaaa.testliandong.MainActivity");
startActivity(i);
```

只是这样还不够，必须得在AndroidMainfest.xml文件中添加如下代码

```xml
 <activity android:name=".NewActivity">
             <intent-filter>
                 <action android:name="com.example.aaaaa.testliandong.MainActivity"/>
                 <category android:name="android.intent.category.DEFAULT"/>
             </intent-filter>
        </activity>
```

其中第一行和活动的声明一样，intent-filter标签中的action中name的值为和之前在Java中setAction的参数一样，category中的name值为android.intent.category.DEFAULT，DEFAULT则表示跳转为隐式跳转

可以看到，我们使用了Intent的另一个构造函数，直接将action 的字符串传了进去，表明我们 

想要启动能够响应com.example.activitytest.ACTION_START 这个action 的活动。那 前面不是说要<action> 和<category> 同时匹配上才能响应的吗？**怎么没看到哪里有指定 category 呢？**这是因为android.intent.category.DEFAULT 是一种默认的category ，在调用startActivity() 方法的时候会自动将这个category 添加到Intent中。 

##### 8.**Activity的Action(单个)和category（多个）属性**

https://blog.csdn.net/itszt888/article/details/76074243

介绍Action和Category的关系 
举一个例子,一个女孩子找男朋友,她有一些要求：男性、高、富、帅。 
男性相当于`Action`,`Action`这能有一个 
高富帅相当于`Category`,`Category`可以有很多 
而一个男性有很多特点,满足了很多女孩系择偶的标准,用如下图表示

![这里写图片描述](https://img-blog.csdn.net/20170725152114852?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRzenQ4ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

~~~java
//今天看了Activity，来跟大家分享一下它的Action属性和category属性
//下面页面为第一个页面，页面只有一个跳转按钮，此处不再给出页面布局
package a.a;

import android.app.Activity;
import android.os.Bundle;
import android.widget.*;
import android.view.*;
import android.view.View.OnClickListener;
import android.content.*;
public class Er extends Activity 
{
   private Button jump;
   private static final String MY_ACTION = "ery.src.a.a.MY_ACTION";
   private static final String MY_CATEGORY = "ery.src.a.a.MY_CATEGORY";
   public void onCreate(Bundle savedInstanceState) 
  {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.main);
       jump = (Button)findViewById(R.id.jump);
       jump.setOnClickListener(new OnClickListener()
       {
           public void onClick(View v)
           {
               //此处为intent添加了一个自定义action和一个自定义category属性，因此配置被启                        //动Activity在注册表androidmanifest.xml文件中要包括这样的两行配置:
               //<action android:name="ery.src.a.a.MY_ACTION" />和
               //<category android:name="ery.src.a.a.MY_CATEGORY" />，然而每一个Intent还                          //有一个默认的category，所以这个默认的也得注册，为:
               //<category android:name="android.intent.category.DEFAULT" />
               //总之归结起来，注册表中的Activity要想启动，必须包含对应Intent的Action属性
               //和Intent的所有category属性。(附：一个Intent只能有一个acton，但可以添加多                        //个category)
               Intent  intent = new Intent();
               intent.setAction(MY_ACTION);
               intent.addCategory(MY_CATEGORY);
                Er.this.startActivity(intent);
            }
        });
   }
}
//第二个页面，只有一个TextView，在此不再给出布局文件
package a.a;
import android.app.*;
import android.os.Bundle;
public class Second extends Activity
{
    protected void onCreate(Bundle savedInstanceState) 
    {
       super.onCreate(savedInstanceState);
       super.setContentView(R.layout.second);
    }
}
~~~

~~~xml

//AnaroidManifest.xml文件
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="a.a"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk android:minSdkVersion="15" />

    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <activity
            android:label="@string/app_name"
            android:name=".Er" >
            <intent-filter >
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name=".Second"
            android:theme="@android:style/Theme.Dialog" 
            >
            <intent-filter>
                <action android:name="ery.src.a.a.MY_ACTION" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="ery.src.a.a.MY_CATEGORY" />
                <category android:name="saer"/>
            </intent-filter>
        </activity>
    </application>

</manifest>

~~~

##### 9. 更多隐式**Intent**的用法 

使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得 Android多个应用程序之间的功能共享成为了可能。比如说你的应用程序中需要展示一个网页， 这时你没有必要自己去实现一个浏览器（事实上也不太可能），而是只需要调用系统的浏览器 来打开这个网页就行了。

~~~xml
        <activity android:name=".SecondActivity">
            <intent-filter>
                <action android:name="com.example.activitytest.ACTION_START" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="com.example.activitytest.MY_CATEGORY" />
            </intent-filter>
        </activity>
        <activity
~~~



我们在ThirdActivity的<intent-filter> 中配置了当前活动能够响应的action 

是Intent.ACTION_VIEW 的常量值，而category 则毫无疑问指定了默认的category 值， 

另外在<data> 标签中我们通过android:scheme 指定了数据的协议必须是http协议，这样 

ThirdActivity应该就和浏览器一样，能够响应一个打开网页的Intent了。



~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                //常量值
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~



 我们还可以在<intent-filter> 标签中再配置一个<data> 标签，用于**更精确地** 

**指定当前活动能够响应什么类型的数据**。<data> 标签中主要可以配置以下内容。 

android:scheme 。用于指定数据的协议部分，如上例中的http部分。 

android:host 。用于指定数据的主机名部分，如上例中的www.baidu.com部分。 

android:port 。用于指定数据的端口部分，一般紧随在主机名之后。 

android:path 。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内 

容。

android:mimeType 。用于指定可以处理的数据类型，允许使用通配符的方式进行指 

定。 

只有<data> 标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该 

Intent。不过一般在<data> 标签中都不会指定过多的内容，如上面浏览器示例中，其实**只需要** 

**指定android:scheme 为http，就可以响应所有的http协议的Intent了。** 

为了让你能够更加直观地理解，我们来自己建立一个活动，让它也能响应打开网页的Intent。

~~~xml
        <activity android:name=".ThirdActivity">
            <intent-filter tools:ignore="AppLinkUrlError">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:scheme="https" />
            </intent-filter>
        </activity>
~~~

##### 10.  向下一个activity传输数据

~~~java
        button1.setOnClickListener(new View.OnClickListener() {
            @Override
            //Intent中提供了一系列putExtra() 方法的重载，可以把 我们想要传递的数据暂存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出 就可以了
            public void onClick(View v) {
                String data = "Hello SecondActivity";
                Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
                intent.putExtra("extra_data", data);
                startActivity(intent);
            }
        });

    @Override
    protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.second_layout);
            Intent intent = getIntent();
            String data = ((Intent) intent).getStringExtra("extra_data");
            Log.d("SecondActivity", data); }
~~~

##### 11. 返回数据给上一个活动 

既然可以传递数据给下一个活动，那么能不能够返回数据给上一个活动呢？答案是肯定的。不 过不同的是，返回上一个活动只需要按一下Back键就可以了，并没有一个用于启动活动的Intent 来传递数据。通过查阅文档你会发现，Activity中还有一个**startActivityForResult() 方 法**也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 毫无疑问，这就是我们所需要的。 

startActivityForResult() 方法接收两个参数，第一个参数还是Intent，第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改FirstActivity中按钮的 点击事件，代码如下所示： 

~~~java
        button1.setOnClickListener(
                new View.OnClickListener() { 
                    @Override 
                    public void onClick(View v) { 
                        Intent intent = new Intent(FirstActivity.this, SecondActivity.class); 
                        startActivityForResult(intent, 1); } 
                });
~~~

# 安卓开发之路第三天（8.18）

# 安卓开发之路第四天（8.19）

# 安卓开发之路第五天（8.20）

# 安卓开发之路第六天（8.21）

### 天气预报App

#### 1. 需求分析

**酷欧天气中至少应该具备以下功能：**

1. 可以罗列出全国所有的省、市、县； 

2. 可以查看全国任意城市的天气信息； 

3. 可以自由地切换城市，去查看其他城市的天气； 

4. 提供手动更新以及后台自动更新天气的功能。

#### 2. 技术可行性分析（彩云天气）

我们 如何才能得到全国省市县的数据信息，以及如何才能获取到每个城市的天气信息。比较遗憾的 是，现在网上免费的天气预报接口已经越来越少，很多之前可以使用的接口都慢慢关闭掉了， 包括本书第1版中使用的中国天气网的接口。因此，这次我也是特意用心去找了一些更加稳定的 天气预报服务，比如彩云天气以及和风天气都非常不错。这两个天气预报服务虽说都是收费 的，但它们每天都提供了一定次数的免费天气预报请求。其中彩云天气的数据更加实时和专 业，可以将天气预报精确到分钟级，每天提供1000次免费请求；和风天气的数据相对简单一 些，比较适合新手学习，每天提供3000次免费请求。那么简单起见，这里我们就使用和风天气 来作为天气预报的数据来源，每天3000次的免费请求对于学习而言已经是相当充足了。

>https://id.heweather.com/#/login?redirect=https%3A%2F%2Fconsole.heweather.com%2F%23%2Fconsole

#### 3.  Gitee托管

https://gitee.com/xumingxiao/Sunny-Weather

#### 4.  搭建MVVM项目架构

#### 5 创建数据库和表

~~~java
dependencies {
    implementation fileTree(dir: "libs", include: ["*.jar"])
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
    //添加依赖项,使用LitePal对数据库进行操作
    implementation 'org.litepal.android:java:3.0.0'
}
~~~

~~~java
dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'androidx.appcompat:appcompat:1.3.0-alpha01'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    implementation 'androidx.legacy:legacy-support-v4:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.3.0-rc03'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0-alpha4'
    //
    implementation 'org.litepal.android:java:3.0.0'
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.3.0'
    implementation 'com.squareup.retrofit2:converter-scalars:2.5.0'
    implementation 'com.github.bumptech.glide:glide:3.7.0'
    def lifecycle_version = "2.0.0"
    // ViewModel and LiveData
    implementation "androidx.lifecycle:lifecycle-extensions:$lifecycle_version"
}
~~~

#### 6 LitePal

https://www.jianshu.com/p/9d0d00b69fe8

https://www.jianshu.com/p/6d3a0f87d637

**学习文档：**

https://github.com/guolindev/LitePal

#### 7 为什么需要实体类

最近因为学习三层架构中的实体类，引发不少问题，下面具体说下三层中的实体类，即数据库表的映射

**为何使用实体类？**

数据库中，DatsSet 不具备OO的优点， 实现数据检索繁琐，易出错， 使数据结构暴露在业务逻辑层和表现层

> “OO，它是英文词组Object Oriented的缩写，它的意思是面向对象

为了消除以上局限我们使用实体类:

![img](https:////upload-images.jianshu.io/upload_images/6923303-2ec385d83393a914.png?imageMogr2/auto-orient/strip|imageView2/2/w/605/format/webp)



**举例说明**

用实体类之后，代码时变得简介，面向对象**封装**思想，最重要的是，**如果将来有所改动，只需要改动实体类， 方法间调用接口，完全不需要变动，大大减少了程序修改量，迎合了面向对象中接口不变的思想。**

甚至在程序设计时，就把将来可能需要的属性预先放在实体类中，这样以后变动时，连实体类都不用变动了

实体类在三层结构中的主要作用是什么？

Using 语句的主要作用是什么？

**为什么需要实体类？**

 从OOP细想考虑

 它是完全受控制的对象

 它具有面向对象的基本特征

 可以自定义行为

消除了关系数据和对象之间的差异

**为我们在关系数据库和对象之间架起了一座桥梁**

**什么是实体类？**

 **简单的说就是描述一个业务实体的类， 例如： 管理员的信息**

![img](https:////upload-images.jianshu.io/upload_images/6923303-e26ae89a463c6480.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)



**下面几个问题是值得思考的**

**表示层如何使用实体类？**

**业务逻辑层如何使用实体类？**



![img](https:////upload-images.jianshu.io/upload_images/6923303-6a1d13147862af10.png?imageMogr2/auto-orient/strip|imageView2/2/w/667/format/webp)



**数据访问层如何使用实体类？**

他们之间的业务实体的依赖图为

![img](https:////upload-images.jianshu.io/upload_images/6923303-85645b9c7cfc862e.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)



 其中Using 语句，用于定义一个范围，在此范围末尾将释放对象



![img](https:////upload-images.jianshu.io/upload_images/6923303-a4c0b2b7ba9ef313.png?imageMogr2/auto-orient/strip|imageView2/2/w/571/format/webp)

https://blog.csdn.net/qq_41386332/article/details/99701010

#### 8 OkHttp用法

https://www.jianshu.com/p/f5320b1e0287

https://github.com/square/okhttp

原理：https://www.jianshu.com/p/7b29b89cd7b5

#### 9. throw new RuntimeException("Stub!")

https://blog.csdn.net/anhenzhufeng/article/details/75268195

这样定义的方法，表示在程序执行的时候，实际由android rom里面相同的类来执行。

**为什么会出现这样的定义？**我猜想可能是，这个类实际只在rom里面提供，而我们有时候要用到这个类的一些方法，那么就以这种方式来提供，因为在编译期间，我们的程序要使用这个类，那必然要提供这个类的定义，不然就引用不了。

就比如在看滴滴的插件化开源软件[VirtualAPK](https://github.com/didi/VirtualAPK) 的时候，在hack AMS服务的时候，需要用到ActivityManagerNative这个类，而这个类我们知道在api里面没有提供，是在framework里面提供的。那么要想引入这个类，要么就是编译一个framework.jar包，工程引用这个jar包，但是这样有个问题，我们的应用要安装在各种版本的系统里面，每个版本的framework都是有差异的，兼容性就低了。所以这里使用了另外一种方法，在我们的工程中声明一个和framework一模一样的类，在运行的时候就能自动运行rom里面的类了。

# 安卓开发之路第六天（8.22）

#### 1 编写ChooseAreaFragment类

**ChooseAreaFragment**用于展示查询界面和实现基本查询功能，继承于**Fragment**

1. 重写**onCreateView**，获取到了一些控件的实例，然后去初始化了ArrayAdapter，并将它设置为ListView的适 配器。
2. **onActivityCreated()**，接着在onActivityCreated() 方法中给**ListView和Button**设置了点击事件，到这里我 们的初始化工作就算是完成了。在onActivityCreated() 方法的最后，调用了queryProvinces() 方法，也就是从这里开 始加载省级数据的。
   * **queryProvinces() 方法**中首先会将头布局的标题设置成中国，将返回 按钮隐藏起来，因为省级列表已经不能再返回了。然后调用LitePal的查询接口来从数据库中读 取省级数据，如果读取到了就直接将数据显示到界面上，如果没有读取到就按照14.1节讲述的接 口组装出一个请求地址，然后调用queryFromServer() 方法来从服务器上查询数据。
     * **queryFromServer() 方法**中会调用HttpUtil的sendOkHttpRequest() 方法来向服务器发送 请求，响应的数据会回调到onResponse() 方法中，然后我们在这里去调用Utility的 handleProvincesResponse() 方法来解析和处理服务器返回的数据，并存储到数据库中。 接下来的一步很关键，在解析和处理完数据之后，我们再次调用了queryProvinces() 方法 来重新加载省级数据，由于queryProvinces() 方法牵扯到了UI操作，因此必须要在主线程 中调用，这里借助了runOnUiThread() 方法来实现从子线程切换到主线程。现在数据库中已 经存在了数据，因此调用queryProvinces() 就会直接将数据显示到界面上了。
3. 当你点击了某个省的时候会进入到ListView的**onItemClick()** 方法中，这个时候会根据当前的 级别来判断是去**调用queryCities()** 方法还是queryCounties() 方法，queryCities() 方法是去查询市级数据，而**queryCounties() 方法**是去查询县级数据，这两个方法内部的流 程和queryProvinces() 方法基本相同，这里就不重复讲解了。 另外还有一点需要注意，在返回按钮的点击事件里，会对当前ListView的列表级别进行判断。如 果当前是县级列表，那么就返回到市级列表，如果当前是市级列表，那么就返回到省级表列表。当返回到省级列表时，返回按钮会自动隐藏，从而也就不需要再做进一步的处理了。 

~~~java
package com.example.sunnywheather.activity;

import android.app.ProgressDialog;
import android.os.Bundle;
import android.telecom.Call;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;

import com.example.sunnywheather.R;
import com.example.sunnywheather.db.City;
import com.example.sunnywheather.db.County;
import com.example.sunnywheather.db.Province;
import com.example.sunnywheather.util.HttpUtil;
import com.example.sunnywheather.util.Utility;

import org.litepal.LitePal;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.security.auth.callback.Callback;

import okhttp3.Response;
// 新建一个ChooseAreaFragment用于展示查询界面和实现基本查询功能
public class ChooseAreaFragment extends Fragment {
    public static final int LEVEL_PROVINCE = 0;
    public static final int LEVEL_CITY = 1;
    public static final int LEVEL_COUNTY = 2;
    private ProgressDialog progressDialog;
    private TextView titleText;
    private Button backButton;
    private ListView listView;
    private ArrayAdapter<String> adapter;
    private List<String> dataList = new ArrayList<>();
    /*** 省列表 */
    private List<Province> provinceList;
    /*** 市列表 */
    private List<City> cityList;
    /*** 县列表 */
    private List<County> countyList;
    /*** 选中的省份 */
    private Province selectedProvince;
    /*** 选中的城市 */
    private City selectedCity;
    /*** 当前选中的级别*/
    private int currentLevel;

    /**
     * 在onCreateView()方法中先是获取到了一些控件的实例，
     * 然后去初始化了ArrayAdapter，并将它设置为ListView的适配器。
     * 接着在onActivityCreated() 方法中给ListView和Button设置了点击事件，
     * 到这里我们的初始化工作就算是完成了
     * @param inflater
     * @param container
     * @param savedInstanceState
     * @return
     */
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {

        View view = inflater.inflate(R.layout.choose_area, container, false);
        titleText = (TextView) view.findViewById(R.id.title_text);
        backButton = (Button) view.findViewById(R.id.back_button);
        listView = (ListView) view.findViewById(R.id.list_view);
        adapter = new ArrayAdapter<>(getContext(), android.R.layout.simple_list_item_1, dataList);
        listView.setAdapter(adapter);
        return view;
    }

    /**
     * 在onActivityCreated()方法中设置ListView和Button的点击事件，
     * 在这里完成了基本的初始化操作，调用queryProvinces()方法，加载省级数据
     * @param savedInstanceState
     */
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        //对列表设置监听事件
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                if(currentLevel == LEVEL_PROVINCE){
                    //记住选中的省份
                    selectedProvince = provinceList.get(position);
                    //显示出省份对应下city的界面
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //记住选中的City
                    selectedCity = cityList.get(position);
                    //切换到相应的county界面
                    queryCounties();
                }
            }
        });
        //为返回按钮注册监听事件
        backButton.setOnClickListener(new View.OnClickListener(){
            public void onClick(View v){
                //若在county切换到City
                if(currentLevel == LEVEL_COUNTY){
                    queryCities();
                }else if(currentLevel == LEVEL_CITY){
                    //若在City切换到province
                    queryProvinces();
                }
            }
        });
        //初始状态下显示province
        queryProvinces();
    }

    /*** 查询全国所有的省，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryProvinces() {
        //首先将头布局的标题设为中国
        titleText.setText("中国");
        //隐藏返回按键
        backButton.setVisibility(View.GONE);
        //调用LitePal接口读取省级数据
        provinceList = LitePal.findAll(Province.class);
        //如果读取到了就直接将数据显示在桌面上
        if (provinceList.size() > 0) {
            dataList.clear();
            //遍历链表
            for (Province province : provinceList) {
                dataList.add(province.getProvinceName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_PROVINCE;
        } else {
            //否则向服务器上查询
            String address = "http://guolin.tech/api/china";
            //传入一个地址和回调函数
            queryFromServer(address, "province");
        }
    }

    /*** 查询选中省内所有的市，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCities() {
        titleText.setText(selectedProvince.getProvinceName());
        backButton.setVisibility(View.VISIBLE);
        cityList = LitePal.where("provinceid = ?", String.valueOf(selectedProvince.getId())).find(City.class);
        if (cityList.size() > 0) {
            dataList.clear();
            for (City city : cityList) {
                dataList.add(city.getCityName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_CITY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            String address = "http://guolin.tech/api/china/" + provinceCode;
            queryFromServer(address, "city");
        }
    }

    /*** 查询选中市内所有的县，优先从数据库查询，如果没有查询到再去服务器上查询 */
    private void queryCounties() {
        titleText.setText(selectedCity.getCityName());
        backButton.setVisibility(View.VISIBLE);
        countyList = LitePal.where("cityid = ?", String.valueOf(selectedCity.getId())).find(County.class);
        if (countyList.size() > 0) {
            dataList.clear();
            for (County county : countyList) {
                dataList.add(county.getCountyName());
            }
            adapter.notifyDataSetChanged();
            listView.setSelection(0);
            currentLevel = LEVEL_COUNTY;
        } else {
            int provinceCode = selectedProvince.getProvinceCode();
            int cityCode = selectedCity.getCityCode();
            String address = "http://guolin.tech/api/china/" + provinceCode + "/" + cityCode;
            queryFromServer(address, "county");
        }
    }

    /*** 根据传入的地址和类型从服务器上查询省市县数据 */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    /*根据传入的地址和类型从服务器上获取数据
     * */
    private void queryFromServer(String address,final String type){
        //未查出之前显示出进度条框
        showProgressDialog();
        //Log.d(TAG,"发送之前");
        HttpUtil.sendOkHttpRequest(address, new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, IOException e) {
                //通过runOnUiThread回到主线程处理逻辑
                getActivity().runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        closeProgressDialog();
                        Toast.makeText(getContext(),"加载失败",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            @Override
            public void onResponse(okhttp3.Call call, Response response) throws IOException {
                String responseText = response.body().string();
                boolean result = false;
                if(type.equals("province")){
                    result = Utility.handleProvinceResponse(responseText);
                }else if(type.equals("city")){
                    result = Utility.handleCityResponse(responseText,selectedProvince.getId());
                }else if(type.equals("county")){
                    result = Utility.handleCountyResponse(responseText,selectedCity.getId());
                }
                if(result){
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            closeProgressDialog();
                            if(type.equals("province")){
                                queryProvinces();
                            }else if(type.equals("city")){
                                queryCities();
                            }else if(type.equals("county")){
                                queryCounties();
                            }
                        }
                    });
                }
            }
        });
    }
    /*** 显示进度对话框 */
    private void showProgressDialog() {
        if (progressDialog == null) {
            progressDialog = new ProgressDialog(getActivity());
            progressDialog.setMessage("正在加载...");
            progressDialog.setCanceledOnTouchOutside(false);
        }
        progressDialog.show();
    }

    /*** 关闭进度对话框 */
    private void closeProgressDialog() {
        if (progressDialog != null) {
            progressDialog.dismiss();
        }
    }
}
~~~

# 安卓开发之路第七天（8.23）

# 安卓开发之路第八天（8.24）

# 安卓开发之路第九天（8.25）

# 安卓开发之路第十天（8.26）

# 安卓开发之路第十一天（8.27）

# 安卓开发之路第十二天（8.28）

# 安卓开发之路第十三天（8.29）

# 安卓开发之路第十四天（8.30）

# 安卓开发之路第十五天（8.31）

# 安卓开发之路第十六天（9.1）

##### 1. 学习安卓 https://github.com/linsir6/AndroidNote

# 安卓开发之路第十七天（9.2）

#### 《14天学会安卓开发》

# 安卓开发之路第十八天（9.3）

#### 一、view的绘制流程

#### 二、自定义view