

# 面试经历

#### 2020.7.14 远景智能

**1. 面试过程**

**算法题**：

找两个数组内相同的值并相加这些值

int[] arr1={2,3,2,5};

int[] arr2={3,2,8};

**java集合：**

Map put方法链表和红黑树时间复杂度

HashMap为什么线程不安全

HashMap 如何检测是否有环，为什么可以检测

**多线程：**

HashMap如何实现线程安全

Syn底层如何实现，深入到LOCK

Syn,volite如何保证内存可见性和有序性如何保证？

为什么存在内存可见性和有序性

**JVM：**

内存划分

堆划分

每个区域是如何使用算法的

大小比例

为什么有分代算法

消息队列：

如何实现？

优点？

如何使用？

**Redis：**

Redis有哪些数据结构及其作用

Redis三种问题，如何解决

**Es:**

底层如何实现插入操作

计算机网络没问

**SQL没问**

**Linux没问**

**2. 面试总结**

**算法题：思路存在缺陷被面试官指出，而且明确思路后代码未实现。**

所以要加强一下编程，故刷leetcode top100

~~~java
package 面试;

import java.util.HashMap;
import java.util.Scanner;
//        int[] arr1={2,3,2,5};
//        int[] arr2={3,2,8};
// 找出arr1和arr2中相同的的元素求和。
public class sum {
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        HashMap <Integer,Integer> map =new HashMap<>();
        int[] arr1={2,3,2,5};
        int[] arr2={3,2,8};
        for(int i=0;i<arr1.length;i++){
            if(!map.containsKey(arr1[i])){
                map.put(arr1[i],1);
            }else{
                //这里用else
                map.put(arr1[i],map.get(arr1[i])+1);
            }
        }
        int sum=0;
        for(int j=0;j<arr2.length;j++){
            if(map.containsKey(arr2[j])){
                //计算数据下标，并不是计算值
                sum=sum+arr2[j]+map.get(arr2[j])*arr2[j];
                map.put(arr2[j],0);
            }
        }
        System.out.println(sum);
    }
}
~~~

**java集合：检测链表是否有环的理论依据没答明白**

此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。

**数学证明过程大致如下：**

pSlow = x

pFast = 2(x+1)

当pSlow到达m时pFast = 2(m+2), 这时候pSlow与pFast都在环上移动，当pSlow移动了t步后

pSlow = m + t ==> m + t %n

pFast = 2*(m + t ) ==> m + (m + 2t)%n

现在,当且仅当m +t%n = m +(m+2t)%n 时 pSlow = pFast，快慢指针相遇，解这个等式：

m +t%n = m +(m+2t)%n ==> t%n = (m+2t)%n ==> (m+t)%n = 0

m是非负整数，n是正整数，t是正整数，显然对于任意的m,n必然存在一个t使得等式成立。

**如何找到环的交点：**

用快慢指针，慢指针每次走一步，快指针每次走两步，快指针与慢指针第一次相遇的的位置慢指针走了t步，快指针走了2t步，如果不相遇则没有环。

t=x+a，  2t=x+a+kc (c为环的结点数，k=1,2,3....)

可得到  2x+2a=x+a+kc，  x=kc-a， **x=(k-1)c+ c-a**

**这里的k-1无论是多少也不影响。环上的指针可能走了很多圈，但最后一定会在节点部分可另外一个指针相遇。**

可以得到，当两个指针相遇时，把一个指针的指向链表开头，两指针都以每次一步的速度走，两指针再次相遇时就是环的入口结点。

![img](https://img-blog.csdnimg.cn/20200626220933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW1jaGltMDQ=,size_16,color_FFFFFF,t_70)

**JVM：老年代和年轻代大小比例，每答对**

老年代和年轻代比值应该为2：1,因为

1.我们创建的对象会优先在Eden分配，如果是大对象（很长的字符串数组）则可以直接进入老年代。另外，长期存活的对象将进入老年代，每一次MinorGC（年轻代GC），对象年龄就大一岁，默认15岁晋升到老年代。

2.老年代满了，会进行一个full GC,Full GC 因为需要对整个堆进行回收，而且会"**STOP THR WORLD"**所以比 Minor GC 要慢，因此应该尽可能减少 Full GC 的次数。在对 JVM 调优的过程中，很大一部分工作就是对于 Full GC 的调节。

**Redis：没有说清楚缓存击穿的解决方法**

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200721100842866.png" alt="image-20200721100842866" style="zoom:67%;" />

**Es:** 底层如何实现插入操作？

https://blog.csdn.net/u013465194/article/details/83305411

https://blog.csdn.net/cangyuemis/article/details/89362992



es 写数据过程

- 客户端选择一个 node 发送请求过去，这个 node 就是 `coordinating node`（协调节点）。
- `coordinating node` 对 document 进行路由，将请求转发给对应的 node（有 primary shard）。
- 实际的 node 上的 `primary shard` 处理请求，然后将数据同步到 `replica node`。
- `coordinating node` 如果发现 `primary node` 和所有 `replica node` 都搞定之后，就返回响应结果给客户端。

 

![img](https://pic4.zhimg.com/80/v2-4de48f728e3ed0fa74db9e2e3b0a1cdb_hd.jpg)

 

es 读数据过程

可以通过 `doc id` 来查询，会根据 `doc id` 进行 hash，判断出来当时把 `doc id` 分配到了哪个 shard 上面去，从那个 shard 去查询。

- 客户端发送请求到任意一个 node，成为 `coordinate node`。
- `coordinate node` 对 `doc id` 进行哈希路由，将请求转发到对应的 node，此时会使用 `round-robin`随机轮询算法，在 `primary shard` 以及其所有 replica 中随机选择一个，让读请求负载均衡。
- 接收请求的 node 返回 document 给 `coordinate node`。
- `coordinate node` 返回 document 给客户端。

es 搜索数据过程

es 最强大的是做全文检索，就是比如你有三条数据：

```
java真好玩儿啊



java好难学啊



j2ee特别牛
```

你根据 `java` 关键词来搜索，将包含 `java`的 `document` 给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。

- 客户端发送请求到一个 `coordinate node`。
- 协调节点将搜索请求转发到所有的 shard 对应的 `primary shard` 或 `replica shard`，都可以。
- query phase：每个 shard 将自己的搜索结果（其实就是一些 `doc id`）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。
- fetch phase：接着由协调节点根据 `doc id` 去各个节点上拉取实际的 `document` 数据，最终返回给客户端。

> 写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。

写数据底层原理

 

![img](https://pic2.zhimg.com/80/v2-fd22b4cf9003391a521da8d7c10e458d_hd.jpg)![img](https://pic2.zhimg.com/80/v2-fd22b4cf9003391a521da8d7c10e458d_hd.jpg)![img](https://img-blog.csdnimg.cn/20190417194014551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nhbmd5dWVtaXM=,size_16,color_FFFFFF,t_70)

 

先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。

如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 `refresh` 到一个新的 `segment file` 中，但是此时数据不是直接进入 `segment file` 磁盘文件，而是先进入 `os cache` 。这个过程就是 `refresh`。

每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 `segment file`，每秒钟会产生一个新的磁盘文件 `segment file`，这个 `segment file` 中就存储最近 1 秒内 buffer 中写入的数据。

但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。

操作系统里面，磁盘文件其实都有一个东西，叫做 `os cache`，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 `os cache`，先进入操作系统级别的一个内存缓存中去。只要 `buffer`中的数据被 refresh 操作刷入 `os cache`中，这个数据就可以被搜索到了。

为什么叫 es 是准实时的？ `NRT`，全称 `near real-time`。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 `restful api` 或者 `java api`，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 `os cache`中，让数据立马就可以被搜索到。只要数据被输入 `os cache` 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。

重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 `buffer` 数据写入一个又一个新的 `segment file` 中去，每次 `refresh` 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 `commit` 操作。

commit 操作发生第一步，就是将 buffer 中现有数据 `refresh` 到 `os cache` 中去，清空 buffer。然后，将一个 `commit point`写入磁盘文件，里面标识着这个 `commit point` 对应的所有 `segment file`，同时强行将 `os cache` 中目前所有的数据都 `fsync` 到磁盘文件中去。最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。

这个 commit 操作叫做 `flush`。默认 30 分钟自动执行一次 `flush`，但如果 translog 过大，也会触发 `flush`。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。

translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 `translog` 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。

translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 `fsync` 到磁盘，但是性能会差很多。

实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。

总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。

> 数据写入 segment file 之后，同时就建立好了倒排索引。

删除/更新数据底层原理

如果是删除操作，commit 的时候会生成一个 `.del` 文件，里面将某个 doc 标识为 `deleted` 状态，那么搜索的时候根据 `.del` 文件就知道这个 doc 是否被删除了。

如果是更新操作，就是将原来的 doc 标识为 `deleted` 状态，然后新写入一条数据。

buffer 每 refresh 一次，就会产生一个 `segment file`，所以默认情况下是 1 秒钟一个 `segment file`，这样下来 `segment file` 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 `segment file` 合并成一个，同时这里会将标识为 `deleted` 的 doc 给物理删除掉，然后将新的 `segment file` 写入磁盘，这里会写一个 `commit point`，标识所有新的 `segment file`，然后打开 `segment file` 供搜索使用，同时删除旧的 `segment file`。

底层 lucene

简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。

通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。

倒排索引

在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。

那么，倒排索引就是关键词到文档 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。

举个栗子。

有以下文档：

![img](https://pic4.zhimg.com/80/v2-7dd22cae5e4c21870e6663955df5da7f_hd.jpg)

对文档进行分词之后，得到以下倒排索引。

![img](https://pic2.zhimg.com/80/v2-a65de3e2c0daebef6af836bdc2210675_hd.jpg)

另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。

那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 `Facebook`，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。

要注意倒排索引的两个重要细节：

- 倒排索引中的所有词项对应一个或多个文档；
- 倒排索引中的词项根据字典顺序升序排列

上面只是一个简单的栗子，并没有严格按照字典顺序升序排列。

#### **2020.7.23 大华提前批**

**1. 面试过程**

1. 自我介绍
2. 你知道什么设计模式，使用他们有什么好处？
3. java中的锁有哪些？
4. 哪些类是线程安全的？如何实现的？
5. 有序性和可见性syn和volite如何时实现的？
6. 线程池如何创建，里面有什么参数？
7. 反射到动态代理的实现？

**2. 面试总结**

1.**1. 单例模式**：单例模式保证系统内存中该类只有一个对象。

> **优势：**可以防止频繁的创建和销毁对象造成的资源浪费，以此来提高系统性能。
>
> **实现方式：**懒汉模式创建和饿汉模式创建。
>
> **应用场景：**我们JDK中，java.lang.Runtime就是百科全书的单例模式（饿汉式）,spring里面就是用了单例模式

**2.工厂模式**：将实例化对象的代码提取出来，放到一个类里面统一管理，由子类决定是否实例化。

> **优势：**工厂方法模式具有很好的封装性。客户端不需要知道创建对象的过程，只需要知道要创建的是哪个具体的产品即可
>
> **实现方式：**简单工厂模式，工厂方法模式，抽象工厂模式。
>
> **应用场景：**在JDK中的Calendar类中，使用了简单的工厂模式。
>
> **抽象工厂模式：**
>
> 抽象工厂模式为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。
>
> **抽象工厂模式和工厂方法模式的区别：**
>
> 如果产品单一，适合使用工厂模式。但是如果有多个业务品种、业务分类时，需要使用抽象工厂模式。也就是说，工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。

**3. 代理模式**：将原类进行封装，客户端不能直接找到原类，必须通过代理角色。即代理是原类的一个替身，客户端要找原类，必须找代理才可以搞定。明星和经纪人的关系就是一种代理模式。

>**优势：**为一个对象提供一个替身,以控制对这个对象的访问.即通过代理对象访问目标对象.这样做的好处 是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.
>
>**实现方式：**静态代理和动态代理。
>
>**应用场景：**动态代理在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。相对来说，自己写代理类的方式就是静态代理。

**4. 装饰器模式**

>**优势：**动态的将新功能附加到对象上.在对象功能扩展方面,它比继承更有弹性,装饰者模式也体现了 开闭原则(ocp)
>
>**实现方式：**静态代理和动态代理。
>
>**应用场景：**String 常量池,数据库连接池

**5. 享元模式**：系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式。在享元模式这样理解,“享”就表示共享,“元”表示对象 

>**优势：**享元模式大大减少了对象的创建,降低了程序内存的占用,提高效率。
>
>**实现方式：**静态代理和动态代理。
>
>**应用场景：**String 常量池,数据库连接池

**6. 模板模式**：定义一个操作中的算法的骨架,而将一些步骤延迟到子类中,使得子类可以不改变一 个算法的结构,就可以重定义该算法的某些特定步骤。

>**优势：**实现了最大化代码复用。
>
>**实现方式：**它的子类可以按需要重写方法实现,但调用将以抽象类中定义的方式进行. 
>
>**应用场景：**当要完成在某个过程,该过程要执行一系列步骤 ,这一系列的步骤基本相同,但其 个别步骤在实现时 可能不同,通常考虑用模板方法模式来处理

**7. 策略模式**：定义算法族(策略组),分别封装起来,让他们之间可以互相替换,此模式 让算法的变化独立于使用算法的客户

>**优势：**体现了“对修改关闭,对扩展开放”原则,客户端增加行为不用修改原有代码,只要添加一种策略(或者行为) 即可,避免了使用多重转移语句
>
>**实现方式：**策略模式将算法封装在独立的 Strategy 类中使得你可以独立于其 Context 改 变它,使它易于切换,易于理解,易于扩展
>
>**应用场景：** JDK的数组的比较器就使用了策略模式

**8. 原型模式**：用原型实例指定创建对象的种类,并且通过拷贝这些原型,创建新的对象 

>**优势：**允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节
>
>**实现方式：**通过将一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它 们自己来实施创建,即 对象.clone()
>
>**应用场景：**Spring 中原型 bean 的创建,就是原型模式的应用

2.java中的锁有哪些？

#### **2020.8.15 猿辅导**        

**1. 面试准备**

```java
//import java.util.Scanner;
import java.util.*;
//联系一下链表的翻转

public class Main {
     public static class  ListNode{
        int val;
        ListNode next;
        ListNode(int x){
            this.val=x;
        }
     }
    public static void main(String[] args) {
        //Scanner in = new Scanner(System.in);
        //int a = in.nextInt();
        //System.out.println(a);
        ListNode node=new ListNode(1);   
        ListNode node1=new ListNode(2);
        ListNode node2=new ListNode(3);   
        ListNode node3=new ListNode(4);
        ListNode node4=new ListNode(5);
        node.next=node1;
        node1.next=node2;
        node2.next=node3;
        node3.next=node4;
        node4.next=null;
        ListNode next= node;
         System.out.print("正序: ");
        while(next!=null){
            System.out.print(next.val+" ");
            next=next.next; 
} //System.out.println("Hello World!");
    System.out.println();
     System.out.print("倒序: ");
  
    next= helper2(node);
   while(next!=null){
        System.out.print(next.val+" ");
        next=next.next;
    } 
}
//翻转链表
private static  ListNode helper(ListNode head){
    ListNode newNode=new ListNode(-1);
    newNode.next=null;
     ListNode nextNode=head;
    while(head!=null){
        nextNode=head.next;
        head.next=newNode.next;
        newNode.next=head;
        head=nextNode;
    }
    return newNode.next;
}
//递归翻转链表
 private static  ListNode helper2(ListNode head){
     //没有结点或者只有一个节点，返回null
     if(head==null||head.next==null) return head;
     //每次递归寻找
     ListNode newHead=helper2(head.next);
     //回溯时候主操作
     head.next.next=head;
     head.next=null;
     //返回newHead
     return newHead;
 }
//翻转链表II
 private static ListNode helper3(ListNode head,int m,int n){
     ListNode dummy=new ListNode(-1);
     dummy.next=head;
     //前驱结点
     ListNode pre=dummy;
     //找到p的前驱结点
     for(int i=1;i<m;i++) pre=pre.next;
     head=pre.next;
     for(int i=m;i<n;i++){
         ListNode nxt=head.next;
         //head插如nxt之后
         head.next=nxt.next;
         nxt.next=pre.next;
         pre.next=nxt;
     }
     return 
 }
```

**2. 面试总结**

无

#### **2020.8.23 远景智能二面**  

1. **面试准备**

1. Kafka为什么数据量多的时候会造成性能下降

2. **面试总结**

#### **2020.8.31 滴滴**  

#### **2020.9.2 58同城**

#### **2020.9.6 VIPKID**

#### **2020.9.8 小米**（实习岗）

#### **2020.9.8 美团**

#### **2020.9.8 有赞**

#### **2020.9.8 富途**

#### 2020.9.11 海康威视

#### **2020.9.12 百度（一面到三面）**

#### **2020.9.15 哔哩哔哩**

#### **2020.9.15 中科创达**

#### **2020.9.17 跟谁学**

#### **2020.9.17 青岛鼎信**

#### **2020.9.18 网易**

#### **2020.9.18 华为**

# 面试经验

#### 2020.7.21 百度面经

**1、项目相关** 

（1）SpringBoot优势



（2）SpringBoot的starter，导入pom的时候是把所有的pom引入吗

> 不是吧，需要什么引入什么

（3）项目哪里用到了redis，为什么使用redis，感觉你说的业务不是很需要redis

>点赞，用到了redis的原子增和原子减，还有秒杀系统的话是把秒杀的系统放入redis中。

（4）redis的持久化

 >RDB和AOF

2、网络连接相关 

（1）HTTP和HTTPS的区别



（2）HTTPS是怎么建立连接的（我说了网络这边不太懂，之后就不再问了）

[HTTPS 建立连接的详细过程](https://www.cnblogs.com/liyuhui-Z/p/7844880.html):

https://www.cnblogs.com/liyuhui-Z/p/7844880.html



3、Mysql 

**（1）分页查询语句？？？？？？**
https://www.jb51.net/article/109749.htm

（2）500页数据查第400页很慢，原因，解决方案

https://blog.csdn.net/happypX/article/details/94504057

因为就是越往后分页，`LIMIT语句的偏移量就会越大，速度也会明显变慢`

因为**子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。**

实际可以利用类似**策略模式**的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。

（3）Mysql的索引，写了一句查询语句，问如何建立索引，涉及很多东西，回表啊，范围查询啊啥的，（奈何我太菜了，不太了解，给了很多提示也不会）



（4）事务隔离级别，我们都用哪个级别，为什么，为什么不用serializable

4、JVM 

（1）类加载的过程

加载

验证

准备

**解析**

初始化

（2）静态变量初始化 成员变量初始化



5、多线程 

（1）volatile（可见性我说成主存通知工作内存数据变了，感觉我真是蠢。。。）

（2）synchronized底层相关（我只说上来个monitor，也不知道对不对），跟reentrantlock的区别

（3）说说你用到volatile和synchronized的一些场景（我用的demo比较少，说了个**双重检查锁**）

6、算法 

问了排序你哪个比较熟悉，我说快排，他写了几个数问我第一次快排之后是什么样的，还有算法稳定性问题

7、反问 

我有哪些需要弥补的？面试官说看面经的时候要多想一个问题，不能浮在表面上，要多记录面经，多思考，多看源码，不然水平很难上去。

 

总的来说：百度面试时间很长，整整一个小时，每个问题都不是看看面试题就能解决的，面试官人很好，会引导你思考，不过我还是太菜了，很多问题答得似是而非，快排都没有说的很对，就像面试官说的，面试大厂就要比别人多想一点，不然机会不会随便到你身上。



作者：Destiny1234
链接：https://www.nowcoder.com/discuss/457746
来源：牛客网

#### 2020.7.23 作业帮面经

1 自我介绍 

  **2 MySql的存储引擎，以及InnoDB和MyISAM的区别？** 

- ​    MyISAM不支持事务；InnoDB是事务类型的存储引擎。       
- ​    MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。       
- ​    MyISAM引擎不支持外键；InnoDB支持外键。

  **3 Mysql的索引，以及B+树与hash索引的区别，为什么不采用B树而采用B+树？** 

  **4 给出联合索引（a,b)，select *from table where a>0 and b>0，是否走索引，哪个走索引，哪个不走，以及从联合索引的底层结构去解释为什么？** 

  5 写出一个Sql语句（分组） 



  6 Mysq的事务，以及隔离级别有哪几种，说一下可重复读解决了什么问题？还有什么问题没解决？幻读如何解决的？说一下间隙锁如何实施的？ 



  幻读的具体场景？ 

  7 为什么InnoDB表必须有主键，并且推荐使用整形的自增主键？   

  8 写出一个单例模式，为什么要用voliate修饰? 出现synchronized为啥还需要voliate，以及synchronized能保证啥？ 

  9 redis的数据类型？各种数据类型的应用场景？分布式锁的实现？ 

  10 有一个100万数据，怎么快速的查找到前最大的100个数？ 

  11 算法 单链表反转    链表中两两数据反转 

  12 实习经历 如何学算法的 



  自己稍微总结了一下 

 

​    二叉树   

​    缺点： 有序的，可以退化为单链表的形式。   

   


​    平衡二叉树   

​    缺点：索引也不是只是存在内存里面存储的，还要落盘持久化，索引也存储在磁盘中，占据大小的。   

​    数层很高，多次I/O操作，消耗性能很大。因为数据量特别大。   



​    B树   

​    特点：叶子节点具有相同的深度，叶子点的指针为空。   

​    所有索引元素不重复   

​    节点中的数据索引从左向右递增排列


​    B+树   

​    特点：   

​     **非叶子节点不存储data，只存储索引，这样可以放更多的索引**   

​    **data只存在叶子节点，这样到达叶子节点的路径查询长度都一样，使用b+树索引更加稳定**   

​     **叶子节点用双向指针连接，提高区间访问的性能**。   

 1.范围区别: 

​     \1. hash索引因为底层是哈希表，数据存储在哈希表中顺序是没有关联的，所以他不适合范围查找，如果要范围查找就需要全表扫描，他只适合全值扫描；    

​     简单的来说就是hash索引适合等值查找，不适合范围查找    

​     \2. B+ tree树索引，底层是多路查询平衡树，节点是天然有序的（左节点小于服节点，右节点大于父节点），所以对于范围查找的时候不需要做全表扫描；    

​     \2. 排序  hash索引无法进行排序    

​     \3. 哈希碰撞问题 如果存在重复键值对，哈希索引效率就会很低    

  4    字段a走索引，字段b不走索引 

​    7 因为叶子节点是按顺序排列的，如果是非自增的话，就会插入的时候频繁的分裂页（效率降低）。    

​    8 vaoliate保证可见性 有序性，sunchronzied保证原子性，可见性，不能禁止指令重排   

​    10 1.根据快速排序划分的思想求解。2.（堆排序）先取出前100个数，维zhi护一个100个数的最小堆，dao遍历一遍剩余的元素，在此过程中维护堆就可以了。3.分块查找。



作者：Nioge
链接：https://www.nowcoder.com/discuss/459198
来源：牛客网



#### 2020.7.25 百度面经

1. 自我介绍

​	2. java基础

​	String，Stringbuffer，Stringbuilder区别

​	String为什么设计成final的（没答出来）

​	equals和==的区别

​	基础类型的==

​	重写equals时hashcode问题

​	jvm结构及作用

​	如何实现多线程

​	start和run方法的关系

​	线程池（问了参数，这块不是特别清楚）

​	**BIO，NIO，AIO**

​	重载和重写（开始忘记重载是什么了，面试官提醒了一下）

​	lock和synchronized的区别

​	CAS怎么回事，自旋怎么回事，ABA如何处理

​	

​	3. 计算机网络

​	http和https区别

​	https怎么加密

​	七层协议和五层协议（有两层顺序说反了，面试官敏锐的察觉到了，第二次说的时候说对了）

​	每层协议作用

​	路由器是哪一层

​	TCP和UDP

​	**沾包怎么解决**

​	三次握手，四次挥手过程，为什么要设计成这样

​	

​	4. 数据结构和算法

​	哈希表相关

​	红黑树，b树，b+树区别

​	熟悉的排序，如何实现，时间复杂度如何

​	主要讲了快排，归并排和堆排

​	

​	5. 操作系统

​	线程和进程区别，jvm里的对应

​	死锁如何产生，产生死锁如何处理

​	银行家算法

​	乐观锁和悲观锁

​	什么时候用乐观锁什么时候用悲观锁（开始答错了，后来面试官引导了一下答对）

​	

​	6. mysql （数据库没单独问，就一个问题还是在其他地方想到顺便说的，本来mysql和redis我还准备挺多的）

​	innodb和myisam在用b+树存索引的区别（这是从问数据结构b+树那里跳过来的）

​	

​	7. spring（这块比较薄弱，只是会用，还远谈不上熟悉）

​	springboot和spring区别（我简历上提到用过springboot）

​	ioc和aop

​	**aop怎么实现的**，用过什么aop

​	（面试官应该看出我这块比较薄弱了，就没继续深问了）

​	

​	8. 编程，写个快排

​	哭了，这里发挥的很差，可能是因为有人看着敲代码心里很慌，没有考虑好就写，最后写的很乱，面试官也直言这里有点失望

​	劝大伙不管多熟悉的题也全考虑好再写，写的时候平复好心态，越错越急，越急越错

​	许愿有二面，好好发挥证明一下自己的编程实力

#### 2020.7.26 用友面经



**1、描述某个场景中JVM的内存分布，以及内存的分布情况。**

​	**2、GC过程中的运行过程，理解过程？** 

​	**3、什么是jvm？** 

​	**4.jvm是如何加载class以及处理的过程** 

​	（1）加载.class文件 

​	（2）管理并分配内存 

​	（3）执行垃圾收集 

​	

​	**5、内存是什么？怎么样分配内存？** 

​	答：对象放置堆中，局部变量以及一些数组值的区域 VM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。 

​	

​	**6、GC的基本原理？什么时候需要GC？为什么需要G？** 

​	答：GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停  

​	（1）对新生代的对象的收集称为minor GC；  

​	（2）对旧生代的对象的收集称为Full GC；  

​	（3）程序中主动调用System.gc()强制执行的GC为Full GC。 

​	

​	不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：  

​	（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）  

​	（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）  

​	（3）弱引用：在GC时一定会被GC回收  

​	（4）虚引用：由于虚引用只是用来得知对象是否被GC 



作者：ITBAI
链接：https://www.nowcoder.com/discuss/454340?type=post&order=recall&pos=&page=1&channel=2001&source_id=search_post
来源：牛客网

#### 2020.7.29 字节面经

7.14一二面一起，7.17完成三面 

  一面： 

  算法题：二叉树左视图 

**java基础**

   java的三大特性，进行解释说明  

   多态的底层原理 

**java集合**

   用过的集合，线程安全的集合，ConcurrentHashMap的原理   

**JVM：**

  java内存结构 

  GC垃圾回收，垃圾回收器

  进程和线程区别 

**java并发**

   悲观锁和乐观锁以及各自应用场景，java中锁 

  **synchronized**与**lock**的区别 

**sql：**

  mysql事务隔离级别，默认的是哪一个，幻读的概念，如何解决幻读 

  mysql行锁和表锁，主从复制原理 

  mysql日志中redo和undo日志概念以及应用 

  sql索引，写了三个sql，**判断用到那几个索引** 

**redis:**

  缓存雪崩，缓存击穿，缓存穿透，解释概念以及解决方案 

  **redis分布式锁，保证原子性，删了别的服务锁如何解决，token存放的位置** 

  **zookeeper锁的原理** 

  布隆过滤器的原理 

**mq:**

  **mq如何保证消息的有序性** 

- **Kafka**：拆分多个 Queue，每个 Queue一个 Consumer（消费者），**就是多一些 Queue 而已**，确实是麻烦点；或者就一个 Queue 但是对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 Worker 来处理.
- **RabbitMQ**：一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，**单线程吞吐量太低，一般不会用这个**；写 N 个内存 Queue，具有相同 key 的数据都到同一个内存 Queue；然后对于 N 个线程，每个线程分别消费一个内存 Queue 即可，这样就能保证顺序性.

  消息不丢失如何解决 

![image-20200731162630350](X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200731162630350.png)

**es:**

  es中的数据类型，倒排索引，插入数据和读数据过程

 

  es中refresh过程 

 


  二面： 

  算法题：1.正整数n， 123， 1*1+2*2+3*3=14 => .... 1判断结果是否为1 

  2.整数数组，8， -12， 7， 6， -15， 12求连续相加和最大的子串 

  sql题：  

   classId studentId courseId score  

   \1. **求1班总分最高的前三名**  

~~~mysql
select studentId from 表名 where studentId like "1" group by studentId having sum(score) as sum_score order by sum_score limit 0, 3;
~~~

   \2. **求每个班总分最高的前三名**  



   分布式微服务和单体应用的区别，什么时候考虑用单体应用  

   场景设计题：海量商品中，如何可以搜索出排行前100的商品，es中如何进行存储，怎样设计  

   不同服务调用接口，如果发生网络抖动原因，如何保证服务之间不会在数据库中产生脏数据  

   接口幂等保证  

   消息队列如何保证消息不丢失  



   SSO单点登录过程介绍  

   用户登录信息如何保存（jwt）  



   三面： 

  两道代码题： 

  1.设计延迟队列数据结构 

  说明自己设计的数据结构会出现什么问题 

  2.二叉树的中序后继节点



作者：godyunfly
链接：https://www.nowcoder.com/discuss/469950
来源：牛客网

#### 2020.8.7 猿辅导面经

0、自我介绍 

  1、讲一讲你的项目中的亮点 

  **2、分布式事务如何实现的？（讲一讲底层原理）** 

https://blog.csdn.net/oldshaui/article/details/88743085

  3、讲一下**MySQL事务**的实现原理和**ACID特性** 

**四种事务隔离级别：读未提交，读已提交，可重复读，串行化**

**实现原理：**

1. 首先innodb默认的锁是行级锁，行级锁分为互斥锁和共享锁，也可以称为写锁和读锁。加了互斥锁之后就不能加其他任何锁，而加了共享锁的行只能加共享锁。是否加锁的规则是这样的，当对行进行修改（包括更新，插入）时，会对其加互斥锁，但是对不加锁的读(select)就不起作用了。

2. **读未提交**： 对于修改的项加排它锁，直到事务结束释放

​       **读已提交**：默认加行级锁，使用MVCC版本控制机制对每一个操作进行加锁。

​       **可重复读**：默认加行级锁，使用MVCC版本控制机制对每一个事务进行加锁。

​       **串行化**： 默认加行级锁，使用**间隙锁**加在操作的行上防止幻读。

**ACID特性** ：

​    **原子性**

​    **一致性**

​    **隔离性**

​    **持久性**

  4、介绍一下undo log和redo log 

**undo日志到底做了什么? undo日志会记录事务执行过程中，每次修改的数据的原始值**。

```mysql
x =5,y  = 8
t1 begin:
	//undo日志记录x=5
	x = x- 1;
	//undo日志记录y=8
	y = y-2;
	//事务执行临近结束，将undo日志写入到磁盘
	//将数据写入到磁盘
commit
```

我们都知道，事务是具有**原子性**的要不全做，要不全部做。可到底是什么机制协助了数据库，**undo（没做）**日志就可以保证数据库事务操作的原子性，从上面的流程我们可以得知每次进行事务修改之前，都会吧**未修改之前的值**存储到undo日志中，当然再**提交的时候也是先将undo写到磁盘，再把修改后的数据写到磁盘。倘若再undo写入磁盘之前发生了异常，根本就不需要做任何操作，这时候事务是被认为执行失败的，也不需要回滚，因为undo日志没有写入磁盘，数据库被认为处于没有执行事务的状态**。若再数据写入磁盘的时候发生故障，则可以根据undo日志进行回滚，整个过程下来起码实现了**原子性以及持久性**。

**undo操作的特点总结如下**：

1. **在更新数据前把数据记录到undo操作**
2. **持久性，只要数据提交则必定保存到了数据库**
3. **undo log必须先于数据持久化到磁盘，这样的话若数据写入磁盘或者进行commit是出错，可以根据undo日志进行回滚**
4. **若事务再undo持久化之前出错，则数据库中的数据还保持在事务之前的状态。undo日志中也没有相应的记录，不需要回滚**

当然undo的缺陷也很明显，他需要提交一次undo日志到磁盘，和一次数据到磁盘。io次数过多，性能太低。

**redo的出现**：**为了解决undo性能过低的问题，就引入了redo**，redo与undo正相反，他记录的是**新数据的备份**。并且事务在提交的时候只需将redo日志持久化到磁盘即可，数据可以根据redo日志**异步的**持久到磁盘。当发生异常的时候，只要redo日志写入到磁盘我们就可以根据redo日志来进行回滚。倘若redo日志再持久化到磁盘的时候出错，数据库就相当于没有执行过当前事务。

**数据库恢复策略**

1.只按照**redo日志**进行回复，所有事务（包括未提交的事务）都按照redo日志，也就是视图提交后的结果进行恢复

2.第二种分两步走，第一部和第一种一样，先根据**redo日志对所有事务进行恢复操作**。再**根据undo日志对未提交的日志进行回复操作**。

Mysql采用的是第二种恢复策略。显然第一种策略也能进行事无恢复，但是为什么Mysql会采用第二种呢。我个人理解是这样的，虽然只按照redo日志进行回复也能回复数据。但是redo日志记录的是事务修改后的数据，这对于已经提交的事务是没有问题的。但是对于未提交的事务，当灾难发生时，事务并没有被提交，逻辑上应该认为这个事务是操作失败的，也就是类似于在做普通的sql的时候出现了异常，此时我们需要做回滚操作。只按照redo日志进行恢复，那么那些未提交的事务会直接恢复到事务提交后的结果。

不妨设想一个场景，a向b转100块钱，这个事务执行的顺序也就是，将 a-100和b+100的结果写入到redo日志，redo日志进行持久化操作，最后一步就是事务提交。但是再事务提交的节骨眼儿上服务器宕了，这时候由于用户a长时间得不到服务器响应，客户端也应该向用户显示操作失败吧（假设需要同步的显示操作结果），但是根据redo日志进行回复后，a-100 以及 b+100的操作被数据库恢复了，但是用户那边的情况却恰恰相反。这样对于一个可靠性要求比较高的系统来说本就是灾难。

  5、介绍一下**ThreadLoacl**的实现原理 

  6、如果ThreadLoaclMap的Key有null的情况呢？  

  7、介绍一下Java的强引用和弱引用  

  8、编程题：判断给定的一颗二叉树是否是二叉搜索树

#### 2020.8.14 猿辅导面经

计算机网络（全部），

1. **IOS七层网络模型：**应用层（HTTP和HTTPS）->表示层->会话层->传输层（TCP和UDP协议）->网络层（IP）->数据链路层->物理层。

2. **输入URL到显示网页的过程 **主机向本地域名服务器的查询一般都是采用**递归查询**，本地域名服务器向根域名服务器的查询的**迭代查询**

3. **TCP三次握手四次挥手**

4. **TCP和UDP区别**，TCP链接可靠性的原因。

5. **HTTP和HTTPS区别**

6. **HTTPs握手过程**

7. **GET和POST区别**

# 编程刷题

## 2020.8.8 刷题

##### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

* 基于手算的思想

~~~java
 import java.util.ArrayList;
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
     List<Integer> list = new ArrayList<Integer>();
       if(root==null) return list;
       Stack<TreeNode> stack=new Stack<>();
       //stack.push(root);
       while(!stack.isEmpty()||root!=null){
           while(root!=null){
               list.add(root.val);
               stack.push(root);
               root=root.left;   
           }
           root=stack.pop();
           root=root.right;
       }
       return list;
    }
}
~~~

##### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

* 基于手算的思想

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
     //List<Integer> List=new ArraryList<Integer>();
     List<Integer> list = new ArrayList<Integer>();
     if(root==null) return list;
     Stack<TreeNode> stack =new Stack<TreeNode>();
     while(!stack.isEmpty()||root!=null){
         while(root!=null){
             stack.push(root);
             root=root.left;
         }
         root=stack.pop();
         list.add(root.val);
         root=root.right;
     }
     return list;
    }
}
~~~

##### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

* 基于手算的思想

~~~java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        //List<Integer> list=new ArraryList<Integer>();
        List<Integer> list = new ArrayList<Integer>();
        if(root==null) return list;
        //标记指针
        TreeNode pre=root;
        Stack <TreeNode> stack=new Stack<TreeNode>();
        while(!stack.isEmpty()||root!=null){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            //找出栈顶的节点的右节点
            root=stack.peek().right;
            //如果没有右节点，或者右节点被遍历过，它就是下一个要遍历的节点
            if(root==null||root==pre){
             root=stack.pop();
             list.add(root.val);
             //标记其已经被遍历过
             pre=root;
             //防止循环遍历，查看右节点
             root=null;
            }           
        }
        return list;
    }
}
~~~

##### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
     List<List<Integer>> lists =new ArrayList<>();
     if(root==null) return lists;
     //List<Integer> list=new ArraryList<>();
     List<Integer> list = new ArrayList<Integer>();
     //使用一个队列
      //Queue<TreeNode> q=new Linkedlist<TreeNode>(); 
      Queue<TreeNode> q=new LinkedList<>();
      q.add(root);
      int size=1;
      while(q.size()!=0){
        //队列的基本操作
        root=q.remove();
        list.add(root.val);
        if(root.left!=null) q.add(root.left);
        if(root.right!=null) q.add(root.right);
        size--;
        if(size==0){
          lists.add(list);
          list= new ArrayList<Integer>();
          size=q.size();
        }
      }
      return lists;
    }
}
~~~

##### [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

* res.add(0,list);//前插

##### [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
      List<List<Integer>> lists=new ArrayList<>();
      if(root==null) return lists;
      List<Integer> List=new ArrayList<>();
      Queue<TreeNode> q=new LinkedList<>();
      q.add(root);
      //记录层数和深度
      int size=1;
      int deep=1;
      while(q.size()!=0){
          root=q.poll();
          //奇数层正插
          if(deep%2==1){
          List.add(root.val);
          //偶数层正插
          }else{
           List.add(0,root.val);
          }
          size--;
          if(root.left!=null)  q.add(root.left);
          if(root.right!=null)  q.add(root.right);
          //当本层已经插入完毕，则更新层中节点数量和深度
          if(size==0){
            lists.add(List);
            List=new ArrayList<>();
            size=q.size();
            deep++; 
          }    
      }
      return lists;
    }
}
~~~

##### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
         //想象一下
         //1.只有t1有一个节点
         //2.只有t2有一个节点
         //3.t1和t2都没有节点
         //4.t1和t2都有节点
         if(t1==null){
             return t2; 
         }
         if(t2==null){
             return t1;
         }
         //实现函数功能
       t1.val=t1.val+t2.val;
       t1.left=mergeTrees(t1.left,t2.left);
       t1.right=mergeTrees(t1.right,t2.right);
       // t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    }
}
~~~

##### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public  TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
~~~

##### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
 public boolean isSymmetric(TreeNode root) {
    if(root==null) return true;
    //其左子树的右节点，等于右子树的左节点
    return helper(root.left,root.right);
  }
  private boolean helper(TreeNode left,TreeNode right){
      //如果都为空，当然为true
      if(left==null&&right==null) return true;
      //在都不为空的前提下，如果其中有一个为空，则为false;
      if(left==null||right==null) return false;
       //否则判断值&&左结点的左结点值和右结点的右结点值&&左结点的右结点值和右结点的左结点值
return left.val==right.val&&helper(left.right,right.left)&&helper(left.left,right.right);
  }
}
~~~

##### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
     if(root==null) return 0;
     int left=maxDepth(root.left);
     int right=maxDepth(root.right);
     return Math.max(left,right)+1;
    }
}
~~~

##### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //最大直径可能不穿过根节点,但一定有一个公共节点
    int max=0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null) return 0;
        helper(root);
        return max; 
    }
    public int helper(TreeNode root) {
        if(root==null) return 0;
        int left=helper(root.left);
        int right=helper(root.right);
        //这里加入一个判断
        max=Math.max(max,left+right);
        return Math.max(left,right)+1;
    }
}
~~~

##### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public static  void flatten(TreeNode root) {
         if(root==null){
             return;
         }
         //将根节点的左子树变成链表
         flatten(root.left);
        //将根节点的右子树变成链表
         flatten(root.right);
        //暂时存储右子树
        TreeNode temp=root.right;
        //左子树转化为右子树
         root.right=root.left;
         root.left=null;
        //连接右子树的最后与temp
         while(root.right!=null) root=root.right;
         root.right=temp;
    }
}
~~~

##### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

1. 第一遍，看题目，想解法，如果十几分分想不出来直接看题解，看看别人的解法，最好能够默写出来
2. 第二遍，自己尝试写出
3. 第三遍，隔几天后再次写一下，体会+上自己的优化
4. 第四遍，一周过去后，再来一一遍
5. 第五遍，复习，例如面试前。 (不一定是五遍，而是要做出来自己的体会和思考才是最重要的。) 如果有小手指，帮忙点点。上面的方法是收到，覃超老师的指导的方法。

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808140310557.png" alt="image-20200808140310557" style="zoom:67%;" />

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808140834123.png" alt="image-20200808140834123" style="zoom: 67%;" />

![image-20200808140935352](X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808140935352.png)

~~~java
/*------------深度遍历每个结点，根据要求判断是否为最近公共子节点-----------------------*/
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //这三种情况返回root即可
        if(root == null || root == p || root == q) return root;
        //如果这个结点左子树p，则返回p,否则返回null;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //这种情况说明root是公共结点，返回root
        if(left != null &&right != null) return root;
        //当left不为null，返回left。否则返回right
        //这也包含了left和right同时为null的情况，返回null
        return  left!=null?left:right;      
    }
}
~~~

##### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> list =new ArrayList<Integer>();
    public List<Integer> rightSideView(TreeNode root) {
            if(root==null) return list;
            helper(root,0);
            return list;
    }
    //设置一个deep标记当前层数
    private void helper(TreeNode root,int deep){
        if(root==null) return ;
        //当第一次访问该层时，才加入值
        if(list.size()==deep){
            list.add(root.val); 
        }
         deep++;
         helper(root.right,deep);
         helper(root.left,deep);
    }
}
~~~

##### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808185709296.png" alt="image-20200808185709296" style="zoom:67%;" />

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808185725233.png" alt="image-20200808185725233" style="zoom:67%;" />

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}
~~~

##### 剑指：[树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

**思路**：参考剑指offer**(双重DFS)**
1、首先设置标志位result = false，因为一旦匹配成功result就设为true，剩下的代码不会执行，如果匹配不成功，默认返回false
2、递归思想，**如果根节点相同**则递归调用DoesTree1HaveTree2（），如果根节点不相同，则判断tree1的左子树和tree2是否相同，再判断右子树和tree2是否相同。
3、注意null的条件，HasSubTree中，如果两棵树都不为空才进行判断，DoesTree1HasTree2中，如果Tree2为空，则说明第二棵树遍历完了，即匹配成功，tree1为空有两种情况:

（1）如果tree1为空&&tree2不为空说明不匹配，
（2）如果tree1为空，tree2为空，说明匹配。



~~~java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/ 
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution{
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        boolean flag = false;
        //必须满足这才判断
        if(root1!=null&&root2!=null){
        if(root1.val==root2.val){
            flag = isSubTree(root1,root2);
        }
        //if(!flag)只要存在没必要再次判断了
        if(!flag)flag = HasSubtree(root1.left, root2);
        if(!flag)flag = HasSubtree(root1.right, root2);
    }
        return flag;
    }
       
    private boolean isSubTree(TreeNode root1, TreeNode root2) {
        //root2==null 说明判断完了
        if(root2==null) return true;
        //到这步root2！=null，那么root1必须!=null
        if(root1==null) return false;      
        return root1.val==root2.val&&isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);

    }
}
~~~

~~~java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution{
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null) return false;
        if(root1==null) return false;  
        //这样每个结点都不
        if(root1.val==root2.val) 
        return isSubTree(root1,root2)
               ||HasSubtree(root1.left,root2)                                                            ||HasSubtree(root1.right, root2);
        return false;
    }
    private boolean isSubTree(TreeNode root1, TreeNode root2) {
        if(root2==null) return true;
        if(root1==null) return false;      
        return root1.val==root2.val&&isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);

    }
}
~~~

~~~java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution{
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null) return false;
        if(root1==null) return false; 
        //为什么不对？
        if(root1.val==root2.val) return isSubTree(root1,root2);
        return HasSubtree(root1.left, root2)||HasSubtree(root1.right, root2);   
    }
        
    private boolean isSubTree(TreeNode root1, TreeNode root2) {
        if(root2==null) return true;
        if(root1==null) return false;      
        return root1.val==root2.val&&isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);

    }
}
~~~

##### 剑指：[二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

~~~java
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
     //如果一个结点有右子树，那么中序遍历的下一个结点是右子树的最左结点
      //如果一个结点没有右子树，那么就是它父节点路径上的右父节点
      //TreeLinkNode temp=null;
      if(pNode.right!=null){
        pNode=pNode.right;
        while(pNode.left!=null){
          pNode=pNode.left;
        }
        return pNode;
      }
      //第二种情况
      while(pNode.next!=null&&pNode!=pNode.next.left){
        pNode=pNode.next;
      }
      return pNode.next;
       
    }
}
~~~

##### 剑指：[平衡二叉树](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

* 平衡二叉树的左右子树也是平衡二叉树，那么所谓**平衡就是左右子树的高度差不超过1**.

~~~java
public class Solution {
    boolean isBalanced=true;
    public boolean IsBalanced_Solution(TreeNode root) {
      getDepth(root);
      return  isBalanced;
    }
     
    private int getDepth(TreeNode root) {
        if(root==null) return 0;
        int left=getDepth(root.left);
        int right=getDepth(root.right);
        //和二叉树的深度只多了这一步
        if(Math.abs(left-right)>1) isBalanced=false;
        return Math.max(left,right)+1;
    }
}
~~~

#### 【路径问题】

##### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int max=Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if(root==null) return 0;
        helper(root);
        return max;
    }
    private int helper(TreeNode root){
       if(root==null) return 0;
       int left =Math.max(0,helper(root.left));
       int right=Math.max(0,helper(root.right));
       max=Math.max(max,left+right+root.val);
       return Math.max(left,right)+root.val;
    }
}
~~~

##### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        //当root==null返回fasle;
        if (root == null) {
            return false;
        }
        //当到达根节点时进行判断
        if (root.left == null && root.right == null) {
            return sum == root.val;
        }
        sum=sum-root.val;
        boolean left=hasPathSum(root.left, sum);
        boolean right=hasPathSum(root.right, sum);
        if(left||right) return true;
        return false;
    }
}
~~~

##### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> ans = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        pathSum(ans, path, root, 0, sum);
        return ans;
    }
    public void pathSum(List<List<Integer>> ans, List<Integer> path, TreeNode root, int temp, int sum){
        if(root == null){
            return ;
        }
        //到达叶子节点时，并且条件成立
        if(root.left == null && root.right == null && temp+root.val == sum){
            //加入根节点
            path.add(root.val);
            //加入总队列
            ans.add(new ArrayList<>(path));
            path.remove(path.size() - 1);
            return ;
        }
        //每次加入一个节点
        path.add(root.val);
        pathSum(ans, path, root.left, temp+root.val, sum);
        pathSum(ans, path, root.right, temp+root.val, sum);
        //回溯
        path.remove(path.size() - 1);
    }
}
~~~

**自己练习：**

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //List<List<Integer>> lists= new ArraryList<>();
    List<List<Integer>> lists = new ArrayList<>();
    List<Integer> list=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root==null) return lists;
        helper(root,sum);
        return lists;
    }
    private void helper(TreeNode root,int sum){
        if(root==null) return;
        //主要操作
        sum=sum-root.val;
        list.add(root.val);
        //满足条件
        if(root.left==null&&root.right==null&&sum==0){
              lists.add(new ArrayList<>(list));
              //回溯
              list.remove(list.size()-1);
              return;
        }
        helper(root.left,sum);
        helper(root.right,sum);
        //回溯
        list.remove(list.size()-1);
    }
}
~~~

##### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

* **双重递归**

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans=0;
    //前序遍历每个结点
    public int pathSum(TreeNode root, int sum) {
        if(root==null) return ans;
        //双重递归:以此节点为树的根节点，进行查找
        dfs(root,sum);
        pathSum(root.left,sum);
        pathSum(root.right,sum);
        return ans;
    }
    //以此节点为起点，查找符合条件的路径
    private void dfs(TreeNode root,int sum){
        if(root==null) return;
        sum=sum-root.val;
        if(sum==0) ans++;
        dfs(root.left,sum);
        dfs(root.right,sum);
    }
}
~~~

#### 【二叉搜索树问题】

##### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

* 中序遍历为升序
* 节点的左子树只包含**小于**当前节点的数。
* 节点的右子树只包含**大于**当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200808204458593.png" alt="image-20200808204458593" style="zoom:50%;" />

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/*-------------------------------正确-------------------------------*/
class Solution {
    public boolean isValidBST(TreeNode root) {
        return Helper(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
    public boolean Helper(TreeNode root,long min,long max){
        if(root==null)return true;
        if(root.val>=max||root.val<=min)return false;
        return Helper(root.left,min,root.val)&&Helper(root.right,root.val,max);
    }
}
/*-------------------------------错误-------------------------------*/
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        if(root.right!=null&&root.val>=root.right.val) return false; 
        if(root.left!=null&&root.left.val>=root.val) return false;
        return isValidBST(root.left)&&isValidBST(root.right);
    }
}
~~~

##### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

~~~java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
//递归
class Solution {
    private int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}
//迭代
class Solution {
    public TreeNode convertBST(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        int num1=0;
        TreeNode temp=root;
        while(!stack.isEmpty()||root!=null){
            //关键点，此处要为pre
            while(root!=null){
                stack.push(root);
                root=root.right;
            }
            root=stack.pop();
            root.val=root.val+num1;
            num1=root.val;
            root=root.left;
        }
        return temp;
    }
}
~~~

##### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**方法**：动态规划

~~~java
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}

~~~

##### 剑指：[二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

* 二叉搜索树的第k小的节点，就是中序遍历第k个节点

~~~java
import java.util.ArrayList;
// {8,6,10,5,7,9,11},8
// null,5
public class Solution {
    ArrayList<TreeNode> list = new ArrayList<>(); // (1)
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        addNode(pRoot);
        //中序遍历第k个节点
        if(k>=1 && list.size()>=k) {
            return list.get(k-1);
        }
        return null;
    }
    // 中序遍历
    void addNode(TreeNode cur) {   // (2)
        if(cur != null) {
            addNode(cur.left);
            list.add(cur);
            addNode(cur.right);
        }
    }
}
//迭代
import java.util.Stack;
public class Solution {
    //中序递归
    int count = 0;
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(count > k || pRoot == null)
            return null;
        TreeNode p = pRoot;
        Stack<TreeNode> myStack = new Stack<TreeNode>();
        TreeNode myNode = null;
        while(p != null || !myStack.isEmpty()){
            while(p != null){
                myStack.push(p);
                p = p.left;
            }
            TreeNode node = myStack.pop();
            count++;
            if(count == k){
                myNode = node;
            }
            p = node.right;
        }
        return myNode;
    }
}
~~~

##### 剑指：二叉搜索树与双向链表

**题目：**输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

* **用一个全局变量pre去保存前一个节点，然后再去创建节点之间的关系**：[link](https://blog.nowcoder.net/n/17c95de2427e49abb207a6a9d37c602d?f=comment)
* 我们受到**惯性思维的约束**，每次都是想着中序遍历先遍历左子树，再遍历根节点，再遍历右子树。那既然中序遍历方法得到的二叉树是降序的，那我先遍历右子树，再遍历根节点，再遍历左子树不就可以了

~~~java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    TreeNode pre=null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if (pRootOfTree==null)
            return null;
        Convert(pRootOfTree.right);
        if (pre!= null){
            pRootOfTree.right=pre;
            pre.left=pRootOfTree;
        }
        pre=pRootOfTree;
        Convert(pRootOfTree.left);
        return pre;
    }
}
~~~

## 2020.8.9 刷题

**String的用法：**
//java中String是只读的，没有办法进行变换，因此需要使用StringBuilder。
**String.length()** //获取字符串的长度
**String.charAt(i)** //获取第i个字符的内容
String.subString(start)   //获取[start,）的字符串
**String.subString(start,end) //获取[start,end）中的字符串**
char[] c = iniString.toCharArray() //将字符串转为char数组来进行改变字符内容
String.equal() //判断两个字符串是否相等

**StringBuilder的用法：**
除了String中支持的方法外，StringBuilder支持字符的增、删、改。
**stringBuilder.append("we");**  //添加we在词尾
**stringBuilder.insert(0,"we")**;//在0的位置加入后面的内容
stringBuilder.delete(0,1);  //删除[0,1)的数据
stringBuilder.deleteCharAt(0);
stringBuilder.setCharAt(0,'p'); //在某一个独特位置设置字符
char c = stringBuilder.charAt(i);//查询某个位置上的字符
System.out.println(stringBuilder);
new String(stringBuilder);//用stringBuilder来初始化String

* 考察String基本操作方法
  1、 获取字符串长度方法length()
  **int length = str.length();**
  2、获取字符串中的第i个字符方法charAt(i)
  **char ch = str.charAt(i);**  

  3、向字符串中添加字符
  **newStr.append(0);**

  4、获取指定位置的字符方法

  **getChars(indexBegin,indexEnd,array,arrayBegin)**

   1) indexBegin：需要复制的字符串的开始索引　

  2) indexEnd:    需要复制的字符串的结束索引，indexEnd-1

  3) array:  前面定义的char型数组的数组名　

  4) arrayBegin:数组array开始存储的位置索引号

* String，StringBuffer，StringBuilder区别：
  1、String类是**不可变类**，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。
  2、StringBuffer对象则代表一个**字符序列可变的字符串**，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。
  3、StringBuilder类也代表**可变字符串对象**。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。
  注：StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：**StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，

##### 剑指：字符串

**题目：**将一个**字符串**中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

~~~java
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	StringBuffer str1=new StringBuffer(0);
        for(int i=0;i<str.length();i++){
          if(str.charAt(i)==' '){
            str1.append('%');
            str1.append(2);
            str1.append(0);
          }else{
            str1.append(str.charAt(i));
          }
        }
        return str1.toString();
    }
}
~~~

##### 剑指：字符串的排列 

> 可以导入一切util下的包，import java.util.*;

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

* [DFS+剪枝](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/)

~~~java
class Solution {
    List<String> res = new LinkedList<>();
    char[] c;
    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }
    void dfs(int x) {
        if(x == c.length - 1) {
            //将数组转化为字符串
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        }
        HashSet<Character> set = new HashSet<>();
        for(int i = x; i < c.length; i++) {
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位 
            //固定字符
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        }
    }
    void swap(int a, int b) {
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
}
~~~

~~~java
import java.util.*;
public class Solution {
    ArrayList<String> list =new ArrayList<>();
    char[] c;
    public ArrayList<String> Permutation(String str) {
      // 记住此方法str.toCharArray()
       c = str.toCharArray();
       dfs(0);
       return list;
    }
    private void dfs(int x){
      if(x==c.length-1){
          //记住此方法String.valueOf(c)，将数组转换为为字符串
        list.add(String.valueOf(c));
        return;
      }
      for(int i=x;i<c.length;i++){
        swap(i,x);
        dfs(x+1);
        swap(i,x);
        
      }
      
    }
    private void swap(int a,int b){
      char temp=c[a];
      c[a]=c[b];
      c[b]=temp;
    }
  
}
~~~



**[String.valueOf()方法的使用](https://www.cnblogs.com/yupf/p/5859374.html)**

**1. 由 基本数据型态转换成 String **String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 
也就是 String.valueOf() 这个参数多载的方法 
有下列几种 
String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 
String.valueOf(char c) : 将 char 变量 c 转换成字符串 
String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 
String.valueOf(char[] data, int offset, int count) : 
将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 
String.valueOf(double d) : 将 double 变量 d 转换成字符串 
String.valueOf(float f) : 将 float 变量 f 转换成字符串 
String.valueOf(int i) : 将 int 变量 i 转换成字符串 
String.valueOf(long l) : 将 long 变量 l 转换成字符串 
String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() 
用法如: 
int i = 10; 
String str = String.valueOf(i); 
这时候 str 就会是 "10" 
**2. 由 String 转换成 数字的基本数据型态 **要将 String 转换成基本数据型态转 
大多需要使用基本数据型态的包装类别 
比如说 String 转换成 byte 
可以使用 Byte.parseByte(String s) 
这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException 
byte : 
Byte.parseByte(String s) : 将 s 转换成 byte 
Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte 
比如说 Byte.parseByte("11", 16) 会得到 17 
double : 
Double.parseDouble(String s) : 将 s 转换成 double 
float : 
Double.parseFloat(String s) : 将 s 转换成 float 
int : 
Integer.parseInt(String s) : 将 s 转换成 int 
long : 
Long.parseLong(String

##### 剑指：左旋转字符串

* **String.subString(start,end) //获取[start,end）中的字符串**

~~~java
public class Solution {
    public String LeftRotateString(String str, int n) {
        if (str == null || n > str.length()) {
            return str;
        }
        return str.substring(n) + str.substring(0, n);
    }
}
~~~

~~~java
public class Solution
{
    public String LeftRotateString(String str,int n)
    {
        char []c=str.toCharArray();
        if(c.length<n)return "";
        //翻转三次
        reverse(c,0,n-1);
        reverse(c,n,c.length-1);
        reverse(c,0,c.length-1);
        StringBuilder sb=new StringBuilder();
        for(char t:c)sb.append(t);
        return sb.toString();
         
    }
    public void reverse(char []c,int low,int high)
    {
        while(low<high)
        {
            char temp=c[low];
            c[low]=c[high];
            c[high]=temp;
            low++;
            high--;
        }
    }
}
~~~

~~~java
public class Solution {
    public String LeftRotateString(String str, int n) {
        if (str == null || n > str.length()) {
            return str;
        }
        StringBuffer newstr =new StringBuffer(0);
        for(int i=n;i<str.length();i++){
          newstr.append(str.charAt(i));
        }
        for(int j=0;j<n;j++){
          newstr.append(str.charAt(j));
        }
       return newstr.toString();
        
    }
}
~~~

##### 剑指：把字符串转换成整数

> throw` `new` `RuntimeException(``"下溢出"``);

~~~java
public class Solution
{
    public int StrToInt(String str)
    {
        if (str.equals("") || str.length() == 0)
            return 0;
        char[] a = str.toCharArray();
        int fuhao = 0;
        if (a[0] == '-')
            fuhao = 1;
        int sum = 0;
        for (int i = fuhao; i < a.length; i++)
        {
            if (a[i] == '+')
                continue;
            if (a[i] < 48 || a[i] > 57)
                return 0;
            sum = sum * 10 + a[i] - 48;
        }
        return fuhao == 0 ? sum : sum * -1;
    }
     
}
~~~

##### 剑指： 翻转单词顺序列

“student. a am I”->I am a student.

* 先翻转整个句子，然后，依次翻转每个单词。
 * 依据空格来确定单词的起始和终止位置

~~~java
public class Solution {
    public String ReverseSentence(String str) {
        //将字符串转化为字符串数组
        char[] s=str.toCharArray();
        //翻转整个字符串，需要自己写
        helper(s,0,s.length-1);
        int blank=0;
        for(int i=0;i<s.length;i++){
          if(s[i]==' '){
            helper(s,blank,i-1);
            blank = i+1;
          }
        }
         //最后一个单词单独进行反转
        helper(s,blank,s.length-1);
        return new String(s);
    }
//翻转字符串算法：使用两个指针指向表头和表尾，交换到指针相交时结束。
   private void helper(char[] s,int i,int j){
     while(i<j){
       char temp=s[i];
       s[i]=s[j];
       s[j]=temp;
       i++;
       j--;
     }
   }   
}
~~~

##### 剑指：第一个只出现一次的字符

> length()是方法，str.length是求数组的长度，length相当于数组的属性

* 建立一个key为字符，val为次数（整数类型）的哈希map；
* 遍历字符串，将字符和次数插入到哈希map中；
* 规则为：定义time就是字符出现的次数，每出现一次加1；
* 再次从头到尾遍历字符串，配合hash表找出符合条件的字符。

~~~java
import java.util.*;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        HashMap<Character,Integer> map= new HashMap<>();
       for(int i=0;i<str.length();i++){
         if(map.containsKey(str.charAt(i))){
           map.put(str.charAt(i),map.get(str.charAt(i))+1);
         }else{
           map.put(str.charAt(i),1);
         }
        }
        for(int j=0;j<str.length();j++){
          if(map.get(str.charAt(j))==1){
            return j;
          }
        }
        return -1;
    }
}
~~~

##### 剑指：第一个不重复的字符（同上）

##### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

~~~java
class Solution {
    public int lengthOfLongestSubstring(String s) {
    if(s==null) return 0;
     HashMap<Character,Integer> map= new HashMap<>();
     //map存储字母和下标
     int max=0;
     for(int i=0,j=0;j<s.length();j++){
         if(map.containsKey(s.charAt(j))){
            //这里要取i之后的值，使用max确定，否则像"abba"则不对。
            i=Math.max(map.get(s.charAt(j))+1,i);
         }
         map.put(s.charAt(j),j);
         max=Math.max(max,j-i+1);
     }
     return max;
    }
}
~~~

##### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

![image-20200810120638975](X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200810120638975.png)

~~~java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
         if(s1.length()>s2.length()) return false;
         //这里为int数组
         int [] chars1=new int[26];
         int [] chars2=new int[26];
         //初始化数组
         for(int i=0;i<s1.length();i++){
             chars1[s1.charAt(i)-'a']++;
         }
         for(int i=0;i<s1.length();i++){
             chars2[s2.charAt(i)-'a']++;
         }
         //滑动窗口，左闭右开[....)
         for(int j=0;j+s1.length()<s2.length();j++){
             if(helper(chars1,chars2)){
                 return true;
             }
             chars2[s2.charAt(j)-'a']--;
             chars2[s2.charAt(j+s1.length())-'a']++;
         }
         //最后一组没有对比到，所以最后到对比最后一组
         return helper(chars1,chars2);
    }
    private static boolean helper(int[] chars1,int [] chars2){
        for(int i=0;i<26;i++){
           if(chars1[i]!=chars2[i]){
               return false;
           }
        }
        return true;
    }
}
~~~

##### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

**int [26] 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’**
**int [128] 用于ASCII码**
**int [256] 用于扩展ASCII码**

**A的ASCII码是65，a的ASCII码是97**

![img](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1948082321,1804832497&fm=26&gp=0.jpg)

阿里巴巴开发手册说过了，**Integer要比较的话必须用.equals方法**，这个IDEA也是有提示的。

```pgsql
我想说的是 Java 用Map记录字母出现个数的写法，
最后一个测试用例通不过时，要明白一件事。
Integer是对象啊。。。
Integer会缓存频繁使用的数值，
数值范围为-128到127，在此范围内直接返回缓存值。
超过该范围就会new 一个对象。
浪费了我两个小时，希望有这种情况的老哥注意一下。
```

~~~java
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || t == null || s.length() == 0 || t.length() == 0) return "";
        // 定义一个数字，用来记录字符串 t 中出现字符的频率，也就是窗口内需要匹配的字符和相应的频率
        int[] map = new int[128];
        for (char c : t.toCharArray()) {
            map[c]++;
        }
        int left = 0, right = 0;
        int match = 0;  // 匹配字符的个数
        int minLen = s.length() + 1;   // 最大的子串的长度
        // 子串的起始位置 子串结束的位置(如果不存在这样的子串的话，start，end 都是 0，s.substring 截取就是 “”
        int start = 0, end = 0;
        while (right < s.length()){
            char charRight = s.charAt(right); // 右边界的那个字符
            map[charRight]--;   // 可以理解为需要匹配的字符 charRight 减少了一个
            // 如果字符 charRight 在 t 中存在，那么经过这一次操作，只要个数大于等于 0，说明匹配了一个
            // 若字符 charRight 不在 t 中，那么 map[charRight] < 0, 不进行任何操作
            if (map[charRight] >= 0) match++;
            right++;  // 右边界右移，这样下面就变成了 [)，方便计算窗口大小
            // 只要窗口内匹配的字符达到了要求，右边界固定，左边界收缩
            while (match == t.length()){
                int size = right - left;
                if (size < minLen){
                    minLen = size;
                    start = left;
                    end = right;
                }
                char charLeft = s.charAt(left);  // 左边的那个字符
                map[charLeft]++;  // 左边的字符要移出窗口
                // 不在 t 中出现的字符，移出窗口，最终能够达到的最大值 map[charLeft] = 0
                // 如果恰好移出了需要匹配的一个字符，那么这里 map[charLeft] > 0, 也就是还要匹配字符 charLeft，此时 match--
                if (map[charLeft] > 0) match--;
                left++;  // 左边界收缩
            }
        }
        return s.substring(start, end);
    }
}

~~~

##### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

~~~java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length==0) return 0;
       //每个位置为终点的最长序列最大值
        int dp[] =new int[nums.length];
        //每一个数都有可能是最长子序列的起点
        Arrays.fill(dp,1);
        int res=0;
        for(int i=0;i<nums.length;i++){
            //读取每个位置为终点序列的最大值
            for(int j=0;j<i;j++){
                //如果读取到的值比子序列最后的值还大，那么就可以放在这个子序列的最后，形成一个更长的子序列
                if(nums[j]<nums[i]) dp[i]=Math.max(dp[i],dp[j]+1);
            }
            res=Math.max(res,dp[i]);
        }
        return res;

    }
}
~~~

##### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
    if(nums.length==0) return 0;
     //dp数组存储当前长度最大值
    int[] dp=new int[nums.length];
    dp[0]=nums[0];
    int ans=dp[0];
    for(int i=1;i<nums.length;i++){
        dp[i]=Math.max(nums[i],nums[i]+dp[i-1]);
        ans=Math.max(ans,dp[i]);
    }
    return ans;  
    }
}
~~~

##### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

~~~java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
       int[][] dp= new int[text1.length()+1][text2.length()+1];
       for(int i=1;i<text1.length()+1;i++){
           for(int j=1;j<text2.length()+1;j++){
              if(text1.charAt(i-1)==text2.charAt(j-1)){
                  dp[i][j]=dp[i-1][j-1]+1;
              }else{
                   dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
              }
           }
       }
       return dp[text1.length()][text2.length()];
    }
}
~~~

##### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

动态规划算法，由于回文串的特性，如'aba'，我们去掉第一位和最后一位，回文串依旧是回文串，所以这里的想法是用一个二维数组来来表示当前字符串的所有子字符串的下标，那么加上回文串的特性，可以得出
S(i,j)=S(i+1,j-1) && S(i)===S(j)
这是字符串长度>2的时候的情况
然后再考虑边界情况，
当字符串长度只有1的时候，S(i,j)==true
当字符串长度为2的时候，S(i,j) = S(i)===S(i,j)
需要注意的是，在遍历的时候，注意遍历的顺序，外层的循环不应该作为字符串的起始位置

链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/dong-tai-gui-hua-jie-fa-by-183279041/

~~~java
import java.util.Arrays;
class Solution {
    //动态规划
    public String longestPalindrome(String s) {
        int len=s.length();
        if(len==0) return s;
        int maxlen=0;
        int low=0,high=0;
        boolean[][] dp =new boolean[len][len];
        for(int n=0;n<len;n++) dp[n][n]=true;
        for(int i=len-1;i>=0;i--){
            for(int j=i+1;j<len;j++){
             if(s.charAt(i)==s.charAt(j)){
                 if(i+1==j) dp[i][j]=true;
                 else dp[i][j]=dp[i+1][j-1];
             }
             else{
                 dp[i][j]=false;
             }
             //如果自身符合条件，且为最长，则记录开始与结束
             if(dp[i][j]&&j-i+1>maxlen){
                 maxlen=j-i+1;
                 low=i;
                 high=j;
             }
            }
        }
        return s.substring(low,high+1);
    }
}
~~~

## 2020.8.12 刷题

##### 面试：两个线程交替打印字母和数字

~~~java
package 数据结构与算法.多线程;
class TestCollection {

    public static void main(String[] args) {
        TestCollection test = new TestCollection();
        test.t1();
        test.t2();
    }
   //定义一个静态object类型的变量；
    public static Object obj = new Object();

    public void t1() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                synchronized (obj) {
                    try {
                        for (int i = 0; i < 26; i++) {
                            System.out.print(i);
                            obj.notifyAll();
                            obj.wait();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }

    public void t2() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                // TODO Auto-generated method stub
                synchronized (obj) {
                    try {
                        char a = 'A';
                        for (int i = 0; i < 26; i++) {
                            System.out.println((char) (a + i));
                            obj.notifyAll();
                            obj.wait();
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
~~~

##### 剑指：数组旋转

* **二分判断**

~~~java
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
     int low=0,high=array.length-1;
     int mid;
     while(low<high){
        mid=(low+high)/2;
       if(array[mid]<array[high]){
         //这里要注意，mid没有被排除
         high=mid;
       }
       else if(array[mid]>array[high]){
         low=mid+1;
       }else{
         high=high-1;
       }
     }
      return array[low];
    }
}
~~~

##### 剑指：调整数组顺序使奇数位于偶数前面

~~~java
public class Solution {
    public void reOrderArray(int [] array) {
        //使用冒泡排序的思想，如果前面是偶数，后面是奇数则交换
      boolean s;
      for(int j=0;j<array.length;j++){
        s=false;
        for(int i=0;i<array.length-1-j;i++){
            //相对于位运算符，恒等运算符优先级大一点
        if((array[i]&1)==0&&(array[i+1]&1)==1){
          int temp=array[i];
          array[i]=array[i+1];
          array[i+1]=temp;
          s=true;
        }
      }
        if(s==false) break;
      }
    }
}
~~~

**剑指：顺时针打印矩阵**

* 注意结束条件：left<=right&&top<=bottom
* 注意仅有一行top==bottom，只需要读取行，读取列会自动跳过，跳过**二次读取行**
* 仅有一列的情况，同理

~~~java
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
      //matrix.length求的是行数，matrix[0].length求的是列数，
       int left=0,right=matrix[0].length-1;
       int top=0,bottom=matrix.length-1;
       ArrayList<Integer> list= new ArrayList<Integer>();
      //首先总的结束条件应该注意
      while(left<=right&&top<=bottom){
       for(int i=left;i<=right;i++){
         list.add(matrix[top][i]);
       }
       for(int j=top+1;j<=bottom;j++){
         list.add(matrix[j][right]);
       }
        //只有一行，不需要第三步，第二步会自己跳过
       if(top!=bottom){
        for(int m=right-1;m>=left;m--){
         list.add(matrix[bottom][m]);
       } 
       }
         //只有一列，不需要第四步，第一步会自己跳过
       if(left!=right){
        for(int n=bottom-1;n>=top+1;n--){
         list.add(matrix[n][left]);
       } 
       }
      left++;
      right--;
      top++;
      bottom--;
      }
      return list;
      }  
      
}
~~~

##### 剑指：[数组中出现次数超过一半的数字](https://www.nowcoder.com/questionTerminal/e8a1b01a2df14cb2b228b30ee6a92163?answerType=1&f=discussion)

* 如果每个数字都投自己支持票，而其他数字投反对票，那么数字多的会胜出。

~~~java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
      int temp=array[0];
      int cnt=1;
      for(int i=1;i<array.length;i++){
          //判断
          if(array[i]==temp){
              cnt++; 
          }else{
              //不相等的两种情况
            if(cnt<=0){
              temp=array[i];
              cnt=1;
            }else{
              cnt--;
            }
          }
        }
      int count=0;
      for(Integer n:array){
        if(n==temp) count++;
      }
      if(count>array.length/2) return temp;
      else return 0;
    }
}
~~~

##### 剑指：扑克牌顺子

~~~java
import java.util.*;
public class Solution {
    public boolean isContinuous(int [] numbers) {
    //分情况讨论
     //首先进行排序，然后计算0之后数字间的差值
     //如果有重复则一定不可以，如果差值可以被0补掉，那么可以
      if(numbers.length==0) return false;
      Arrays.sort(numbers);
      int count=0;
      int sub=0;
      for(int i=0;i<numbers.length;i++){
        if(numbers[i]==0){
          count++;
        } 
        else{
          if(i+1<numbers.length){
            if(numbers[i+1]==numbers[i]){
              return false;
            }else{
              //这里求需要0的个数
              sub=sub+numbers[i+1]-numbers[i]-1;
            }
          }
        }
      }
      if(count>=sub) return true;
      else{
        return false;
      }
    }
}
~~~

##### 剑指：数组中重复的数字

* 由于所有数字都在0到n-1的范围，可以**原地（in-place算法）**寻找

##### 剑指：[数据流中的中位数](https://sunweiguo.github.io/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9863-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%91/)

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

因为要求的是中位数，那么这两个堆，**大顶堆用来存较小的数，从大到小排列；**
**小顶堆存较大的数，从小到大的顺序排序**，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。
保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值
当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；
当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；
取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是**取小顶堆的根节点**

##### 剑指： 二维数组中的查找

~~~java
public class Solution {
    public boolean Find(int target, int [][] array) {
    int i=0;
      //注意边界
    int j=array[0].length-1;
    
      while(i<array.length&&j>=0){
        if(array[i][j]==target){
          return true;
        }else if(array[i][j]<target)
        {
          i++;
        }else{
          j--;
        }
      }
      return false;
    }
}
~~~

## 2020.8.12 刷题

##### 面试：LRU算法

**一、什么是LRU算法？**

LRU缓存淘汰算法就是一种常用策略。LRU的全称是Least Recently Used，也就是说我们认为最近使用过的数据应该是有用的，很久都没用过的数据应该是无用的，缓存满了就优先删除那些很久没有用过的数据。

**二、实现思路？**

>首先构造函数接受一个**capacity参数**作为缓存的最大容量，然后实现两个API：
>
>一个是 put(key, val) 方法插入新的或更新已有键值对，如果缓存已满的话，要删除那个最久没用过的键值对以腾出位置插入。
>
>另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。
>
>需要注意的是，**get 和 put 方法必须都是 O(1) 的时间复杂度**。

<img src="https://img2018.cnblogs.com/blog/1566782/201907/1566782-20190713105655398-1688289084.jpg" alt="img" style="zoom:50%;" />

<img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2Fca580eb634d27ec2a8f22714f741bbaf56c2b6d1.jpg?alt=media" alt="img" style="zoom:33%;" />

**数据结构：HashMap+链表**，链表**队尾**记录最新的数据，队头**删除**旧数据

**如何写？**

1. 构造方法：传入一个最大长度capacity，作为删除阈值，并初始化链表。

2. 定义数据结构：**双向链表**，需要参数头尾结点，另外还需要一个hashmap

3. 双向链表需要三个方法：

   ~~~java
   private void addToLast(Node newNode)；//插入到尾部
   
   private  void removeNode(Node node)；//移除指定节点
   
   private  Node removeHead()；//删除头节点
       
   //更新节点状态：移除指定节点+插入到尾部
   ~~~

4. 主方法有两个：

   ~~~java
   //如果key已经存在，则更新value，并更新状态
   //如果key不存在，则插入新节点到尾部，并更新map。再判断是否需要缩减！
   public void put(int key, int value);
   //如果存在，则更新状态并返回，否则返回-1
   public  int get(int key);
   ~~~

   

**1.  静态和非静态内部类的区别？**

静态内部类的作用：只是为了降低包的深度，方便类的使用，静态内部类适用于包含类当中，但又不依赖与外在的类，不用使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。
非静态内部类有一个很大的优点：可以自由使用外部类的所有变量和方法

<img src="X:\Users\xu\AppData\Roaming\Typora\typora-user-images\image-20200813194642319.png" alt="image-20200813194642319" style="zoom:67%;" />

~~~java


public class LRUCache {
    //第三步 需要什么参数？
    //不能加private，不然子类访问不到
     int capacity;
    //private int size;
     HashMap<Integer,Node> map;
    //构造头尾结点，保证（在空结点情况下）的操作一致性
     Node head;
     Node tail;

    //第二步，写构造方法，传入最大容量参数
    LRUCache(int capacity){

        this.capacity=capacity;
        //初始化hashmap
        map=new HashMap<>();
        //构造双向链表
        head= new Node(0, 0);
        tail= new Node(0, 0);
        head.next=tail;
        tail.pre=head;
        //初始化size,也可以利用map.size(),其方法直接返回size
        //size=0;
    }
    //第一步定义数据结构
    //class应该小写！！！为什么需要static ??
     private static class Node{
        //内部有key和value
        int k;
        int v;
        //有前后指针
        Node pre;
        Node  next;
        //构造方法
        public Node(int k,int v){
            this.k=k;
            this.v=v;
        }
    }
    //第四步，写链表的三个方法
    //1 在尾部插入节点，不可能失败无返回值
    private void addToLast(Node newNode) {
         newNode.pre=tail.pre;
         newNode.next=tail;
         tail.pre.next=newNode;
         tail.pre=newNode;
    }
    //2 删除结点
    private  void removeNode(Node node){
        node.pre.next=node.next;
        node.next.pre=node.pre;
    }
    //3.删除头结点,可能没有节点,删除成功返回原来节点
    private  Node removeHead(){
        Node node=head.next;
        head.next=head.next.next;
        head.next.pre=head;
        return node;
    }
    //put方法
    public void put(int key, int value){
        //如果key不存在则插入
        Node node=map.get(key);
        if(node==null){
           Node newnode=new Node(key,value);
           //当操作链表时，别忘了操作map
           map.put(key,newnode);
           addToLast(newnode);
           if (map.size()>capacity){
               Node fristNode=removeHead();
               map.remove(fristNode.k);
           }
        }else{
            node.v=value;
            removeNode(node);
            addToLast(node);
        }
    }
    //get方法
    public  int get(int key){
        Node node=map.get(key);
        if(node!=null){
            removeNode(node);
            addToLast(node);
            return node.v;
        }else {
            return -1;
        }
    }
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
~~~

##### [78. 子集](https://leetcode-cn.com/problems/subsets/)

观察全排列/组合/子集问题，它们比较相似，且可以使用一些通用策略解决。

首先，它们的解空间非常大：

全排列：N!N!。

组合：N!N!。

子集：2^N2 

**方法一**：开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集。

~~~java
class Solution {
  public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> output = new ArrayList();
    output.add(new ArrayList<Integer>());

    for (int num : nums) {
      List<List<Integer>> newSubsets = new ArrayList();
      for (List<Integer> curr : output) {
        newSubsets.add(new ArrayList<Integer>(curr){{add(num);}});
      }
      for (List<Integer> curr : newSubsets) {
        output.add(curr);
      }
    }
    return output;
  }
}
~~~

**方法二**：回溯

~~~java
class Solution {
  List<List<Integer>> output = new ArrayList();
  int n, k;

  public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {
    // if the combination is done
    if (curr.size() == k)
      output.add(new ArrayList(curr));

    for (int i = first; i < n; ++i) {
      // add i into the current combination
      curr.add(nums[i]);
      // use next integers to complete the combination
      backtrack(i + 1, curr, nums);
      // backtrack
      curr.remove(curr.size() - 1);
    }
  }

  public List<List<Integer>> subsets(int[] nums) {
    n = nums.length;
    for (k = 0; k < n + 1; ++k) {
      backtrack(0, new ArrayList<Integer>(), nums);
    }
    return output;
  }
}
~~~

**方法三：字典排序（二进制排序） 子集**

~~~java
class Solution {
  public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> output = new ArrayList();
    int n = nums.length;

    for (int i = (int)Math.pow(2, n); i < (int)Math.pow(2, n + 1); ++i) {
      // generate bitmask, from 0..00 to 1..11
      String bitmask = Integer.toBinaryString(i).substring(1);

      // append subset corresponding to that bitmask
      List<Integer> curr = new ArrayList();
      for (int j = 0; j < n; ++j) {
        if (bitmask.charAt(j) == '1') curr.add(nums[j]);
      }
      output.add(curr);
    }
    return output;
  }
}
~~~







